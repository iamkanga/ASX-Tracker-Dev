import { initializeFirebaseAndAuth, db as hubDb, auth as hubAuth, firestore as hubFs, authFunctions as hubAuthFx, currentAppId as hubAppId, firebaseInitialized as hubInit } from './firebase.js';
import { initializeAppEventListeners } from './js/init.js';
import { setupAuthListener } from './js/auth.js';
import { loadShares, loadCashCategories, loadTriggeredAlertsListener, saveWatchlistSortOrder, loadWatchlistSortOrders, getSortOrderForWatchlist, saveViewModePreference, loadViewModePreference } from './js/dataService.js';
import { fetchLivePrices } from './js/priceService.js';
import { saveShareData as saveShareDataSvc, deleteShare as deleteShareSvc, saveWatchlistChanges as saveWatchlistChangesSvc, deleteWatchlist as deleteWatchlistSvc, saveCashAsset as saveCashAssetSvc, deleteCashCategory as deleteCashCategorySvc, deleteAllUserData as deleteAllUserDataSvc } from './js/appService.js';
import { formatMoney, formatPercent, formatAdaptivePrice, formatAdaptivePercent, formatDate, calculateUnfrankedYield, calculateFrankedYield, isAsxMarketOpen, escapeCsvValue, formatWithCommas, formatCompactNumber } from './utils.js';
import { getAllSharesData, getLivePrices, getUserWatchlists, getUserCashCategories, getCurrentSelectedWatchlistIds, getSharesAtTargetPrice, getCurrentSortOrder, getAllAsxCodes, setAllSharesData, setLivePrices, setUserWatchlists, setCurrentSelectedWatchlistIds, setSharesAtTargetPrice, setCurrentSortOrder, setAllAsxCodes, setWatchlistSortOrder } from './js/state.js';
import { applyAsxButtonsState, setAsxButtonsExpanded, getAsxButtonsExpanded, toggleCodeButtonsArrow, renderCashCategories as uiRenderCashCategories, calculateTotalCash as uiCalculateTotalCash, updateAddHeaderButton as uiUpdateAddHeaderButton, updateSidebarAddButtonContext as uiUpdateSidebarAddButtonContext, handleAddShareClick as uiHandleAddShareClick, handleAddCashAssetClick as uiHandleAddCashAssetClick } from './js/uiService.js';
// Import the centralized theme apply function and helpers so script.js delegates theme changes to a single source of truth
import { initializeTheme, applyLow52AlertTheme, applyTheme as moduleApplyTheme, updateThemeToggleAndSelector as moduleUpdateThemeToggle } from './js/theme.js';

// --- UI Element References ---
// Copilot: No-op change to trigger source control detection
const appHeader = document.getElementById('appHeader'); // Reference to the main header
const mainContainer = document.querySelector('main.container'); // Reference to the main content container
// mainTitle removed in favour of dynamicWatchlistTitle only
const addShareHeaderBtn = document.getElementById('addShareHeaderBtn'); // This will become the contextual plus icon
const newShareBtn = document.getElementById('newShareBtn');
const standardCalcBtn = document.getElementById('standardCalcBtn');
const dividendCalcBtn = document.getElementById('dividendCalcBtn');
const asxCodeButtonsContainer = document.getElementById('asxCodeButtonsContainer');
// Ensure scroll class applied (id container present in DOM from HTML)
if (asxCodeButtonsContainer && !asxCodeButtonsContainer.classList.contains('asx-code-buttons-scroll')) {
    try { asxCodeButtonsContainer.classList.add('asx-code-buttons-scroll'); } catch(_) {}
}

// Dynamic unified loader injection
try {
    // Only inject when the HTML doesn't already have a static loader element
    if (!document.getElementById('dynamic-unified-loader')) {
        const injectTarget = document.getElementById('stockWatchlistSection') || document.querySelector('main.container') || document.body;
        if (injectTarget) {
            const wrapper = document.createElement('div');
            wrapper.id = 'dynamic-unified-loader';
            wrapper.className = 'unified-loader-wrapper';
            wrapper.setAttribute('aria-hidden', 'false');
            wrapper.style.textAlign = 'center';
            wrapper.style.padding = '20px';
            wrapper.innerHTML = '<div class="loader" style="display:inline-block; vertical-align:middle; width:28px; height:28px; margin-right:8px;"></div><span class="unified-loader-text">Loading watchlist…</span>';
            // Place near top of watchlist section when possible
            try {
                const tableContainer = document.querySelector('#stockWatchlistSection .table-container');
                if (tableContainer && tableContainer.parentNode) tableContainer.parentNode.insertBefore(wrapper, tableContainer.nextSibling);
                else injectTarget.appendChild(wrapper);
            } catch(_) { injectTarget.appendChild(wrapper); }
            // Expose a helper to remove the injected loader
            window.__dynamicUnifiedLoaderId = 'dynamic-unified-loader';
        }
    }
                    } catch (e) {
                        try { console.warn('[LoaderInject] failed to inject dynamic loader', e); } catch (_) { }
                    }
// Frontend helper: call the Apps Script web app to trigger a privileged sync
// Replace DEPLOYED_WEBAPP_URL with your actual deployed Apps Script Web App URL
window.triggerServerSideGlobalSettingsSync = async function triggerServerSideGlobalSettingsSync(userId) {
    const DEPLOYED_WEBAPP_URL = 'https://script.google.com/macros/s/AKfycbwwwMEss5DIYblLNbjIbt_TAzWh54AwrfQlVwCrT_P0S9xkAoXhAUEUg7vSEPYUPOZp/exec';
    if (!userId) {
        console.warn('[SyncTrigger] userId required to trigger server-side sync');
        return { ok: false, error: 'userId required' };
    }
    // Resolve userId if not supplied
    if (!userId) {
        // Try several auth sources to find the current user's uid
        userId = currentUserId || (window.firebase && window.firebase.auth && window.firebase.auth().currentUser && window.firebase.auth().currentUser.uid) || (hubAuth && hubAuth.currentUser && hubAuth.currentUser.uid) || null;
    }
    if (!userId) {
        console.warn('[SyncTrigger] No userId available for server-side sync');
        return { ok: false, error: 'userId required' };
    }

    // Try a minimal, non-preflight POST first (application/x-www-form-urlencoded)
    const payload = 'userId=' + encodeURIComponent(userId);
    try {
        const res = await fetch(DEPLOYED_WEBAPP_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' // avoids preflight
            },
            body: payload
        });
        // If server responded with JSON, parse it. If not, fall through to json parse try/catch.
        let json = null;
        try { json = await res.json(); } catch (_) { json = { ok: false, error: 'non-json-response', status: res.status }; }
        if (!json || !json.ok) {
            console.warn('[SyncTrigger] Server-side sync returned error', json);
        } else {
            logDebug('[SyncTrigger] Server-side sync succeeded', json);
        }
        return json;
    } catch (err) {
        // If fetch failed (CORS/TypeError), attempt JSONP fallback by injecting a <script> tag to call doGet with callback
        console.warn('[SyncTrigger] Primary call failed (will attempt JSONP fallback)', err);
        return new Promise((resolve) => {
            const callbackName = '__asx_sync_cb_' + Math.random().toString(36).slice(2);
            window[callbackName] = function(result) {
                try { delete window[callbackName]; } catch(_) {}
                resolve(result || { ok: false, error: 'jsonp-no-result' });
            };
            const script = document.createElement('script');
            script.src = DEPLOYED_WEBAPP_URL + '?userId=' + encodeURIComponent(userId) + '&callback=' + callbackName;
            script.onerror = function(e) {
                try { delete window[callbackName]; } catch(_) {}
                resolve({ ok: false, error: 'jsonp-load-failed' });
            };
            document.head.appendChild(script);
            // Cleanup script tag after a short timeout
            setTimeout(() => { try { script.remove(); } catch(_) {} }, 15_000);
        });
    }
};

// Render the Global Alerts modal (#targetHitDetailsModal). This will populate two containers:
// - #targetHitDetailsModal .movers-accordion  (for GLOBAL_MOVERS up/down)
// - #targetHitDetailsModal .hilo-accordion    (for HI_LO_52W highs/lows)
// Shim: expose enforceTargetHitStyling in module scope by delegating to Rendering
// This avoids ReferenceError in this module when the function lives under window.Rendering
function enforceTargetHitStyling() {
    try {
        if (window.Rendering && typeof window.Rendering.enforceTargetHitStyling === 'function') {
            return window.Rendering.enforceTargetHitStyling();
        }
    } catch (e) {
        console.warn('[Shim] enforceTargetHitStyling delegation failed', e);
    }
    return undefined;
}

window.__renderTargetHitDetailsModalImpl = function(options={}) {
    try {
        const modal = document.getElementById('targetHitDetailsModal');
        if (!modal) { console.warn('[GlobalAlerts] targetHitDetailsModal not found'); return; }
    // Locate the real containers used in the HTML
    const gainersContainer = modal.querySelector('#globalGainersContainer');
    const losersContainer = modal.querySelector('#globalLosersContainer');
    const hiloHighContainer = modal.querySelector('#globalHigh52Container');
    const hiloLowContainer = modal.querySelector('#globalLow52Container');
    if (!gainersContainer && !losersContainer && !hiloHighContainer && !hiloLowContainer) { console.warn('[GlobalAlerts] modal containers missing'); return; }

    // Clear previous contents
    try { if (gainersContainer) gainersContainer.innerHTML = ''; } catch(_) {}
    try { if (losersContainer) losersContainer.innerHTML = ''; } catch(_) {}
    try { if (hiloHighContainer) hiloHighContainer.innerHTML = ''; } catch(_) {}
    try { if (hiloLowContainer) hiloLowContainer.innerHTML = ''; } catch(_) {}

    // Render GLOBAL_MOVERS (window.globalMovers expected shape: { up: [...], down: [...], upSample, downSample })
        // If central doc is missing or empty, fall back to the last local snapshot computed by applyGlobalSummaryFilter
        // Accept both modern '*Hits' names and legacy names (up/down). Prefer new names but fall back to legacy.
        function coerceMoversShape(raw) {
            try {
                if (!raw || typeof raw !== 'object') return null;
                // Prefer new keys
                const upList = Array.isArray(raw.upHits) ? raw.upHits : (Array.isArray(raw.up) ? raw.up : (Array.isArray(raw.upList) ? raw.upList : []));
                const downList = Array.isArray(raw.downHits) ? raw.downHits : (Array.isArray(raw.down) ? raw.down : (Array.isArray(raw.downList) ? raw.downList : []));
                const thresholds = raw.thresholds || raw.meta || null;
                return {
                    updatedAt: raw.updatedAt || raw.lastUpdated || null,
                    up: upList || [],
                    down: downList || [],
                    upCount: (upList || []).length,
                    downCount: (downList || []).length,
                    totalCount: ((upList || []).length + (downList || []).length),
                    thresholds: thresholds
                };
            } catch (_) { return null; }
        }
        let gm = coerceMoversShape(window.globalMovers);
        if (!gm || (!Array.isArray(gm.up) && !Array.isArray(gm.down))) {
            try {
                const snap = window.__lastMoversSnapshot || null;
                if (snap && Array.isArray(snap.entries)) {
                    // Build a gm-shaped object from the snapshot entries
                    const ups = snap.entries.filter(e=> e.direction === 'up').map(e=>({ code: e.code, name: e.name||null, live: e.live, prevClose: e.prev, pct: e.pct, change: e.change, direction: 'up' }));
                    const downs = snap.entries.filter(e=> e.direction === 'down').map(e=>({ code: e.code, name: e.name||null, live: e.live, prevClose: e.prev, pct: e.pct, change: e.change, direction: 'down' }));
                    gm = { updatedAt: (new Date()).toISOString(), up: ups, down: downs, upCount: ups.length, downCount: downs.length, totalCount: ups.length + downs.length, thresholds: null };
                    window.globalMovers = gm; // expose for debugging
                } else {
                    gm = window.globalMovers || { updatedAt: null, up: [], down: [], upCount: 0, downCount: 0, totalCount: 0, thresholds: null };
                }
            } catch (e) {
                gm = window.globalMovers || { updatedAt: null, up: [], down: [], upCount: 0, downCount: 0, totalCount: 0, thresholds: null };
            }
        }
    // --- Filtering refinement (frontend safeguard) ---
        // Some environments have reported an excessively large movers list (hundreds of entries)
        // when the centralized GLOBAL_MOVERS doc either (a) lacks thresholds metadata or (b) was
        // populated before stricter server filtering was deployed. To keep the UI concise and
        // useful, derive a filtered projection of the movers using (in priority order):
        //   1. gm.thresholds (authoritative server thresholds)
        //   2. User's locally configured directional thresholds (globalPercentIncrease, etc)
        //   3. A conservative default (1% move) if neither is present and raw count is large
        // The filtered projection is used for summary counts and list rendering; the raw arrays
        // remain available (gm.__rawUp / gm.__rawDown) for diagnostics.
        try {
            if (gm && (Array.isArray(gm.up) || Array.isArray(gm.down))) {
                const rawUp = Array.isArray(gm.up) ? gm.up.slice() : [];
                const rawDown = Array.isArray(gm.down) ? gm.down.slice() : [];
                const rawTotal = rawUp.length + rawDown.length;
                // Build server thresholds (coerced to numbers when present)
                let server = null;
                if (gm.thresholds) {
                    server = {
                        upPercent: gm.thresholds.upPercent != null ? Number(gm.thresholds.upPercent) : null,
                        upDollar: gm.thresholds.upDollar != null ? Number(gm.thresholds.upDollar) : null,
                        downPercent: gm.thresholds.downPercent != null ? Number(gm.thresholds.downPercent) : null,
                        downDollar: gm.thresholds.downDollar != null ? Number(gm.thresholds.downDollar) : null,
                        minimumPrice: gm.thresholds.minimumPrice != null ? Number(gm.thresholds.minimumPrice) : null
                    };
                }
                // Read CURRENT local settings every modal open (no caching) – they may have changed without reload
                function numPos(v){ return (typeof v === 'number' && isFinite(v) && v>0) ? v : null; }
                const local = {
                    upPercent: numPos(window.globalPercentIncrease),
                    upDollar: numPos(window.globalDollarIncrease),
                    downPercent: numPos(window.globalPercentDecrease),
                    downDollar: numPos(window.globalDollarDecrease),
                    minimumPrice: numPos(window.globalMinimumPrice)
                };
                // Decide effective thresholds: prefer CURRENT local settings; fall back to server when local is unset
                function preferLocal(loc, srv){ return (loc!=null && isFinite(loc) && loc>0) ? loc : ((srv!=null && isFinite(srv) && srv>0) ? srv : null); }
                const effective = {
                    upPercent: preferLocal(local.upPercent, server && server.upPercent),
                    upDollar: preferLocal(local.upDollar, server && server.upDollar),
                    downPercent: preferLocal(local.downPercent, server && server.downPercent),
                    downDollar: preferLocal(local.downDollar, server && server.downDollar),
                    minimumPrice: preferLocal(local.minimumPrice, server && server.minimumPrice)
                };
                // Tolerant filter: use whatever metrics are available; apply Min Price only when live known
                const filterFn = (item) => {
                    const live = (item.live != null && !isNaN(item.live)) ? Number(item.live) : null;
                    const prev = (item.prevClose != null && !isNaN(item.prevClose)) ? Number(item.prevClose) : (item.prevClosePrice != null && !isNaN(item.prevClosePrice) ? Number(item.prevClosePrice) : null);
                    const providedPct = (item.pct != null && !isNaN(item.pct)) ? Number(item.pct) : null;
                    const providedCh = (item.change != null && !isNaN(item.change)) ? Number(item.change) : (item.ch != null && !isNaN(item.ch) ? Number(item.ch) : null);
                    const computedCh = (live!=null && prev!=null) ? (live - prev) : null;
                    const computedPct = (computedCh!=null && prev!=null && prev!==0) ? ((computedCh/prev)*100) : null;
                    const dir = (item.direction||'').toLowerCase() || ((computedCh!=null) ? (computedCh>0?'up':(computedCh<0?'down':'')) : '');

                    if (effective.minimumPrice && live != null && live < effective.minimumPrice) return false;

                    // Evaluate thresholds using OR logic across percent and dollar
                    const evalUp = () => {
                        const pctAvail = (computedPct!=null) || (providedPct!=null);
                        const chAvail = (computedCh!=null) || (providedCh!=null);
                        const pctVal = (computedPct!=null) ? computedPct : providedPct;
                        const chVal = (computedCh!=null) ? computedCh : providedCh;
                        const pctOk = (effective.upPercent!=null && pctAvail) ? (pctVal >= effective.upPercent) : null;
                        const dolOk = (effective.upDollar!=null && chAvail) ? (Math.abs(chVal) >= effective.upDollar) : null;
                        // If at least one criterion is measurable, require that measurable one(s) pass (OR)
                        if (pctOk !== null || dolOk !== null) return (!!pctOk) || (!!dolOk);
                        // If nothing measurable but item was classified as up, keep it (don’t over-prune)
                        return true;
                    };
                    const evalDown = () => {
                        const pctAvail = (computedPct!=null) || (providedPct!=null);
                        const chAvail = (computedCh!=null) || (providedCh!=null);
                        const pctValAbs = (computedPct!=null) ? Math.abs(computedPct) : (providedPct!=null ? Math.abs(providedPct) : null);
                        const chValAbs = (computedCh!=null) ? Math.abs(computedCh) : (providedCh!=null ? Math.abs(providedCh) : null);
                        const pctOk = (effective.downPercent!=null && pctAvail) ? (pctValAbs >= effective.downPercent) : null;
                        const dolOk = (effective.downDollar!=null && chAvail) ? (chValAbs >= effective.downDollar) : null;
                        if (pctOk !== null || dolOk !== null) return (!!pctOk) || (!!dolOk);
                        return true;
                    };

                    if (dir === 'up') return evalUp();
                    if (dir === 'down') return evalDown();
                    // Unknown direction: accept if any measurable threshold passes
                    return evalUp() || evalDown();
                };
                const upFiltered = rawUp.filter(filterFn);
                const downFiltered = rawDown.filter(filterFn);
                gm.__rawUp = rawUp; gm.__rawDown = rawDown; gm.__rawTotal = rawTotal;
                gm.__serverThresholds = server; gm.__localThresholds = local; gm.__effectiveThresholds = effective;
                gm.upFiltered = upFiltered; gm.downFiltered = downFiltered; gm.filteredTotal = upFiltered.length + downFiltered.length;
                if (window.DEBUG_MODE) {
                    try { /* GlobalMovers filter diagnostics removed */ } catch(_){ }
                }
            }
        } catch (fErr) { console.warn('[GlobalMovers][filter] frontend filtering failed', fErr); }

        function renderMoverCard(o, kind) {
            const code = (o.code || o.shareCode || '').toUpperCase();
            const nameRaw = o.name || (o.companyName || '') || '';
            const name = sanitizeCompanyName(nameRaw, code);
            const liveNum = (o.live != null && !isNaN(Number(o.live))) ? Number(o.live) : null;
            const live = liveNum != null ? '$' + formatAdaptivePrice(liveNum) : '<span class="na">N/A</span>';
            const pct = (o.pct != null && !isNaN(Number(o.pct))) ? formatAdaptivePercent(Number(o.pct)) : '';
            const dirClass = (o.direction || '').toLowerCase() === 'up' ? 'up' : (o.direction || '').toLowerCase() === 'down' ? 'down' : '';
            const arrow = dirClass === 'up' ? '&#9650;' : dirClass === 'down' ? '&#9660;' : '';

            const card = document.createElement('div');
            card.className = 'notification-card mover-card ' + dirClass;
            card.setAttribute('data-code', code);
            card.innerHTML = `
                <div class="notification-card-row">
                    <div class="notification-card-left">
                        <div class="notification-code">${code}</div>
                        <div class="notification-name small">${name}</div>
                    </div>
                    <div class="notification-card-right">
                        <div class="notification-live">${live}</div>
                    </div>
                </div>
                <div class="notification-card-bottom mover-bottom-row">
                    <div class="mover-change ${dirClass}">${arrow} ${pct}</div>
                </div>`;
            // click behavior: open search/detail
            card.addEventListener('click', (e)=>{
                try { hideModal(targetHitDetailsModal); } catch(_){}
                try { openStockSearchForCode(code); } catch(_){}
            });
            return card;
        }

        // Add a scroll wrapper to ensure long lists are scrollable
        function ensureScrollHost(container){
            if (!container) return null;
            let inner = container.querySelector('.notification-list-inner');
            if (!inner) {
                inner = document.createElement('div'); inner.className = 'notification-list-inner';
                while (container.firstChild) inner.appendChild(container.firstChild);
                container.appendChild(inner);
                container.classList.add('notification-list-host');
            }
            return inner;
        }
        const gainersInner = ensureScrollHost(gainersContainer);
        const losersInner = ensureScrollHost(losersContainer);
        function renderMoversInto(containerInner, items, dir) {
            try {
                const fragment = document.createDocumentFragment();
                let arr = Array.isArray(items) ? items.slice() : [];
                arr.forEach(it => {
                    let card;
                    try {
                        // Try to use the normal card if possible
                        const live = (it.live != null && !isNaN(it.live)) ? Number(it.live) : null;
                        const prev = (it.prevClose != null && !isNaN(it.prevClose)) ? Number(it.prevClose) : null;
                        const hasMovement = (it.pct != null && !isNaN(it.pct)) || (it.change != null && !isNaN(it.change)) || (live != null && prev != null);
                        if (hasMovement) {
                            card = renderMoverCardWithMovement(it);
                        } else {
                            // Fallback: minimal card with just code and name
                            const code = (it.code || it.shareCode || '').toUpperCase();
                            const name = sanitizeCompanyName(it.name || it.companyName || '', code);
                            card = document.createElement('div');
                            card.className = 'notification-card mover-card';
                            card.setAttribute('data-code', code);
                            card.innerHTML = `
                                <div class="notification-card-row">
                                    <div class="notification-card-left">
                                        <div class="notification-code">${code}</div>
                                        <div class="notification-name small">${name}</div>
                                    </div>
                                    <div class="notification-card-right">
                                        <div class="notification-live"><span class='na'>No movement data</span></div>
                                    </div>
                                </div>
                            `;
                            card.addEventListener('click', ()=>{ try{ hideModal(targetHitDetailsModal); }catch(_){} openStockSearchForCode(code); });
                        }
                    } catch (e) {
                        card = document.createElement('div');
                        card.className = 'notification-card mover-card';
                        card.textContent = '[Error rendering entry]';
                    }
                    fragment.appendChild(card);
                });
                containerInner.appendChild(fragment);
            } catch (err) { console.warn('renderMoversIntoHost failed', err); }
        }

                // Extended mover card showing dollar and percent changes
            function renderMoverCardWithMovement(o) {
                const code = (o.code || o.shareCode || '').toUpperCase();
                const name = sanitizeCompanyName(o.name || o.companyName || '', code);
                const liveNum = (o.live != null && !isNaN(Number(o.live))) ? Number(o.live) : null;
                const prev = (o.prevClose != null && !isNaN(Number(o.prevClose))) ? Number(o.prevClose) : (o.prevClosePrice != null ? Number(o.prevClosePrice) : null);
                const ch = (liveNum != null && prev != null) ? Number((liveNum - prev).toFixed(2)) : (o.ch != null ? Number(o.ch) : null);
                const pct = (ch != null && prev != null && prev !== 0) ? Number(((ch / prev) * 100).toFixed(2)) : (o.pct != null ? Number(o.pct) : null);
                const dirClass = (ch === null || ch === 0) ? 'flat' : (ch > 0 ? 'up' : 'down');
                const arrow = dirClass === 'up' ? '▲' : (dirClass === 'down' ? '▼' : '');

                const card = document.createElement('div');
                card.className = 'notification-card mover-card ' + dirClass;
                card.setAttribute('data-code', code);
                const pctText = (pct!=null) ? `${pct>0?'+':''}${pct}%` : '';
                const chText = (ch!=null) ? `${ch>0?'+':''}$${Number(ch).toFixed(2)}` : '-';
                card.innerHTML = `
                    <div class="notification-card-row">
                        <div class="notification-card-left">
                            <div class="notification-code">${code}</div>
                            <div class="notification-name small">${name}</div>
                        </div>
                        <div class="notification-card-right">
                            <div class="notification-live">${liveNum!=null?('$'+formatAdaptivePrice(liveNum)):'<span class="na">N/A</span>'}</div>
                        </div>
                    </div>
                    <div class="notification-card-bottom mover-bottom-row">
                        <div class="mover-change ${dirClass}">${arrow} ${chText}${pctText?` (${pctText})`:''}</div>
                    </div>`;
                card.addEventListener('click', ()=>{ try{ hideModal(targetHitDetailsModal); }catch(_){} openStockSearchForCode(code); });
                return card;
            }

            // Build sections from filtered arrays
            let upArr = (gm && Array.isArray(gm.upFiltered)) ? gm.upFiltered : (Array.isArray(gm.up) ? gm.up : []);
            let downArr = (gm && Array.isArray(gm.downFiltered)) ? gm.downFiltered : (Array.isArray(gm.down) ? gm.down : []);
            // Fallback: if filtering produced empty results but raw arrays are populated, use raw arrays to avoid blank UI
            if (Array.isArray(gm.up) && upArr.length === 0 && gm.up.length > 0) upArr = gm.up;
            if (Array.isArray(gm.down) && downArr.length === 0 && gm.down.length > 0) downArr = gm.down;
            // EXTRA: If both filtered and raw are empty, but the original data exists, try to use the original data
            if ((!Array.isArray(upArr) || upArr.length === 0) && Array.isArray(gm.up) && gm.up.length > 0) upArr = gm.up;
            if ((!Array.isArray(downArr) || downArr.length === 0) && Array.isArray(gm.down) && gm.down.length > 0) downArr = gm.down;
            // Add thresholds hint to headers via title attribute
            const eff = gm && gm.__effectiveThresholds ? gm.__effectiveThresholds : (gm && gm.thresholds ? gm.thresholds : null);
            function thresholdsLabel(eff){
                if (!eff) return '';
                const parts = [];
                if (eff.upPercent || eff.upDollar) parts.push(`Up ≥ ${eff.upPercent?eff.upPercent+'%':''}${(eff.upPercent&&eff.upDollar)?' or ':''}${eff.upDollar?('$'+eff.upDollar):''}`.trim());
                if (eff.downPercent || eff.downDollar) parts.push(`Down ≥ ${eff.downPercent?eff.downPercent+'%':''}${(eff.downPercent&&eff.downDollar)?' or ':''}${eff.downDollar?('$'+eff.downDollar):''}`.trim());
                if (eff.minimumPrice) parts.push(`Min Price $${eff.minimumPrice}`);
                return parts.join(' | ');
            }
            // Insert contextual explainers for each section
            function insertExplainer(host, text, targetKey){
                try {
                    if (!host) return;
                    const existing = host.querySelector('.section-explainer');
                    if (existing) existing.remove();
                    const el = document.createElement('div');
                    el.className = 'section-explainer';
                    el.setAttribute('role', 'button');
                    el.setAttribute('tabindex', '0');
                    el.textContent = text || '';
                    if (targetKey) el.setAttribute('data-settings-target', targetKey);
                    host.insertBefore(el, host.firstChild);
                } catch(_) {}
            }
            // Build always-on explainer labels using current thresholds with 'Not set' placeholders
            // Merge per-field with effective server thresholds so we don't show 'Not set' due to timing
            const baseThr = (typeof window.getCurrentDirectionalThresholds === 'function' ? window.getCurrentDirectionalThresholds() : {}) || {};
            const toNum = (v) => {
                const n = Number(v);
                return (v != null && isFinite(n) && n > 0) ? n : null;
            };
            const curThr = {
                upPercent: (toNum(baseThr.upPercent) != null ? toNum(baseThr.upPercent) : (eff ? toNum(eff.upPercent) : null)),
                upDollar: (toNum(baseThr.upDollar) != null ? toNum(baseThr.upDollar) : (eff ? toNum(eff.upDollar) : null)),
                downPercent: (toNum(baseThr.downPercent) != null ? toNum(baseThr.downPercent) : (eff ? toNum(eff.downPercent) : null)),
                downDollar: (toNum(baseThr.downDollar) != null ? toNum(baseThr.downDollar) : (eff ? toNum(eff.downDollar) : null)),
                minimumPrice: (toNum(baseThr.minimumPrice) != null ? toNum(baseThr.minimumPrice) : (eff ? toNum(eff.minimumPrice) : null))
            };
            const upLabel = (function(){
                const pct = (curThr.upPercent != null && isFinite(curThr.upPercent) && curThr.upPercent > 0) ? (Number(curThr.upPercent).toFixed(0) + '%') : null;
                const dol = (curThr.upDollar != null && isFinite(curThr.upDollar) && curThr.upDollar > 0) ? ('$' + Number(curThr.upDollar).toFixed(2)) : null;
                const move = (pct || dol) ? `Gainers ≥ ${[pct, dol].filter(Boolean).join(' or ')}` : 'Gainers ≥ Not set';
                const minP = (curThr.minimumPrice != null && isFinite(curThr.minimumPrice) && curThr.minimumPrice > 0) ? ('$' + Number(curThr.minimumPrice).toFixed(2)) : 'Not set';
                return `${move} | Min Price: ${minP}`;
            })();
            const downLabel = (function(){
                const pct = (curThr.downPercent != null && isFinite(curThr.downPercent) && curThr.downPercent > 0) ? (Number(curThr.downPercent).toFixed(0) + '%') : null;
                const dol = (curThr.downDollar != null && isFinite(curThr.downDollar) && curThr.downDollar > 0) ? ('$' + Number(curThr.downDollar).toFixed(2)) : null;
                const move = (pct || dol) ? `Losers ≥ ${[pct, dol].filter(Boolean).join(' or ')}` : 'Losers ≥ Not set';
                const minP = (curThr.minimumPrice != null && isFinite(curThr.minimumPrice) && curThr.minimumPrice > 0) ? ('$' + Number(curThr.minimumPrice).toFixed(2)) : 'Not set';
                return `${move} | Min Price: ${minP}`;
            })();

            // Always refresh explainers for consistency with 52-week sections
            if (gainersContainer) insertExplainer(gainersContainer, upLabel, 'global-gainers');
            if (losersContainer) insertExplainer(losersContainer, downLabel, 'global-losers');

            if (gainersInner) {
                const items = upArr.filter(x => (x.direction||'').toLowerCase()==='up');
                renderMoversInto(gainersInner, items, 'up');
            }
            if (losersInner) {
                const items = downArr.filter(x => (x.direction||'').toLowerCase()==='down');
                renderMoversInto(losersInner, items, 'down');
            }
        

        // Render HI_LO_52W
        // Prefer centralized HI_LO_52W, but don't leave UI blank: if highs/lows are empty, derive a local projection from livePrices
        const hiloSource = window.globalHiLo52Alerts || {};
        const hilo = {
            highs: (hiloSource && Array.isArray(hiloSource.highs)) ? [...hiloSource.highs] : [],
            lows: (hiloSource && Array.isArray(hiloSource.lows)) ? [...hiloSource.lows] : []
        };

        // Local fallback: compute 52-week highs/lows from available livePrices if either list is empty
        try {
            const needHighs = !Array.isArray(hilo.highs) || hilo.highs.length === 0;
            const needLows = !Array.isArray(hilo.lows) || hilo.lows.length === 0;
            if (needHighs || needLows) {
                const local = (function computeLocalHiLoProjection() {
                    const result = { highs: [], lows: [] };
                    try {
                        const epsilon = 0.01; // small buffer for comparisons
                        const minPrice = (typeof hiLoMinimumPrice === 'number' && hiLoMinimumPrice > 0) ? hiLoMinimumPrice : null;
                        const entries = (livePrices && typeof livePrices === 'object') ? Object.entries(livePrices) : [];
                        for (const [code, lp] of entries) {
                            if (!lp || lp.live == null || isNaN(lp.live)) continue;
                            if (minPrice != null && lp.live < minPrice) continue; // respect Min Price if set
                            const hi = (lp.High52 != null && !isNaN(lp.High52)) ? lp.High52 : null;
                            const lo = (lp.Low52 != null && !isNaN(lp.Low52)) ? lp.Low52 : null;
                            const name = lp.companyName || null;
                            if (needHighs && hi != null && lp.live >= (hi - epsilon)) {
                                result.highs.push({ code, name, live: lp.live, high52: hi, low52: lo, type: 'high' });
                            }
                            if (needLows && lo != null && lp.live <= (lo + epsilon)) {
                                result.lows.push({ code, name, live: lp.live, high52: hi, low52: lo, type: 'low' });
                            }
                        }
                    } catch (e) { console.warn('[HiLo52][fallback] local projection failed', e); }
                    return result;
                })();
                if (needHighs) hilo.highs = local.highs;
                if (needLows) hilo.lows = local.lows;
            }
        } catch(_) { /* non-fatal */ }
    function renderHiLoEntry(e, kind) {
        const code = String(e.code || e.shareCode || '').toUpperCase();
        // Clean up embedded code fragments from company names (e.g., "(ASX:ABC)", "(ABC)", "- ABC")
    const name = sanitizeCompanyName(e.name || e.companyName || code, code);
            const liveVal = (e.live!=null && !isNaN(Number(e.live))) ? Number(e.live) : null;
            const liveDisplay = (liveVal!=null) ? ('$' + formatAdaptivePrice(liveVal)) : '<span class="na">N/A</span>';
            // Pull both 52W High and Low from entry or livePrices fallback
            let lp = null; try { lp = (window.livePrices && window.livePrices[code]) ? window.livePrices[code] : null; } catch(_) {}
            const hiRaw = (e.high52 ?? e.High52 ?? e.hi52 ?? e.high ?? (lp ? (lp.high52 ?? lp.High52 ?? lp.hi52 ?? lp.high) : null) ?? null);
            const loRaw = (e.low52 ?? e.Low52 ?? e.lo52 ?? e.low ?? (lp ? (lp.low52 ?? lp.Low52 ?? lp.lo52 ?? lp.low) : null) ?? null);
            const hiDisplay = (hiRaw!=null && !isNaN(Number(hiRaw))) ? ('$' + formatAdaptivePrice(Number(hiRaw))) : '?';
            const loDisplay = (loRaw!=null && !isNaN(Number(loRaw))) ? ('$' + formatAdaptivePrice(Number(loRaw))) : '?';
            const card = document.createElement('div');
            card.className = 'notification-card hilo-card ' + kind;
            card.innerHTML = `
                <div class="notification-card-row">
                    <div class="notification-card-left">
                        <div class="notification-code">${code}</div>
                        <div class="notification-name small">${name}</div>
                    </div>
                    <div class="notification-card-right">
                            <div class="notification-live">${liveDisplay}</div>
                    </div>
                </div>
                <div class="notification-card-bottom hilo-bottom-row">
                    <div class="hilo-low"><span class="label">Low:</span> ${loDisplay}</div>
                    <div class="hilo-high"><span class="label">High:</span> ${hiDisplay}</div>
                </div>`;
            card.addEventListener('click', ()=>{
                try { hideModal(targetHitDetailsModal); } catch(_) {}
                try {
                    const list = (window.allSharesData || []);
                    const share = list.find(s => s && s.shareName && String(s.shareName).toUpperCase() === code);
                    if (share && typeof selectShare === 'function') {
                        try { wasShareDetailOpenedFromTargetAlerts = true; } catch(_) {}
                        selectShare(share.id);
                        if (typeof showShareDetails === 'function') showShareDetails();
                        return;
                    }
                } catch(_) {}
                // Fallback: if share not found locally, open search (should be rare per user flow)
                try { if (typeof openStockSearchForCode === 'function') openStockSearchForCode(code); } catch(_) {}
            });
            return card;
        }

        // Ensure fixed header (explainer) with inner scroll for hi/lo sections
        if (hiloHighContainer) {
            // Ensure host/inner structure
            const highInner = ensureScrollHost(hiloHighContainer);
            // Insert explainer pinned above the inner
            (function insertHiExplainer(){
                try {
                    const toNum = (v)=>{ const n = Number(v); return (v!=null && isFinite(n) && n>0) ? n : null; };
                    const mpNum = toNum(hiLoMinimumPrice);
                    const mcNum = toNum(hiLoMinimumMarketCap);
                    const mp = (mpNum!=null) ? ('$' + mpNum.toFixed(2)) : 'Not set';
                    const mc = (mcNum!=null) ? ('$' + formatCompactNumber(mcNum)) : 'Not set';
                    insertExplainer(hiloHighContainer, `Min Price: ${mp} | Min Mkt Cap: ${mc}`, '52w-highs');
                } catch(_) { insertExplainer(hiloHighContainer, 'Min Price: Not set | Min Mkt Cap: Not set'); }
            })();
            // Render cards into the inner scroller
            if (highInner) {
                highInner.innerHTML = '';
                const fragH = document.createDocumentFragment();
                (hilo.highs || []).forEach(e => { fragH.appendChild(renderHiLoEntry(e, 'high')); });
                highInner.appendChild(fragH);
            }
        }
        if (hiloLowContainer) {
            const lowInner = ensureScrollHost(hiloLowContainer);
            (function insertLoExplainer(){
                try {
                    const toNum = (v)=>{ const n = Number(v); return (v!=null && isFinite(n) && n>0) ? n : null; };
                    const mpNum = toNum(hiLoMinimumPrice);
                    const mcNum = toNum(hiLoMinimumMarketCap);
                    const mp = (mpNum!=null) ? ('$' + mpNum.toFixed(2)) : 'Not set';
                    const mc = (mcNum!=null) ? ('$' + formatCompactNumber(mcNum)) : 'Not set';
                    insertExplainer(hiloLowContainer, `Min Price: ${mp} | Min Mkt Cap: ${mc}`, '52w-lows');
                } catch(_) { insertExplainer(hiloLowContainer, 'Min Price: Not set | Min Mkt Cap: Not set'); }
            })();
            if (lowInner) {
                lowInner.innerHTML = '';
                const fragL = document.createDocumentFragment();
                (hilo.lows || []).forEach(e => { fragL.appendChild(renderHiLoEntry(e, 'low')); });
                lowInner.appendChild(fragL);
            }
        }

        // Mark this modal as rendered via the modern global sections path so legacy fallbacks can skip duplicating UI
        try { modal.__newGlobalRendered = true; } catch(_) {}

        // Show modal via existing helper if present
            try { if (typeof window.showModal === 'function') { showModal(modal); } else { modal.style.display = 'flex'; modal.classList.add('show'); } } catch(_) { modal.style.display = 'flex'; modal.classList.add('show'); }
            // Minimal reliability guard: if both movers and hilo sections are still empty shortly after open, retry once.
            try {
                setTimeout(() => {
                    try {
                        const isEmpty = (host) => {
                            if (!host) return true;
                            const inner = host.querySelector('.notification-list-inner');
                            return !inner || inner.children.length === 0;
                        };
                        const moversEmpty = isEmpty(gainersContainer) && isEmpty(losersContainer);
                        const stillEmpty = moversEmpty && isEmpty(hiloHighContainer) && isEmpty(hiloLowContainer);
                        if (stillEmpty && typeof window.__renderTargetHitDetailsModalImpl === 'function' && !modal.__retryOnce) {
                            modal.__retryOnce = true;
                            window.__renderTargetHitDetailsModalImpl({ retry: true });
                        }
                    } catch(_) {}
                }, 150);
            } catch(_) {}
    } catch (err) {
        console.warn('[GlobalAlerts] showTargetHitDetailsModal (impl) failed', err);
    }
};

// Debug mode toggle - set to true locally for verbose debugging output
// You can flip this in the console via: DEBUG_MODE = true/false
window.DEBUG_MODE = (typeof window.DEBUG_MODE !== 'undefined') ? window.DEBUG_MODE : false;

function debugLog() {
    if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
           try { console.log.apply(console, arguments); } catch(_) {}
    }
}

function debugDebug() {
    if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
           try { console.debug.apply(console, arguments); } catch(_) {}
    }
}

// Remove duplicate code fragments from company names since the code is already displayed separately.
// Examples removed: " (ASX:ABC)", " - ABC", " (ABC)", leading code prefixes like "ABC - ".
function sanitizeCompanyName(name, code) {
    try {
        if (!name) return '';
        const c = (code || '').toUpperCase();
        let n = String(name);
        // Patterns to strip
        const patterns = [
            new RegExp(`\\s*\\(ASX:${c}\\)`, 'i'),
            new RegExp(`\\s*\\(${c}\\)`, 'i'),
            new RegExp(`^${c}\\s*[-–:/\\|]\\s*`, 'i'),
            new RegExp(`\\s*[-–:/\\|]\\s*${c}$`, 'i')
        ];
        patterns.forEach(rx => { n = n.replace(rx, ''); });
        return n.trim();
    } catch(_) { return name || ''; }
}

// Lightweight console filter: when DEBUG_MODE is false, suppress noisy diagnostic logs
// that begin with known diagnostic tags. This keeps regular console output intact.
(function installConsoleFilter(){
    try {
            // Aggressive tag list: any console message whose first argument string begins with
            // one of these tags will be suppressed when DEBUG_MODE is false.
            const tags = [
                // existing diagnostics
                '[BANNER-DEBUG]','[Diag]','[TEST]','[DiagnosticsDump]','[MOVERS DEBUG]','[ASX Debug]','[NotifDiag]','[GlobalAlerts] Listener',
                // expanded suppression list (from user QA)
                '[DISPLAY]','[PADDING DEBUG]','[SORT HANDSHAKE]','[SCROLL DEBUG]','[SingleScroll]','[TypographyDiagnostics]','[SCROLL DEBUG]',
                '[SYNC]','[SyncTrigger]','[Movers init]','[Movers fallback]','[DEBUG]','[ELEMENT CHECK]','[TOGGLE DEBUG]','[GlobalAlerts]','[DiagDirectional]'
            ];
        const rawLog = console.log.bind(console);
        const rawDebug = console.debug ? console.debug.bind(console) : rawLog;
    const rawInfo = console.info ? console.info.bind(console) : rawLog;
        console.log = function(...args){
            try {
                if (!window.DEBUG_MODE && args && args.length && typeof args[0] === 'string') {
                    const a0 = args[0];
                    for (let t of tags) { if (a0.indexOf(t) === 0) return; }
                }
            } catch(_){}
            return rawLog.apply(console, args);
        };
        console.debug = function(...args){
            try {
                if (!window.DEBUG_MODE && args && args.length && typeof args[0] === 'string') {
                    const a0 = args[0];
                    for (let t of tags) { if (a0.indexOf(t) === 0) return; }
                }
            } catch(_){}
            return rawDebug.apply(console, args);
        };
        console.info = function(...args){
            try {
                if (!window.DEBUG_MODE && args && args.length && typeof args[0] === 'string') {
                    const a0 = args[0];
                    for (let t of tags) { if (a0.indexOf(t) === 0) return; }
                }
            } catch(_){ }
            return rawInfo.apply(console, args);
        };
    } catch(_){}
})();

// Patch wrapper: after saving settings, also trigger the server-side sync (fire-and-forget)
(function patchSaveGlobalAlertSettingsToTriggerServerSync(){
    const original = saveGlobalAlertSettingsDirectional;
    saveGlobalAlertSettingsDirectional = async function(settings) {
        try { await original(settings); } catch(e){ console.warn('[GlobalAlerts] original save failed', e); }
        try {
            const uid = currentUserId || (window.firebase && window.firebase.auth && window.firebase.auth().currentUser && window.firebase.auth().currentUser.uid);
            if (uid) {
                window.triggerServerSideGlobalSettingsSync(uid).catch(()=>{});
            } else {
                console.warn('[SyncTrigger] No user id available for server-side sync');
            }
        } catch (err) { console.warn('[SyncTrigger] Trigger failed', err); }
    };
})();
// Keep main content padding in sync with header height changes (e.g., viewport resize)
window.addEventListener('resize', () => requestAnimationFrame(adjustMainContentPadding));
document.addEventListener('DOMContentLoaded', () => requestAnimationFrame(adjustMainContentPadding));
// Ensure UI refs are initialized before any listeners that use them
// (moved UI const declarations to top after imports)
// Diagnostic: overlay listener singleton self-check
// Global delegated handlers for inputs with class `smart-ph`.
// Use focusin/input/focusout so dynamic elements are handled and mobile browsers react correctly.
try {
    document.addEventListener('focusin', (e) => {
        const t = e.target;
        if (t && t.matches && t.matches('input.smart-ph')) {
            if (!t.dataset._ph) t.dataset._ph = t.getAttribute('placeholder') || '';
            t.setAttribute('placeholder', '');
        }
    });
    document.addEventListener('input', (e) => {
        const t = e.target;
        if (t && t.matches && t.matches('input.smart-ph')) {
            if (t.value && t.value.length > 0) t.setAttribute('placeholder', '');
        }
    });
    document.addEventListener('focusout', (e) => {
        const t = e.target;
        if (t && t.matches && t.matches('input.smart-ph')) {
            if (!t.value || t.value.length === 0) {
                const original = t.dataset._ph || '';
                if (original) t.setAttribute('placeholder', original);
                else t.removeAttribute('placeholder');
            }
        }
    });
} catch (_) {}
document.addEventListener('DOMContentLoaded', () => {
    try {
        const ov = document.getElementById('sidebarOverlay') || document.querySelector('.sidebar-overlay');
        if (ov) {
            // Lightweight listener probe (no diagnostic logging)
            try { ov.addEventListener('mousedown', () => {}, { once: true }); ov.dispatchEvent(new Event('mousedown')); } catch(_) {}
        }
    } catch(e) { console.warn('[Diag] Overlay singleton check failed', e); }
});
// ...existing code...



// Simplified mute button handler after layout fix
function fixLow52MuteButton(card) {
    if (!card) return;
    const muteBtn = card.querySelector('.low52-mute-btn');
    if (muteBtn) {
            muteBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                card.classList.toggle('low52-card-hidden');
            });
    }
}

// Example usage after rendering a 52-week alert card:
// applyLow52AlertTheme(cardEl, 'low');
// fixLow52MuteButton(cardEl);

// Title mutation observer guard to restore if emptied by outside DOM ops
try {
    (function installTitleGuard(){
        if (window.__titleGuardInstalled) return; window.__titleGuardInstalled = true;
        const host = document.getElementById('dynamicWatchlistTitle'); if(!host) return;
        const obs = new MutationObserver(()=>{
            try {
                const span = document.getElementById('dynamicWatchlistTitleText');
                if (!span) return;
                if (!span.textContent || !span.textContent.trim()) {
                    let wid = getCurrentSelectedWatchlistIds() && getCurrentSelectedWatchlistIds()[0];
                    let expected;
                    if (wid === '__movers') expected = 'Movers';
                    else if (wid === 'portfolio') expected = 'Portfolio';
                    else if (wid === CASH_BANK_WATCHLIST_ID) expected = 'Cash & Assets';
                    else if (wid === ALL_SHARES_ID) expected = 'All Shares';
                    else {
                        const wl = (userWatchlists||[]).find(w=>w.id===wid);
                        expected = (wl && wl.name) ? wl.name : 'Share Watchlist';
                    }
                    span.textContent = expected;
                    console.warn('[TitleGuard] Restored empty dynamic title to:', expected);
                }
            } catch(_) {}
        });
        obs.observe(host, { childList:true, characterData:true, subtree:true });
    })();
} catch(_) {}

// ...existing code...
// Historical enforcement patch removed (cleanup)


// [Copilot Update] Source control helper
// This function is a placeholder for automating source control actions (e.g., git add/commit)
// and for tracking how many times files have been made available to source control.
// Usage: Call makeFilesAvailableToSourceControl() after major changes if you want to automate this.
let sourceControlMakeAvailableCount = 0;
function makeFilesAvailableToSourceControl() {
    // This is a placeholder for future automation (e.g., via backend or extension)
    // Instructs the user to use git or triggers a VS Code command if available
    sourceControlMakeAvailableCount++;
    if (window && window.showCustomAlert) {
        window.showCustomAlert('Files are ready for source control. (Count: ' + sourceControlMakeAvailableCount + ')', 2000);
    } else {
        // no-op fallback for non-UI environments
    }
    // To actually add to git, run: git init; git add .; git commit -m "Initial commit"
}
// End Copilot source control helper

// --- 52-Week Low Alert State ---
let sharesAt52WeekLow = [];
const triggered52WeekLowSet = new Set();
// Load muted 52-week alerts from session storage
let __low52MutedMap = {};
try {
    const stored = sessionStorage.getItem('low52MutedMap');
    if (stored) {
        __low52MutedMap = JSON.parse(stored);
    }
} catch (e) {
    __low52MutedMap = {};
}
window.__low52MutedMap = __low52MutedMap;

// Helper: Sort shares by percentage change
function sortSharesByPercentageChange(shares) {
    return shares.slice().sort((a, b) => {
        const liveA = livePrices[a.shareName?.toUpperCase()]?.live;
        const prevA = livePrices[a.shareName?.toUpperCase()]?.prevClose;
        const liveB = livePrices[b.shareName?.toUpperCase()]?.live;
        const prevB = livePrices[b.shareName?.toUpperCase()]?.prevClose;
        const pctA = (prevA && liveA) ? ((liveA - prevA) / prevA) : 0;
        const pctB = (prevB && liveB) ? ((liveB - prevB) / prevB) : 0;
        return pctB - pctA; // Descending
    });
}

// Live prices hook: always re-apply current sort and re-render the watchlist
// After any live-price update we must ensure the list reflects new prices and is resorted
function onLivePricesUpdated() {
    try {
        // Prefer calling the canonical sort routine which also triggers renderWatchlist()
        if (typeof sortShares === 'function') {
            try {
                logDebug && logDebug('Live Price: Invoking sortShares() after live update');
            } catch(_) {}
            try { sortShares(); } catch (sErr) { console.warn('Live Price: sortShares() failed, falling back to renderWatchlist()', sErr); if (typeof renderWatchlist === 'function') try { renderWatchlist(); } catch(_) {} }
        } else if (typeof renderWatchlist === 'function') {
            // If sortShares is not available, at least re-render the watchlist
            try { renderWatchlist(); } catch(e) { console.warn('Live Price: renderWatchlist() failed in onLivePricesUpdated', e); }
        }

        // Also refresh portfolio list if visible
        try {
            if (typeof renderPortfolioList === 'function') {
                const section = document.getElementById('portfolioSection');
                if (section && section.style.display !== 'none') {
                    try { renderPortfolioList(); } catch(e) { console.warn('Live Price: renderPortfolioList failed', e); }
                }
            }
        } catch (_) {}

        // After dynamic content changes, reposition & optionally scroll to top.
        try { if (window.repositionMainContentUnderHeader) window.repositionMainContentUnderHeader(); else if (window.adjustMainContentPadding) { window.adjustMainContentPadding(); if (window.scrollMainToTop) window.scrollMainToTop(true); } } catch(_) {}
    } catch (e) {
        console.error('Live Price: onLivePricesUpdated error:', e);
    }
}

// Compatibility stub (legacy callsites may invoke)
function forceApplyCurrentSort() { /* legacy no-op retained */ }
document.addEventListener('DOMContentLoaded', function () {
    // --- Watchlist logic moved to watchlist.js ---
    // Import and call watchlist functions
    if (window.watchlistModule) {
        window.watchlistModule.renderWatchlistSelect();
    // If we have a persisted lastKnownTargetCount, ensure the notification icon restores pre-live-load
    try { if (typeof updateTargetHitBanner === 'function') updateTargetHitBanner(); } catch(e) { console.warn('Early Target Alert restore failed', e); }
        window.watchlistModule.populateShareWatchlistSelect();
        window.watchlistModule.ensurePortfolioOptionPresent();
        setTimeout(window.watchlistModule.ensurePortfolioOptionPresent, 2000);
    }

    // Automatic closed-market banner and ghosting
    const marketStatusBanner = document.getElementById('marketStatusBanner');
    function formatSydneyDate(d) {
        return new Intl.DateTimeFormat('en-AU', { timeZone: 'Australia/Sydney', day: '2-digit', month: '2-digit', year: 'numeric' }).format(d);
    }
    function isAfterCloseUntilMidnightSydney() {
        const now = new Date();
        const opts = { hour: 'numeric', minute: 'numeric', hour12: false, timeZone: 'Australia/Sydney' };
        const timeStr = new Intl.DateTimeFormat('en-AU', opts).format(now);
        const [h, m] = timeStr.split(':').map(Number);
        return (h > 16) || (h === 16 && m >= 0);
    }
    function updateMarketStatusUI() {
    const open = isAsxMarketOpen();
        if (marketStatusBanner) {
            if (!open) {
                const now = new Date();
                // Snapshot is the last fetched live as at close; show date to avoid weekend ambiguity
                marketStatusBanner.textContent = `ASX market is closed. Showing final prices from today. (${formatSydneyDate(now)})`;
                marketStatusBanner.classList.remove('app-hidden');
            } else {
                marketStatusBanner.textContent = '';
                marketStatusBanner.classList.add('app-hidden');
            }
        }
    // No global disabling; controls remain enabled regardless of market state
    }
    // Initial status and periodic re-check each minute
    updateMarketStatusUI();
    setInterval(updateMarketStatusUI, 60 * 1000);

    // Ensure Edit Current Watchlist button updates when selection changes
    if (typeof watchlistSelect !== 'undefined' && watchlistSelect) {
        watchlistSelect.addEventListener('change', function () {
            // Capture previous selection for shallow back
            try { const prev = Array.isArray(getCurrentSelectedWatchlistIds()) ? getCurrentSelectedWatchlistIds().slice(0) : []; pushAppStateEntry('watchlist', prev); logBackDebug('WATCHLIST change push prev=', prev); } catch(_) {}
            // If Portfolio is selected, show portfolio view
            if (watchlistSelect.value === 'portfolio') {
                showPortfolioView();
                try { setLastSelectedView('portfolio'); } catch(e){}
            } else {
                // Default: show normal watchlist view
                showWatchlistView();
                try { setLastSelectedView(watchlistSelect.value); } catch(e){}
            }
            // Push a browser history entry so Back triggers popstate -> handleGlobalBack
            try { if (typeof pushAppState === 'function') pushAppState({ watchlist: watchlistSelect.value }, '', '#watchlist'); } catch(_) {}
            updateMainButtonsState(true);
            // Ensure main content scrolls to the top after a view change for consistent UX
            try {
                if (window.repositionMainContentUnderHeader) {
                    window.repositionMainContentUnderHeader();
                } else if (window.scrollMainToTop) {
                    window.scrollMainToTop();
                } else {
                    scrollMainToTop();
                }
            } catch(_) {}
        });
    }

    // Helper: scroll main content to specified position in a resilient way
    function scrollMainToTop(instant = false, targetPosition = 0) {
        try {
            // Prefer the global smart implementation defined by UI module if present
            if (typeof window !== 'undefined' && window.scrollMainToTop && window.scrollMainToTop !== scrollMainToTop) {
                try { window.scrollMainToTop(instant, targetPosition); return; } catch (err) { /* ignore */ }
            }
            const el = document.querySelector('main.container');
            if (el) {
                try {
                    el.scrollTo({ top: targetPosition, left: 0, behavior: instant ? 'auto' : 'smooth' });
                    return;
                } catch(_) {}
            }
        } catch (_) {}

        try { window.scrollTo({ top: targetPosition, left: 0, behavior: instant ? 'auto' : 'smooth' }); } catch(_) {}
    }

    // Portfolio view logic
    window.showPortfolioView = function() {
        // Hide normal stock watchlist section, show a dedicated portfolio section (create if needed)
        if (!document.getElementById('portfolioSection')) {
            const portfolioSection = document.createElement('div');
            portfolioSection.id = 'portfolioSection';
            portfolioSection.className = 'portfolio-section';
            portfolioSection.innerHTML = '<div class="portfolio-scroll-wrapper"><div id="portfolioListContainer">Loading portfolio...</div></div>';
            mainContainer.appendChild(portfolioSection);
        }
        stockWatchlistSection.style.display = 'none';
        // Ensure selection state reflects Portfolio for downstream filters (e.g., ASX buttons)
        // But do not auto-switch away from a forced initial Movers selection unless user explicitly chose portfolio
        if (!__forcedInitialMovers || (watchlistSelect && watchlistSelect.value === 'portfolio')) {
            setCurrentSelectedWatchlistIds(['portfolio']);
        }
        // Reflect in dropdown if present
        if (typeof watchlistSelect !== 'undefined' && watchlistSelect) {
            if (watchlistSelect.value !== 'portfolio') {
                watchlistSelect.value = 'portfolio';
            }
        }
    // Persist user intent
    try { setLastSelectedView('portfolio'); } catch(e) {}
        let portfolioSection = document.getElementById('portfolioSection');
        portfolioSection.style.display = 'block';
    renderPortfolioList();
    try { scrollMainToTop(); } catch(_) {}
    // Keep header text in sync
    try { updateMainTitle(); } catch(e) {}
    // Ensure sort options and alerts are correct for Portfolio view
    try { renderSortSelect(); } catch(e) {}
    try { updateSortPickerButtonText(); } catch(e) {}
    try { updateTargetHitBanner(); } catch(e) {}
        if (typeof renderAsxCodeButtons === 'function') {
            if (asxCodeButtonsContainer) asxCodeButtonsContainer.classList.remove('app-hidden');
            renderAsxCodeButtons();
        }
    };
    window.showWatchlistView = function() {
        // Hide portfolio section if present, show normal stock watchlist section
        let portfolioSection = document.getElementById('portfolioSection');
        if (portfolioSection) portfolioSection.style.display = 'none';
        stockWatchlistSection.style.display = '';
        stockWatchlistSection.classList.remove('app-hidden');
        // Also ensure the table and mobile containers are restored from any previous hide
        if (tableContainer) tableContainer.style.display = '';
        const mobileContainer = getMobileShareCardsContainer();
        if (mobileContainer) mobileContainer.style.display = '';
        // Update sort picker button text when switching to watchlist view
        try { updateSortPickerButtonText(); } catch(e) {}
    };
    // Render portfolio list (uses live prices when available)
    window.renderPortfolioList = function() {
        const portfolioListContainer = document.getElementById('portfolioListContainer');
        if (!portfolioListContainer) return;

        // Filter for shares assigned to the Portfolio
        const portfolioShares = allSharesData.filter(s => shareBelongsTo(s, 'portfolio'));
        if (portfolioShares.length === 0) {
            portfolioListContainer.innerHTML = '<p>No shares in your portfolio yet.</p>';
            return;
        }

        // Helper functions
        function fmtMoney(n) { return formatMoney(n); }
        function fmtPct(n) { return formatPercent(n); }

        // --- Calculate Portfolio Metrics ---
        let totalValue = 0;
        let totalPL = 0;
        let totalCostBasis = 0;
        let todayNet = 0;
        let todayNetPct = 0;
        let overallPLPct = 0;
        let daysGain = 0;
        let daysLoss = 0;
        let profitPLSum = 0;
        let lossPLSum = 0;

        // For each share, calculate metrics
    const cards = portfolioShares.map((share, i) => {
            const shares = (share.portfolioShares !== null && share.portfolioShares !== undefined && !isNaN(Number(share.portfolioShares)))
                ? Math.trunc(Number(share.portfolioShares)) : '';
            const avgPrice = (share.portfolioAvgPrice !== null && share.portfolioAvgPrice !== undefined && !isNaN(Number(share.portfolioAvgPrice)))
                ? Number(share.portfolioAvgPrice) : null;
            const code = (share.shareName || '').toUpperCase();
            const lpObj = livePrices ? livePrices[code] : undefined;
            const marketOpen = typeof isAsxMarketOpen === 'function' ? isAsxMarketOpen() : true;
            let priceNow = null;
            let prevClose = null;
            if (lpObj) {
                if (marketOpen && lpObj.live !== null && !isNaN(lpObj.live)) priceNow = Number(lpObj.live);
                else if (!marketOpen && lpObj.lastLivePrice !== null && !isNaN(lpObj.lastLivePrice)) priceNow = Number(lpObj.lastLivePrice);
                if (lpObj.prevClose !== null && !isNaN(lpObj.prevClose)) prevClose = Number(lpObj.prevClose);
            }
            if (priceNow === null || isNaN(priceNow)) {
                if (share.currentPrice !== null && share.currentPrice !== undefined && !isNaN(Number(share.currentPrice))) {
                    priceNow = Number(share.currentPrice);
                }
            }
            if (prevClose === null && lpObj && lpObj.lastPrevClose !== null && !isNaN(lpObj.lastPrevClose)) {
                prevClose = Number(lpObj.lastPrevClose);
            }
            // Value, P/L, Cost Basis
            const rowValue = (typeof shares === 'number' && typeof priceNow === 'number') ? shares * priceNow : null;
            const rowPL = (typeof shares === 'number' && typeof priceNow === 'number' && typeof avgPrice === 'number') ? (priceNow - avgPrice) * shares : null;
            // If this share has been hidden from totals, skip adding its numbers to aggregates
            const isHidden = hiddenFromTotalsShareIds.has(share.id);
            if (!isHidden) {
                if (typeof rowValue === 'number') totalValue += rowValue;
                if (typeof shares === 'number' && typeof avgPrice === 'number') totalCostBasis += (shares * avgPrice);
                if (typeof rowPL === 'number') {
                    totalPL += rowPL;
                    if (rowPL > 0) profitPLSum += rowPL; else if (rowPL < 0) lossPLSum += rowPL;
                }
            }
            // Today change
            let todayChange = 0;
            let todayChangePct = 0;
            if (typeof shares === 'number' && typeof priceNow === 'number' && typeof prevClose === 'number') {
                todayChange = (priceNow - prevClose) * shares;
                todayChangePct = prevClose > 0 ? ((priceNow - prevClose) / prevClose) * 100 : 0;
                // Only include today's movements in aggregates when the share is NOT hidden
                if (!isHidden) {
                    todayNet += todayChange;
                    if (todayChange > 0) daysGain += todayChange;
                    if (todayChange < 0) daysLoss += todayChange;
                }
            }
            // P/L %

            const rowPLPct = (typeof avgPrice === 'number' && avgPrice > 0 && typeof priceNow === 'number') ? ((priceNow - avgPrice) / avgPrice) * 100 : null;
            const plClass = (typeof rowPL === 'number') ? (rowPL > 0 ? 'positive' : (rowPL < 0 ? 'negative' : 'neutral')) : '';
        if (plClass === 'neutral') {
            try { /* neutral card assignment */ } catch(_) {}
        }
            const todayClass = (todayChange > 0) ? 'positive' : (todayChange < 0 ? 'negative' : 'neutral');

            // Custom target-hit indicator: pulsing dot next to code
            const isTargetHit = (lpObj && typeof lpObj.targetHit !== 'undefined') ? !!lpObj.targetHit : false;

            // per-card debug removed

            // Card HTML (collapsed/expandable)
            // Border color is controlled purely by CSS via .portfolio-card.{positive|negative|neutral}
            // Compute today movement direction for dynamic color
            const dToday = (typeof priceNow === 'number' && typeof prevClose === 'number') ? (priceNow - prevClose) : 0;

            // Build code with optional colored dot
            const codeWithDot = (() => {
                if (!(isTargetHit && !targetHitIconDismissed)) return `${share.shareName || ''}`;
                const color = dToday>0 ? 'var(--brand-green)' : (dToday<0 ? 'var(--brand-red)' : 'var(--accent-color)');
                return `${share.shareName || ''}<span class="target-hit-dot" aria-label="Alert target hit" style="background:${color}"></span>`;
            })();
            return `<div class="portfolio-card ${todayClass}${isHidden ? ' hidden-from-totals' : ''}" data-doc-id="${share.id}">
                <!-- Single line with ASX code, current price, and day change -->
                <div class="portfolio-top-row">
                    <div class="portfolio-code">${codeWithDot}</div>
                    <div class="portfolio-price">${(priceNow !== null && !isNaN(priceNow)) ? formatMoney(priceNow) : ''}</div>
                    <div class="portfolio-day-change ${todayClass}">
                        <div class="pc-day-dollar">${todayChange !== null ? fmtMoney(todayChange) : ''}</div>
                        <div class="pc-day-pct">${todayChange !== null ? fmtPct(todayChangePct) : ''}</div>
                    </div>
                </div>

                <!-- Current Value row (eye moved to under ASX code for better discoverability) -->
                <div class="portfolio-current-value">
                    <span class="portfolio-label">Current Value</span>
                    <span class="portfolio-val">${rowValue !== null ? fmtMoney(rowValue) : ''}</span>
                </div>

                <!-- Capital Gain on separate line -->
                <div class="portfolio-capital-gain">
                    <span class="portfolio-label">Capital Gain</span>
                    <span class="portfolio-val ${plClass}">${rowPL !== null ? fmtMoney(rowPL) : ''}</span>
                </div>

                <!-- Eye icon placed under ASX code for easier reach on mobile -->
                <div class="pc-eye-container">
                    <button class="pc-eye-btn" aria-label="Hide or show from totals"><span class="fa fa-eye"></span></button>
                </div>

                <!-- Centered arrow at bottom of card -->
                <div class="portfolio-centered-arrow">⌄</div>

                <!-- Expanded details with shares, average price, and target -->
                <div class="portfolio-expanded-content">
                    <div class="portfolio-detail-row">
                        <span class="portfolio-detail-label">Amount of Shares</span>
                        <span class="portfolio-detail-val">${shares !== '' ? shares : ''}</span>
                    </div>
                    <div class="portfolio-detail-row">
                        <span class="portfolio-detail-label">Average Price per Share</span>
                        <span class="portfolio-detail-val">${avgPrice !== null ? fmtMoney(avgPrice) : ''}</span>
                    </div>
                    ${(() => {
                        const at = renderAlertTargetInline(share);
                        return at ? `<div class="portfolio-detail-row"><span class="portfolio-detail-label">Target Value</span><span class="portfolio-detail-val">${at}</span></div>` : '';
                    })()}
                </div>
            </div>`;
    });

        // Calculate overall %
        overallPLPct = (totalCostBasis > 0 && typeof totalPL === 'number') ? (totalPL / totalCostBasis) * 100 : 0;
        daysLoss = Math.abs(daysLoss);

        // After mapping, inject a test neutral card at the start for debug/visual confirmation

    // Compute overall today percentage from aggregated totalValue (excluding hidden shares)
    todayNetPct = (totalValue > 0) ? ((todayNet / totalValue) * 100) : 0;

    // Note: Day Change uses net movement (gains minus losses)

    // Compute explicit total capital gain (sum of per-card rowPL used in cards)
    const totalCapitalGain = totalPL; // totalPL is already aggregated for non-hidden shares above

    // --- Summary Bar ---
        const summaryBar = `<div class="portfolio-summary-bar">
            <div class="summary-card ${todayNet > 0 ? 'positive' : todayNet < 0 ? 'negative' : 'neutral'}">
                <div class="summary-label">Total Day Change</div>
                <div class="summary-value ${todayNet >= 0 ? 'positive' : 'negative'}">${fmtMoney(todayNet)} <span class="summary-pct">${fmtPct(todayNetPct)}</span></div>
            </div>
            <div class="summary-card ${daysGain > 0 ? 'positive' : daysGain < 0 ? 'negative' : 'neutral'}">
                <div class="summary-label">Day's Gain</div>
                <div class="summary-value positive">${fmtMoney(daysGain)} <span class="summary-pct positive">${fmtPct(totalValue > 0 ? (daysGain / totalValue) * 100 : 0)}</span></div>
            </div>
            <div class="summary-card ${daysLoss > 0 ? 'negative' : daysLoss < 0 ? 'positive' : 'neutral'}">
                <div class="summary-label">Day's Loss</div>
                <div class="summary-value negative">${fmtMoney(-daysLoss)} <span class="summary-pct negative">${fmtPct(totalValue > 0 ? (daysLoss / totalValue) * 100 : 0)}</span></div>
            </div>
            <div class="summary-card ${totalCapitalGain > 0 ? 'positive' : totalCapitalGain < 0 ? 'negative' : 'neutral'}">
                <div class="summary-label">Total Return</div>
                <div class="summary-value ${totalCapitalGain >= 0 ? 'positive' : 'negative'}">${fmtMoney(totalCapitalGain)} <span class="summary-pct">${fmtPct(overallPLPct)}</span></div>
            </div>
            <div class="summary-card neutral">
                <div class="summary-label">Total Portfolio Value</div>
                <div class="summary-value">${fmtMoney(totalValue)}</div>
            </div>
        </div>`;

        // --- Cards Grid ---
        const cardsGrid = `<div class="portfolio-cards-grid">${cards.join('')}</div>`;
        portfolioListContainer.innerHTML = summaryBar + cardsGrid;

        // Ensure summary modal exists (reuse or create)
        let portfolioSummaryModal = document.getElementById('portfolio-summary-modal');
        if (!portfolioSummaryModal) {
            portfolioSummaryModal = document.createElement('div');
            portfolioSummaryModal.id = 'portfolio-summary-modal';
            portfolioSummaryModal.className = 'modal';
            portfolioSummaryModal.innerHTML = `
                <div class="modal-backdrop"></div>
                <div class="modal-content">
                    <div class="modal-header-with-icon">
                        <div class="modal-title-container">
                            <h3 class="modal-title">Summary</h3>
                        </div>
                        <div class="modal-header-action-group">
                            <button class="close-button" data-dismiss="modal" aria-label="Close">
                                <span aria-hidden="true">&times;</span>
                            </button>
                        </div>
                    </div>
                    <div class="modal-body"><div class="summary-list"></div></div>
                </div>`;
            document.body.appendChild(portfolioSummaryModal);

            // Close handlers
            // Close via backdrop only (back button or overlay click)
            portfolioSummaryModal.querySelector('.modal-backdrop').addEventListener('click', () => {
                hideModal(portfolioSummaryModal);
            });
            // Close via close button (X)
            portfolioSummaryModal.querySelector('.close-button').addEventListener('click', () => {
                hideModal(portfolioSummaryModal);
            });
        }

        // Helper to populate and show summary modal for 'gain' or 'loss'
        const showSummaryModal = (type) => {
            // Update modal title based on the summary type so the modal is descriptive.
            try {
                const titleMap = {
                    daychange: 'Summary Total Day Change',
                    gain: 'Summary Day Change Winners',
                    loss: 'Summary Day Change Losers',
                    capitalGain: 'Summary Capital Gain',
                    currentValueBreakdown: 'Summary Current Value'
                };
                const titleEl = portfolioSummaryModal.querySelector('.modal-title');
                if (titleEl) titleEl.textContent = titleMap[type] || 'Summary';
            } catch (_) {}

            const listNode = portfolioSummaryModal.querySelector('.summary-list');
            listNode.innerHTML = '';
            // type = 'gain' | 'loss' | 'daychange' | 'capitalGain' | 'currentValueBreakdown'

            // We'll recalculate today's change per share using the same logic as renderPortfolioList
            const marketOpen = typeof isAsxMarketOpen === 'function' ? isAsxMarketOpen() : true;
            const items = [];

            portfolioShares.forEach((s) => {
                if (hiddenFromTotalsShareIds.has(s.id)) return; // respect hidden-from-totals

                const sharesCount = (s.portfolioShares !== null && s.portfolioShares !== undefined && !isNaN(Number(s.portfolioShares))) ? Math.trunc(Number(s.portfolioShares)) : 0;
                const code = (s.shareName || '').toUpperCase();
                const lpObj = (typeof livePrices !== 'undefined' && livePrices) ? livePrices[code] : undefined;
                let priceNow = null;
                let prevClose = null;
                if (lpObj) {
                    if (marketOpen && lpObj.live !== null && !isNaN(lpObj.live)) priceNow = Number(lpObj.live);
                    else if (!marketOpen && lpObj.lastLivePrice !== null && !isNaN(lpObj.lastLivePrice)) priceNow = Number(lpObj.lastLivePrice);
                    if (lpObj.prevClose !== null && !isNaN(lpObj.prevClose)) prevClose = Number(lpObj.prevClose);
                    if (prevClose === null && lpObj.lastPrevClose !== null && !isNaN(lpObj.lastPrevClose)) prevClose = Number(lpObj.lastPrevClose);
                }
                if ((priceNow === null || isNaN(priceNow)) && s.currentPrice !== null && s.currentPrice !== undefined && !isNaN(Number(s.currentPrice))) {
                    priceNow = Number(s.currentPrice);
                }
                if ((priceNow === null || isNaN(priceNow)) && s.lastPrice !== null && s.lastPrice !== undefined && !isNaN(Number(s.lastPrice))) {
                    priceNow = Number(s.lastPrice);
                }

                // Compute dollar and percent change for this holding
                let dolChange = 0;
                let pctChange = null;
                let hasNumericChange = false;
                if (typeof priceNow === 'number' && typeof prevClose === 'number' && sharesCount > 0) {
                    dolChange = (priceNow - prevClose) * sharesCount;
                    pctChange = prevClose > 0 ? ((priceNow - prevClose) / prevClose) * 100 : 0;
                    hasNumericChange = true;
                } else if (typeof priceNow === 'number' && typeof prevClose === 'number') {
                    // Even without a shares count, compute per-share percent change (dollars will be zero if sharesCount == 0)
                    dolChange = (priceNow - prevClose) * (sharesCount || 0);
                    pctChange = prevClose > 0 ? ((priceNow - prevClose) / prevClose) * 100 : 0;
                    hasNumericChange = true;
                }

                items.push({ share: s, priceNow, prevClose, sharesCount, dolChange, pctChange, hasNumericChange });
            });

            // Special handling for the two new summary types
            if (type === 'capitalGain') {
                // Show list of each share with code and its current capital gain (per holding)
                // Compute using portfolio average price so it matches the per-card 'Capital Gain' display
                const rows = items.map(it => {
                    const s = it.share;
                    const sharesCount = it.sharesCount || 0;
                    const avgPrice = (s.portfolioAvgPrice !== null && s.portfolioAvgPrice !== undefined && !isNaN(Number(s.portfolioAvgPrice))) ? Number(s.portfolioAvgPrice) : null;
                    const gain = (it.priceNow !== null && avgPrice !== null && sharesCount) ? ((it.priceNow - avgPrice) * sharesCount) : 0;
                    return { code: (s.shareName||'').toUpperCase(), gain };
                }).filter(r => r.code);
                if (rows.length === 0) {
                    const msg = 'No shares available for capital gain summary';
                    try { if (window.ToastManager && typeof window.ToastManager.info === 'function') window.ToastManager.info(msg, { duration: 1400 }); else if (typeof showCustomAlert === 'function') showCustomAlert(msg,1400); else console.log(msg); } catch(_){}
                    return;
                }
                rows.sort((a,b) => b.gain - a.gain);
                rows.forEach(r => {
                    const item = document.createElement('div');
                    const cls = (r.gain > 0) ? 'positive' : (r.gain < 0 ? 'negative' : 'neutral');
                    item.className = `summary-list-item ${cls}`;
                    item.innerHTML = `<div class="summary-item-left"><span class="summary-item-code">${r.code}</span></div><div class="summary-item-right"><span class="summary-item-dollar-change">${fmtMoney(r.gain)}</span></div>`;
                    listNode.appendChild(item);
                });
                try { pushAppStateEntry && pushAppStateEntry('summaryModal', type); } catch(_){}
                showModal(portfolioSummaryModal);
                return;
            }

            if (type === 'currentValueBreakdown') {
                // Show total current value per share held in portfolio (shareCode + current total value)
                // Color the total by comparing current value vs purchase (cost basis)
                const rows = items.map(it => {
                    const s = it.share;
                    const sharesCount = it.sharesCount || 0;
                    const priceNow = (it.priceNow !== null && !isNaN(it.priceNow)) ? it.priceNow : (s.currentPrice || s.lastPrice || 0);
                    const totalValueForShare = (priceNow || 0) * sharesCount;
                    const avgPrice = (s.portfolioAvgPrice !== null && s.portfolioAvgPrice !== undefined && !isNaN(Number(s.portfolioAvgPrice))) ? Number(s.portfolioAvgPrice) : null;
                    const costBasis = (avgPrice !== null && sharesCount > 0) ? (avgPrice * sharesCount) : null;
                    const diff = (costBasis !== null) ? (totalValueForShare - costBasis) : null;
                    const cls = (diff === null) ? 'neutral' : (diff > 0 ? 'positive' : (diff < 0 ? 'negative' : 'neutral'));
                    return { code: (s.shareName||'').toUpperCase(), total: totalValueForShare, cls };
                }).filter(r => r.code);
                if (rows.length === 0) {
                    const msg = 'No shares available for current value summary';
                    try { if (window.ToastManager && typeof window.ToastManager.info === 'function') window.ToastManager.info(msg, { duration: 1400 }); else if (typeof showCustomAlert === 'function') showCustomAlert(msg,1400); else console.log(msg); } catch(_){}
                    return;
                }
                rows.sort((a,b) => b.total - a.total);
                rows.forEach(r => {
                    const item = document.createElement('div');
                    item.className = `summary-list-item ${r.cls}`;
                    item.innerHTML = `<div class="summary-item-left"><span class="summary-item-code">${r.code}</span></div><div class="summary-item-right"><span class="summary-item-dollar-change">${fmtMoney(r.total)}</span></div>`;
                    listNode.appendChild(item);
                });
                try { pushAppStateEntry && pushAppStateEntry('summaryModal', type); } catch(_){}
                showModal(portfolioSummaryModal);
                return;
            }

            // Filter according to type (existing behavior)
            let filtered = items.filter(it => it.hasNumericChange);
            if (type === 'gain') filtered = filtered.filter(it => it.dolChange > 0);
            else if (type === 'loss') filtered = filtered.filter(it => it.dolChange < 0);

            // Sort: for the full Day Change view, sort by signed dollar change (largest gains first,
            // then smaller gains, then losses). For the gain/loss filtered views keep sorting by
            // absolute contribution so the biggest contributors appear first regardless of sign.
            if (type === 'daychange') {
                filtered.sort((a, b) => (b.dolChange || 0) - (a.dolChange || 0));
            } else {
                filtered.sort((a, b) => Math.abs(b.dolChange) - Math.abs(a.dolChange));
            }

            if (filtered.length === 0) {
                // Defensive: do not open an empty modal. Show a brief toast instead.
                try {
                    const msg = type === 'gain' ? 'No gainers found' : type === 'loss' ? 'No losses found' : 'No data available';
                    if (window.ToastManager && typeof window.ToastManager.info === 'function') {
                        window.ToastManager.info(msg, { duration: 1400 });
                    } else if (typeof window.showCustomAlert === 'function') {
                        window.showCustomAlert(msg, 1400);
                    } else {
                        console.log(msg);
                    }
                } catch (e) { console.warn('Summary: failed to show empty toast', e); }
                return;
            }

            filtered.forEach((it) => {
                const s = it.share;
                const price = (it.priceNow !== null && !isNaN(it.priceNow)) ? formatMoney(it.priceNow) : (s.lastPrice !== undefined ? formatMoney(s.lastPrice) : '');
                const dolChange = it.dolChange || 0;
                const pctChange = (it.pctChange !== null && it.pctChange !== undefined) ? fmtPct(it.pctChange) : '';
                const cls = (dolChange > 0) ? 'positive' : (dolChange < 0 ? 'negative' : 'neutral');
                const item = document.createElement('div');
                // Use the exact class names requested for styling and click targets
                item.className = `summary-list-item ${cls}`;
                // Left: code and live price. Right: total dollar change and pct
                item.innerHTML = `
                    <div class="summary-item-left">
                        <span class="summary-item-code">${s.shareName || ''}</span>
                        <span class="summary-item-price">${price}</span>
                    </div>
                    <div class="summary-item-right">
                        <span class="summary-item-dollar-change">${fmtMoney(dolChange)}</span>
                        <span class="summary-item-pct-change">${pctChange}</span>
                    </div>`;
                // Make the entire row clickable
                item.addEventListener('click', () => {
                    try {
                        selectShare(s.id);
                        showShareDetails();
                    } catch (err) { console.warn('Failed to open share details from summary modal', err); }
                    hideModal(portfolioSummaryModal);
                });
                listNode.appendChild(item);
            });

            // push app state so back button will close modal
            try { pushAppStateEntry('summaryModal', type); } catch (e) { /* ignore */ }
            showModal(portfolioSummaryModal);
        };

        // --- Expand/Collapse Logic (Accordion) & Eye Button ---
        const cardNodes = portfolioListContainer.querySelectorAll('.portfolio-card');
    cardNodes.forEach((card, idx) => {
            // Get the share object for this card
            const share = portfolioShares[idx];
            const arrow = card.querySelector('.portfolio-centered-arrow');
            const content = card.querySelector('.portfolio-expanded-content');

            // Accordion expand/collapse logic
            const expandCard = () => {
                cardNodes.forEach((otherCard) => {
                    if (otherCard !== card) {
                        otherCard.classList.remove('expanded');
                        const otherArrow = otherCard.querySelector('.portfolio-centered-arrow');
                        const otherContent = otherCard.querySelector('.portfolio-expanded-content');
                        // rely on CSS for caret appearance; ensure no leftover expanded class
                        if (otherArrow) { /* no-op: appearance handled by CSS triangle */ }
                        if (otherContent) otherContent.style.display = 'none';
                    }
                });
                card.classList.add('expanded');
                // CSS will rotate the caret when .expanded is present
                content.style.display = 'block';
            };

            const collapseCard = () => {
                card.classList.remove('expanded');
                // CSS will show collapsed caret automatically
                content.style.display = 'none';
            };

            const toggleExpanded = () => {
                const isExpanded = card.classList.contains('expanded');
                if (isExpanded) {
                    collapseCard();
                } else {
                    expandCard();
                }
            };

            // Click on arrow to toggle
            arrow.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleExpanded();
            });

            // Pointer/touch handlers to suppress native long-press visual effects on mobile.
            // We add a short-lived class during the interaction which forces the card
            // background to remain stable via CSS. This covers browsers that ignore
            // -webkit-tap-highlight-color on certain elements.
            const addNoTap = (ev) => {
                try {
                    // Force inline styles to override any native pressed overlay.
                    const cs = window.getComputedStyle(card);
                    const resolvedBG = cs && cs.backgroundColor ? cs.backgroundColor : 'transparent';
                    // Mark that we've applied overrides so removeNoTap can clean up
                    card.__noTapApplied = true;
                    // Also toggle an ephemeral class so a single high-specificity stylesheet
                    // can override UA pressed overlays which sometimes ignore inline styles.
                    card.classList.add('no-tap-ephemeral');
                    // Ensure the global ephemeral style exists
                    try {
                        if (!document.getElementById('no-tap-ephemeral-style')) {
                            const s = document.createElement('style');
                            s.id = 'no-tap-ephemeral-style';
                            s.textContent = `html body .portfolio-card.no-tap-ephemeral, html body .portfolio-card.no-tap-ephemeral * { -webkit-tap-highlight-color: transparent !important; -webkit-touch-callout: none !important; -webkit-user-select: none !important; user-select: none !important; background-color: var(--card-bg) !important; }
html body .portfolio-card.no-tap-ephemeral:active, html body .portfolio-card.no-tap-ephemeral *:active, html body .portfolio-card.no-tap-ephemeral::before, html body .portfolio-card.no-tap-ephemeral::after { background-color: var(--card-bg) !important; color: inherit !important; }
`;
                            (document.head || document.documentElement).appendChild(s);
                        }
                    } catch(_) {}
                    // Apply important inline properties
                    try { card.style.setProperty('background-color', resolvedBG, 'important'); } catch(_) {}
                    try { card.style.setProperty('-webkit-tap-highlight-color', 'transparent', 'important'); } catch(_) {}
                    try { card.style.setProperty('-webkit-touch-callout', 'none', 'important'); } catch(_) {}
                    try { card.style.setProperty('user-select', 'none', 'important'); } catch(_) {}
                    // Also apply tap-highlight / touch-callout suppression to children for extra coverage
                    try {
                        const children = card.querySelectorAll('*');
                        for (let i = 0; i < children.length; i++) {
                            const el = children[i];
                            try { el.style.setProperty('-webkit-tap-highlight-color', 'transparent', 'important'); } catch(_) {}
                            try { el.style.setProperty('-webkit-touch-callout', 'none', 'important'); } catch(_) {}
                            try { el.style.setProperty('user-select', 'none', 'important'); } catch(_) {}
                        }
                    } catch(_) {}
                } catch(_) {}
            };

            const removeNoTap = (ev) => {
                try {
                    if (!card.__noTapApplied) return;
                    // Remove the inline overrides we added
                    try { card.style.removeProperty('background-color'); } catch(_) {}
                    try { card.style.removeProperty('-webkit-tap-highlight-color'); } catch(_) {}
                    try { card.style.removeProperty('-webkit-touch-callout'); } catch(_) {}
                    try { card.style.removeProperty('user-select'); } catch(_) {}
                    try {
                        const children = card.querySelectorAll('*');
                        for (let i = 0; i < children.length; i++) {
                            const el = children[i];
                            try { el.style.removeProperty('-webkit-tap-highlight-color'); } catch(_) {}
                            try { el.style.removeProperty('-webkit-touch-callout'); } catch(_) {}
                            try { el.style.removeProperty('user-select'); } catch(_) {}
                        }
                    } catch(_) {}
                    card.__noTapApplied = false;
                    try { card.classList.remove('no-tap-ephemeral'); } catch(_) {}
                } catch(_) {}
            };

            if (window.PointerEvent) {
                card.addEventListener('pointerdown', addNoTap, { passive: true });
                card.addEventListener('pointerup', removeNoTap);
                card.addEventListener('pointercancel', removeNoTap);
                card.addEventListener('pointerleave', removeNoTap);
            } else {
                // Fallback for older browsers: touch events
                card.addEventListener('touchstart', addNoTap, { passive: true });
                card.addEventListener('touchend', removeNoTap);
                card.addEventListener('touchcancel', removeNoTap);
            }

            // Additional suppression on touch devices: prevent context menu and selection start
            try {
                const isCoarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
                if (isCoarsePointer) {
                    card.addEventListener('contextmenu', (e) => { e.preventDefault(); }, { passive: false });
                    card.addEventListener('selectstart', (e) => { e.preventDefault(); }, { passive: false });
                }
            } catch(_) {}

            // NOTE: card-level tap should open share details. The expand/collapse
            // behavior is handled only by the dedicated arrow control below. We
            // therefore remove the previous behavior that toggled the card when
            // tapping anywhere on the card to ensure a single consistent action.
            // Eye icon logic: toggle hide-from-totals (Option A). Click still opens details when CTRL/Meta is held.
            const eyeBtn = card.querySelector('.pc-eye-btn');
            if (eyeBtn) {
                // Set initial visual state on eye button and card
                const isHiddenPersisted = (share.isHiddenInPortfolio === true) || hiddenFromTotalsShareIds.has(share.id);
                if (isHiddenPersisted) {
                    eyeBtn.classList.add('hidden-from-totals');
                    card.classList.add('hidden-from-totals');
                    hiddenFromTotalsShareIds.add(share.id);
                }

                eyeBtn.addEventListener('click', async function(e) {
                    e.stopPropagation();
                    // If user held Ctrl/Meta or Shift while clicking, treat as 'open details' to preserve previous flow
                    if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        selectShare(share.id);
                        showShareDetails();
                        return;
                    }

                    const wasHidden = hiddenFromTotalsShareIds.has(share.id);
                    const nextHidden = !wasHidden;

                    // Optimistic UI update
                    try {
                        if (nextHidden) {
                            hiddenFromTotalsShareIds.add(share.id);
                            eyeBtn.classList.add('hidden-from-totals');
                            card.classList.add('hidden-from-totals');
                        } else {
                            hiddenFromTotalsShareIds.delete(share.id);
                            eyeBtn.classList.remove('hidden-from-totals');
                            card.classList.remove('hidden-from-totals');
                        }
                        persistHiddenFromTotals();
                        // Also optimistically update the local cached share object so renders
                        // that consult `share.isHiddenInPortfolio` reflect the user's action immediately.
                        try {
                            const currentShares = (typeof getAllSharesData === 'function') ? getAllSharesData() : (window.allSharesData || []);
                            if (Array.isArray(currentShares)) {
                                const idx = currentShares.findIndex(s => s && s.id === share.id);
                                if (idx !== -1) {
                                    const next = currentShares.slice();
                                    next[idx] = { ...next[idx], isHiddenInPortfolio: !!nextHidden };
                                    try { setAllSharesData(next); } catch(_) { window.allSharesData = next; }
                                }
                            }
                        } catch (e) { console.warn('Optimistic local share update failed', e); }
                        try { if (typeof sortShares === 'function') sortShares(); } catch(_) {}
                        try { renderPortfolioList(); } catch(_) {}
                    } catch(err) {
                        console.warn('Optimistic UI update failed for eye toggle', err);
                    }

                    // Persist to Firestore via AppService if available; otherwise rely on local storage
                    try {
                        if (window.AppService && typeof window.AppService.updateShareHiddenInPortfolio === 'function') {
                            await window.AppService.updateShareHiddenInPortfolio(share.id, nextHidden);
                        } else if (typeof updateShareHiddenInPortfolio === 'function') {
                            // Some modules import AppService functions directly
                            await updateShareHiddenInPortfolio(share.id, nextHidden);
                        } else {
                            // Firestore helper not available; already persisted locally via persistHiddenFromTotals
                            console.info('Share visibility persisted locally only (no AppService available)');
                        }
                    } catch (err) {
                        console.error('Failed to persist share hidden state to Firestore:', err);
                        // On failure, keep optimistic UI but notify user
                        try { if (window.ToastManager && typeof window.ToastManager.error === 'function') window.ToastManager.error('Failed to save visibility change'); else if (window.showCustomAlert) window.showCustomAlert('Failed to save visibility change', 1800); } catch(_) {}
                    }
                });
            }
            // (Removed deprecated shortcut button — click-to-open is handled by card click-through)

            // Click-through: clicking a portfolio card (except interactive controls)
            // opens the viewing modal. Explicitly exclude the eye button and the
            // expand arrow so those retain their own behavior.
            if (!card.__clickThroughAttached) {
                card.addEventListener('click', function(e) {
                    // Ignore clicks on buttons, links, inputs or elements that handle their own click
                    const interactive = e.target.closest('button, a, input, .pc-eye-btn, .pc-chevron-btn, .portfolio-centered-arrow');
                    if (interactive) return;
                    try {
                        selectShare(share.id);
                        showShareDetails();
                    } catch (err) { console.warn('Card click-through handler failed', err); }
                });
                card.__clickThroughAttached = true;
            }
        });

        // Wire click handlers for summary cards (Day's Gain / Day's Loss / Day Change)
        const summaryCards = portfolioListContainer.querySelectorAll('.portfolio-summary-bar .summary-card');
        if (summaryCards && summaryCards.length) {
            // Day Change (index 0), Day's Gain (1), Day's Loss (2)
            const scArr = Array.from(summaryCards);
            scArr.forEach((sc, idx) => {
                sc.style.cursor = 'pointer';
                sc.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // idx mapping: 0 -> Day Change, 1 -> Day's Gain, 2 -> Day's Loss, 3 -> Total Return, 4 -> Total Portfolio Value
                    if (idx === 1) showSummaryModal('gain');
                    else if (idx === 2) showSummaryModal('loss');
                    else if (idx === 3) showSummaryModal('capitalGain');
                    else if (idx === 4) showSummaryModal('currentValueBreakdown');
                    else showSummaryModal('daychange');
                });
            });
        }

        // NOTE: Per-card 'Current Value' clicks no longer open summary modals.
        // Summary modals are only accessible via the summary cards at the top
        // of the portfolio view. This avoids confusion on mobile where the
        // current value area was unintentionally opening the summary modal.
    };
});

// On full page load (including reload), ensure main content starts at the top
window.addEventListener('load', () => {
    try { scrollMainToTop(true); } catch(_) {}
});
// Log modal close clicks to correlate with [Back] history handling
try {
    document.addEventListener('click', function(e){
        const closeBtn = e.target && (e.target.closest && (e.target.closest('[data-dismiss="modal"], [data-close-modal], .modal .close, .modal .modal-close, .close-modal') || null));
        if (closeBtn) {
            const modalEl = closeBtn.closest && closeBtn.closest('.modal');
            try { if (window.logBackDebug) window.logBackDebug('CLICK close', modalEl && modalEl.id); } catch(_) {}
        }
    }, true);
} catch(_) {}
// Delegate clicks on elements with `data-settings-target` to open the settings page
try {
    document.addEventListener('click', function (ev) {
        try {
            const btn = ev.target && ev.target.closest ? ev.target.closest('[data-settings-target]') : null;
            if (!btn) return;
            ev.preventDefault();
            const targetKey = btn.getAttribute('data-settings-target') || '';
            // Close the notifications modal if present
            try {
                const modal = document.getElementById('targetHitDetailsModal');
                if (modal) {
                    try { if (typeof hideModal === 'function') hideModal(modal); else { modal.style.display = 'none'; modal.classList.remove('show'); } } catch(_) {}
                }
            } catch(_) {}
            // Open the Global Alerts Settings modal (in-place) without navigation
            try {
                const settingsModal = document.getElementById('globalAlertsModal');
                if (settingsModal) {
                    try {
                        // If app exposes showModal helper, prefer it so history/back handling is consistent
                        if (typeof window.showModal === 'function') {
                            window.showModal(settingsModal);
                        } else {
                            settingsModal.style.display = 'flex';
                            settingsModal.classList.add('show');
                        }
                        // Optionally, focus first focusable element inside the settings modal
                        try { const first = settingsModal.querySelector('button, input, [tabindex]:not([tabindex="-1"])'); if (first) first.focus(); } catch(_) {}
                    } catch (e) { console.warn('Failed to show globalAlertsModal', e); }
                } else {
                    // As a fallback, if the modal element doesn't exist, log the key for debugging
                    console.warn('[Settings] globalAlertsModal not found for target:', targetKey);
                }
            } catch (e) {
                console.warn('Opening settings modal failed', e);
            }
        } catch (err) { console.warn('settings-target click handler failed', err); }
    }, false);
} catch (_) {}
//  This script interacts with Firebase Firestore for data storage.

// --- GLOBAL VARIABLES ---
let DEBUG_MODE = false; // Quiet by default; enable via window.toggleDebug(true)
window.toggleDebug = (on) => { DEBUG_MODE = !!on; };

// Custom logging function to control verbosity
function logDebug(message, ...optionalParams) {
    if (DEBUG_MODE) {
        // This line MUST call the native console.log, NOT logDebug itself.
        console.log(message, ...optionalParams); 
    }
}
// Expose core helpers to other modules
try { window.logDebug = logDebug; } catch(_) {}
// NOTE: console monkey-patching removed to avoid surprising global behavior.
// Use `logDebug(...)` or `window.filteredLog(...)` for controlled debug output.
window.filteredLog = function(...args) {
    try {
        if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
            console.log(...args);
        }
    } catch(_) {}
};
try {
    window.showModal = function(m){
        // Prevent re-opening the share form when suppression is active
        try {
            if (m && ((m.id === 'shareFormSection') || (m === shareFormSection)) && window.suppressShareFormReopen) {
                try { logDebug && logDebug('showModal: suppressed opening share form due to suppressShareFormReopen flag'); } catch(_) {}
                return;
            }
        } catch(_) {}

        // Prefer UI module which also pushes history/stack
        if (typeof window.UI !== 'undefined' && window.UI.showModal) {
            // Avoid duplicate push
            try { if (stackHasModal(m)) { return window.UI.showModalNoHistory ? window.UI.showModalNoHistory(m) : UI.showModal(m); } } catch(_) {}
            return window.UI.showModal(m);
        }
        // Fallback: push into back stack and browser history, then show
    try { if (m && !stackHasModal(m) && typeof window.__appBackStackPush === 'function') { window.__appBackStackPush('modal', m); logBackDebug('MODAL open push', m && m.id); } } catch(_) {}
    try { if (m && typeof pushAppState === 'function') { pushAppState({ modalId: m.id || true }, '', '#modal'); } } catch(_) {}
    try { if (m) { m.style.setProperty('display','flex','important'); m.classList.add('show'); } } catch(_){}
    };
} catch(_) {}
try {
    if (!window.scrollMainToTop) {
        window.scrollMainToTop = function(instant, targetPosition = 0){
            logDebug('[ASX Debug] window.scrollMainToTop called with instant:', instant, 'targetPosition:', targetPosition);
            try {
                const el = document.querySelector('main.container');
                logDebug('[ASX Debug] window.scrollMainToTop - main.container found:', !!el);
                if (el) {
                    logDebug('[ASX Debug] window.scrollMainToTop - scrolling main.container to position:', targetPosition);
                    el.scrollTo({ top: targetPosition, left: 0, behavior: instant ? 'auto' : 'smooth' });
                } else {
                    logDebug('[ASX Debug] window.scrollMainToTop - scrolling window to position:', targetPosition);
                    window.scrollTo({ top: targetPosition, left: 0, behavior: instant ? 'auto' : 'smooth' });
                }
            } catch(error) {
                console.error('[ASX Debug] window.scrollMainToTop error:', error);
            }
        };
    }
} catch(_) {}
try { window.updateAddFormLiveSnapshot = updateAddFormLiveSnapshot; } catch(_) {}

// Expose utils-derived helpers (needed by ui.js calculators)
try { window.calculateUnfrankedYield = calculateUnfrankedYield; } catch(_) {}
try { window.calculateFrankedYield = calculateFrankedYield; } catch(_) {}
try { window.estimateDividendIncome = estimateDividendIncome; } catch(_) {}
try { window.formatAdaptivePercent = formatAdaptivePercent; } catch(_) {}
try { window.formatAdaptivePrice = formatAdaptivePrice; } catch(_) {}
// --- END DEBUG LOGGING SETUP ---

let db;
let auth = null;
let currentUserId = null;

// Clears all global notification state (movers, hi/lo, custom trigger hits, etc.)
function clearAllNotificationState() {
    try {
        window.globalMovers = { updatedAt: null, up: [], down: [], upCount: 0, downCount: 0, totalCount: 0, thresholds: null };
        window.globalHiLo52Alerts = { updatedAt: null, highs: [], lows: [] };
        window.globalHiLo52Hits = { updatedAt: null, highHits: [], lowHits: [] };
        window.customTriggerHits = { updatedAt: null, hits: [] };
        if (typeof refreshNotificationsModalIfOpen === 'function') refreshNotificationsModalIfOpen('signout');
        if (typeof updateTargetHitBanner === 'function') updateTargetHitBanner();
    } catch(_) {}
}
let currentAppId;
let firestore;
let authFunctions;
let selectedShareDocId = null;

// Keep window.selectedShareDocId in sync for compatibility with other modules
Object.defineProperty(window, 'selectedShareDocId', {
    get: () => selectedShareDocId,
    set: (value) => { selectedShareDocId = value; }
});
// moved to state.js: allSharesData
// Prevent duplicate sign-in attempts
let authInProgress = false;
// Helper: normalize and check membership for multi-watchlist support with backward compatibility
function shareBelongsTo(share, watchlistId) {
    if (!share) return false;
    if (Array.isArray(share.watchlistIds)) {
        const result = share.watchlistIds.includes(watchlistId);
        if (!result && DEBUG_MODE) {
            console.log(`Share ${share.shareName} does not belong to ${watchlistId}. Share watchlistIds:`, share.watchlistIds);
        }
        return result;
    }
    const result = share.watchlistId === watchlistId;
    if (!result && DEBUG_MODE) {
        console.log(`Share ${share.shareName} does not belong to ${watchlistId}. Share watchlistId:`, share.watchlistId);
    }
    return result;
}
// Helper: ensure we don't render duplicates when transient optimistic updates or race conditions occur
function dedupeSharesById(items) {
    try {
        const map = new Map();
        for (const it of items || []) {
            if (it && it.id) map.set(it.id, it);
        }
        return Array.from(map.values());
    } catch (e) {
        console.warn('Dedupe: Failed to dedupe shares by id:', e);
        return Array.isArray(items) ? items : [];
    }
}
let currentDialogCallback = null;
let autoDismissTimeout = null;
let lastTapTime = 0;
let tapTimeout;
let selectedElementForTap = null;
let longPressTimer;
const LONG_PRESS_THRESHOLD = 500; // Time in ms for long press detection (desktop only; mobile long-press disabled)
let touchStartX = 0;
let touchStartY = 0;
const TOUCH_MOVE_THRESHOLD = 10; // Pixels for touch movement to cancel long press
const KANGA_EMAIL = 'iamkanga@gmail.com';
let currentCalculatorInput = '';
let operator = null;
let previousCalculatorInput = '';
let resultDisplayed = false;
const DEFAULT_WATCHLIST_NAME = 'My Watchlist (Default)';
const DEFAULT_WATCHLIST_ID_SUFFIX = 'default';
// moved to state.js: userWatchlists
// moved to state.js: currentSelectedWatchlistIds
// Guard: track if an initial forced movers selection was applied so later routines do not override
let __forcedInitialMovers = false;
let __moversFallbackScheduled = false;

function ensureMoversPlaceholder() {
    try {
        const tbody = document.querySelector('#shareTable tbody');
        if (!tbody) return false;
        if (!tbody.querySelector('tr.__movers-loading')) {
            const tr = document.createElement('tr');
            tr.className='__movers-loading';
            const td = document.createElement('td');
            td.colSpan = 50;
            td.textContent = 'Loading movers…';
            td.style.opacity='0.65';
            td.style.fontStyle='italic';
            td.style.textAlign='center';
            tr.appendChild(td);
            tbody.appendChild(tr);
    }
    try { window.__lastBackAction = 'modal'; } catch(_) {}
    return true;
    } catch(_) { return false; }
}

function scheduleMoversFallback() {
    if (__moversFallbackScheduled) return; __moversFallbackScheduled = true;
    setTimeout(()=>{
        try {
            const wantMovers = localStorage.getItem('lastSelectedView') === '__movers';
            const haveMovers = getCurrentSelectedWatchlistIds() && getCurrentSelectedWatchlistIds()[0] === '__movers';
            if (wantMovers && !haveMovers) {
                // Fallback to All Shares (user request) while preserving intent logs
                setCurrentSelectedWatchlistIds([ALL_SHARES_ID]);
                if (typeof watchlistSelect !== 'undefined' && watchlistSelect) watchlistSelect.value = ALL_SHARES_ID;
                try { setLastSelectedView(ALL_SHARES_ID); } catch(_) {}
                try { localStorage.setItem('lastWatchlistSelection', JSON.stringify(getCurrentSelectedWatchlistIds())); } catch(_) {}
                if (typeof renderWatchlist === 'function') { try { renderWatchlist(); } catch(_) {} }
                console.warn('[Movers restore][fallback->allShares] Movers failed to attach; defaulted to All Shares.');
                try { scrollMainToTop(); } catch(_) {}
            }
        } catch(e) { console.warn('[Movers fallback] failed', e); }
    }, 2500);
}
// Restore last explicit watchlist (including virtual '__movers') from localStorage before any render logic
try {
    const lsLastWatch = localStorage.getItem('lastWatchlistSelection');
    if (lsLastWatch) {
        const parsed = JSON.parse(lsLastWatch);
        if (Array.isArray(parsed) && parsed.length) {
            try {
                const prev = Array.isArray(getCurrentSelectedWatchlistIds()) ? getCurrentSelectedWatchlistIds().slice(0) : [];
                if (prev.join(',') !== parsed.join(',')) pushAppStateEntry('watchlist', prev);
            } catch(_) {}
            setCurrentSelectedWatchlistIds(parsed);
        }
    }
} catch(_) {}
// Initialize dismissal and sort state from localStorage as early as possible to avoid flashes/defaults
try { targetHitIconDismissed = localStorage.getItem('targetHitIconDismissed') === 'true'; } catch(e) {}
// Restore last selected view (persisted)
try {
    const lastView = localStorage.getItem('lastSelectedView');
    if (lastView === '__movers') {
        // Immediate forced selection BEFORE any data. Will re-render later as data arrives.
    try { const prev = Array.isArray(getCurrentSelectedWatchlistIds()) ? getCurrentSelectedWatchlistIds().slice(0) : []; if (prev[0] !== '__movers') pushAppStateEntry('watchlist', prev); } catch(_) {}
    setCurrentSelectedWatchlistIds(['__movers']);
        __forcedInitialMovers = true;
    try { console.log('[Movers init] Forced initial Movers selection before data load'); } catch(_) {}
        // Set select value if present
        if (typeof watchlistSelect !== 'undefined' && watchlistSelect) { watchlistSelect.value = '__movers'; }
    // Insert placeholder (retry a few frames if table not yet present)
    let tries = 0; (function attempt(){ if (ensureMoversPlaceholder()) return; if (++tries < 10) requestAnimationFrame(attempt); })();
        // Schedule an early render/enforce even if data empty; later data loads will call render again.
        setTimeout(()=>{ try { if (typeof renderWatchlist==='function') renderWatchlist(); enforceMoversVirtualView(true); } catch(_) {} }, 50);
        try { updateMainTitle(); } catch(e) {}
        try { ensureTitleStructure(); } catch(e) {}
        try { updateTargetHitBanner(); } catch(e) {}
    // Schedule fallback to All Shares if movers never attaches
    scheduleMoversFallback();
    } else if (lastView === 'portfolio') {
    try { const prev = Array.isArray(getCurrentSelectedWatchlistIds()) ? getCurrentSelectedWatchlistIds().slice(0) : []; if (prev[0] !== 'portfolio') pushAppStateEntry('watchlist', prev); } catch(_) {}
    setCurrentSelectedWatchlistIds(['portfolio']);
    if (typeof watchlistSelect !== 'undefined' && watchlistSelect) { watchlistSelect.value = 'portfolio'; }
        // Defer actual DOM switch until initial data load completes; hook into data load readiness
        window.addEventListener('load', () => {
            setTimeout(() => { if (typeof showPortfolioView === 'function') showPortfolioView(); }, 300);
        });

    // Keep header and alerts consistent after portfolio render
    try { updateMainTitle(); } catch(e) {}
    try { ensureTitleStructure(); } catch(e) {}
    try { updateTargetHitBanner(); } catch(e) {}
    } else if (lastView && lastView !== 'portfolio') {
    try {
        const prev = Array.isArray(getCurrentSelectedWatchlistIds()) ? getCurrentSelectedWatchlistIds().slice(0) : [];
        if (prev.join(',') !== [lastView].join(',')) pushAppStateEntry('watchlist', prev);
    } catch(_) {}
    setCurrentSelectedWatchlistIds([lastView]);
        if (typeof watchlistSelect !== 'undefined' && watchlistSelect) { watchlistSelect.value = lastView; }
        try { updateMainTitle(); } catch(e) {}
        try { ensureTitleStructure(); } catch(e) {}
        try { updateTargetHitBanner(); } catch(e) {}
    }
} catch(e) { /* ignore */ }
const ALL_SHARES_ID = 'all_shares_option'; // Special ID for the "Show All Shares" option
const CASH_BANK_WATCHLIST_ID = 'cashBank'; // NEW: Special ID for the "Cash & Assets" option
// moved to state.js: currentSortOrder
try { const lsSort = localStorage.getItem('lastSortOrder'); if (lsSort) { setCurrentSortOrder(lsSort); } } catch(e) {}
let contextMenuOpen = false; // To track if the custom context menu is open
let currentContextMenuShareId = null; // Stores the ID of the share that opened the context menu
let originalShareData = null; // Stores the original share data when editing for dirty state check
let originalWatchlistData = null; // Stores original watchlist data for dirty state check in watchlist modals
let currentEditingWatchlistId = null; // NEW: Stores the ID of the watchlist being edited in the modal
// Guard against unintended re-opening of the Share Edit modal shortly after save
// Use a window-scoped sentinel so other modules (dataService, appService) can
// set/check it across module boundaries and avoid reopening the form after save.
try { window.suppressShareFormReopen = window.suppressShareFormReopen || false; } catch(_) { window.suppressShareFormReopen = false; }

// App version (displayed in UI title bar)
// REMINDER: Before each release, update APP_VERSION here, in the splash screen, and any other version displays.
// Release: 2025-09-21 - Global alerts explainers always show thresholds with 'Not set' placeholders
// Bump: 2025-09-28 - patched version for release QA
const APP_VERSION = '3.13';

// Persisted set of share IDs to hide from totals (Option A)
// Persisted set of share IDs to hide from totals (Option A)
let hiddenFromTotalsShareIds = new Set();
try {
    // If a shared authoritative Set was injected on window by the data loader, use it
    if (window.hiddenFromTotalsShareIds && window.hiddenFromTotalsShareIds instanceof Set) {
        hiddenFromTotalsShareIds = window.hiddenFromTotalsShareIds;
    } else {
        const stored = localStorage.getItem('hiddenFromTotalsShareIds');
        if (stored) {
            JSON.parse(stored).forEach(id => hiddenFromTotalsShareIds.add(id));
        }
        // Mirror to window for other modules
        try { window.hiddenFromTotalsShareIds = hiddenFromTotalsShareIds; } catch(_) {}
    }
} catch (e) {
    hiddenFromTotalsShareIds = new Set();
}

function persistHiddenFromTotals() {
    try { localStorage.setItem('hiddenFromTotalsShareIds', JSON.stringify(Array.from(hiddenFromTotalsShareIds))); } catch(_) {}
    try { window.hiddenFromTotalsShareIds = hiddenFromTotalsShareIds; } catch(_) {}
}

// External API: allow other modules (e.g., dataService) to apply an authoritative list of hidden IDs
try {
    window.applyHiddenFromTotalsIds = function(arr) {
        try {
            if (!Array.isArray(arr)) return;
            hiddenFromTotalsShareIds = new Set(arr.filter(Boolean));
            // Persist locally and mirror
            persistHiddenFromTotals();
            // Trigger re-render of portfolio/UI if available
            try { if (typeof renderPortfolioList === 'function') renderPortfolioList(); } catch(_) {}
            try { if (typeof sortShares === 'function') sortShares(); } catch(_) {}
        } catch (e) {
            console.warn('applyHiddenFromTotalsIds failed', e);
        }
    };
} catch (_) {}

// Double-back exit toast state (used when there is nothing left to go back to in-app)
let __lastBackPressAt = 0;
const EXIT_BACK_TOAST_TIMEOUT_MS = 1500; // ms window for second back to confirm exit
// De-dup guards for back handling and toast flooding
let __lastBackHandleAt = 0; // timestamp of last handleGlobalBack entry
let __lastBackToastAt = 0;  // timestamp of last back toast shown

// Wire splash version display and Force Update helper
document.addEventListener('DOMContentLoaded', function () {
    // Splash version display
    try {
        const splashVerEl = document.getElementById('splashAppVersion');
    if (splashVerEl) splashVerEl.textContent = 'v' + APP_VERSION;
    } catch (e) { /* ignore */ }

    // Force Update button handler - posts SKIP_WAITING to waiting worker or triggers update
    try {
        const forceBtn = document.getElementById('forceUpdateBtn');
        async function requestSWUpdate() {
            if (!('serviceWorker' in navigator)) {
                console.log('[SW] Service Worker not supported in this browser.');
                if (window.showCustomAlert) window.showCustomAlert('Service worker not supported in this browser.', 3000);
                return;
            }
            try {
                const reg = await navigator.serviceWorker.getRegistration();
                if (!reg) {
                    console.log('[SW] No service worker registration found.');
                    if (window.showCustomAlert) window.showCustomAlert('No service worker registered.', 3000);
                    return;
                }
                if (reg.waiting) {
                    reg.waiting.postMessage({ type: 'SKIP_WAITING' });
                    console.log('[SW] Sent SKIP_WAITING to waiting worker.');
                    if (window.showCustomAlert) window.showCustomAlert('Updating app... Reloading when ready.', 2500);
                    return;
                }
                // No waiting worker -> check for update which may install a new worker
                await reg.update();
                if (reg.waiting) {
                    reg.waiting.postMessage({ type: 'SKIP_WAITING' });
                    if (window.showCustomAlert) window.showCustomAlert('New update found — activating.', 2500);
                } else {
                    if (window.showCustomAlert) window.showCustomAlert('No update available.', 2000);
                }
            } catch (err) {
                console.error('[SW] Force update failed', err);
                if (window.showCustomAlert) window.showCustomAlert('Update request failed.', 3000);
            }
        }

        if (forceBtn) {
            forceBtn.addEventListener('click', function () { requestSWUpdate(); }, { passive: true });
        }
        // Expose helper for console debugging
        window.requestServiceWorkerUpdate = requestSWUpdate;
    } catch (e) { /* ignore */ }
});

// Service Worker / Version diagnostics helper
async function getAppVersionReport() {
    const report = { APP_VERSION };
    try {
        if ('serviceWorker' in navigator) {
            const reg = await navigator.serviceWorker.getRegistration();
            report.registration = !!reg;
            if (reg) {
                report.scope = reg.scope || null;
                report.activeScript = reg.active && reg.active.scriptURL ? reg.active.scriptURL : null;
                report.waitingScript = reg.waiting && reg.waiting.scriptURL ? reg.waiting.scriptURL : null;
                report.installingScript = reg.installing && reg.installing.scriptURL ? reg.installing.scriptURL : null;
            }
            if (navigator.serviceWorker.controller && navigator.serviceWorker.controller.scriptURL) {
                report.controllerScript = navigator.serviceWorker.controller.scriptURL;
            }
        }
    } catch (e) {
        report.swError = String(e);
    }
    // Inspect cache names for APP_VERSION token
    try {
        if (window.caches && typeof caches.keys === 'function') {
            const keys = await caches.keys();
            report.caches = keys;
            // Find caches that contain the APP_VERSION token (loose match)
            report.versionedCaches = keys.filter(k => k && k.indexOf(String(APP_VERSION)) !== -1);
        }
    } catch (e) {
        report.cacheError = String(e);
    }
    return report;
}

// Update splash element title with SW diagnostic info for quick visibility
(async function annotateSplashWithSW(){
    try {
        const el = document.getElementById('splashAppVersion');
        if (!el) return;
        const rep = await getAppVersionReport();
        const parts = [];
        if (rep.controllerScript) parts.push('controller:' + rep.controllerScript.split('/').pop());
        if (rep.activeScript) parts.push('active:' + rep.activeScript.split('/').pop());
        if (Array.isArray(rep.versionedCaches) && rep.versionedCaches.length) parts.push('cache:' + rep.versionedCaches.join(','));
        if (parts.length) el.title = parts.join(' | ');
    } catch(_) {}
})();

// Expose reporter to console for manual inspection
window.getAppVersionReport = getAppVersionReport;

// Remember prior movers selection across auth resets: stash in sessionStorage before clearing localStorage (if any external code clears it)

// Runtime enforcement: ensure modals follow the single-scroll-container pattern
(function enforceSingleScrollModals(){
    function normalizeModalContent(mc) {
        if (!mc) return { added: false, unwrapped: 0 };
        let added = false;
        if (!mc.classList.contains('single-scroll-modal')) {
            mc.classList.add('single-scroll-modal');
            added = true;
        }
        // Move children out of any nested .modal-body-scrollable wrappers
        const inners = Array.from(mc.querySelectorAll('.modal-body-scrollable'));
        let unwrapped = 0;
        inners.forEach(inner => {
            try {
                while (inner.firstChild) mc.appendChild(inner.firstChild);
                inner.remove();
                unwrapped++;
            } catch(e) { console.warn('[SingleScroll] Failed to unwrap inner container', e); }
        });
        // Ensure touch-scrolling styles present (defensive)
        try {
            mc.style.overflowY = mc.style.overflowY || 'auto';
            mc.style.webkitOverflowScrolling = 'touch';
            if (!mc.style.maxHeight) mc.style.maxHeight = 'calc(100vh - 80px)';
        } catch(e) {}
        return { added, unwrapped };
    }

    function run() {
        try {
            const modalContents = document.querySelectorAll('.modal .modal-content');
            const report = { total: modalContents.length, changed: 0, unwrapped: 0 };
            modalContents.forEach(mc => {
                const r = normalizeModalContent(mc);
                if (r.added) report.changed++;
                report.unwrapped += r.unwrapped || 0;
            });
            if (report.changed || report.unwrapped) {
                console.info('[SingleScroll] Enforced single-scroll on', report.total, 'modals — added class to', report.changed, 'and unwrapped', report.unwrapped, 'inner containers.');
            } else {
                console.debug('[SingleScroll] No changes required — modals already normalized (count:', report.total, ')');
            }
        } catch(e) { console.warn('[SingleScroll] Enforcement failed', e); }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', run, { once: true });
    } else {
        setTimeout(run, 0);
    }

    // Re-run automatically when DOM changes (e.g., modals injected dynamically)
    (function installObserver(){
        let timer = null;
        const debouncedRun = () => {
            if (timer) clearTimeout(timer);
            timer = setTimeout(() => { run(); timer = null; }, 120);
        };

        try {
            const observer = new MutationObserver((mutations) => {
                for (const m of mutations) {
                    if (m.type === 'childList' && m.addedNodes && m.addedNodes.length) {
                        for (const n of m.addedNodes) {
                            if (n.nodeType === 1) {
                                const el = n;
                                if (el.classList && (el.classList.contains('modal') || el.classList.contains('modal-content') || el.querySelector && el.querySelector('.modal-content'))) {
                                    debouncedRun();
                                    return;
                                }
                            }
                        }
                    } else if (m.type === 'attributes' && m.attributeName === 'class') {
                        debouncedRun();
                        return;
                    }
                }
            });
            observer.observe(document.documentElement || document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class'] });
        } catch(e) {
            // noop
        }
    })();

    // Expose for manual debugging from console
    window.__enforceSingleScrollModals = run;
})();
// Non-mutating diagnostic: returns a report of what the enforcement would change
// Usage (from console): await window.__enforceSingleScrollModalsReport()
window.__enforceSingleScrollModalsReport = function() {
    function describeNode(n) {
        if (!n) return null;
        const id = n.id ? `#${n.id}` : '';
        const classes = n.classList && n.classList.length ? `.${Array.from(n.classList).join('.')}` : '';
        const short = `${n.tagName.toLowerCase()}${id}${classes}`;
        return short;
    }

    const modalContents = Array.from(document.querySelectorAll('.modal .modal-content'));
    const report = {
        timestamp: new Date().toISOString(),
        totalModalContents: modalContents.length,
        missingSingleScrollClass: 0,
        totalNestedWrappersFound: 0,
        details: []
    };

    modalContents.forEach((mc, idx) => {
        const hasSingle = mc.classList.contains('single-scroll-modal');
        const inners = Array.from(mc.querySelectorAll('.modal-body-scrollable'));
        if (!hasSingle) report.missingSingleScrollClass++;
        if (inners.length) report.totalNestedWrappersFound += inners.length;

        report.details.push({
            index: idx,
            descriptor: describeNode(mc),
            hasSingleScrollModalClass: hasSingle,
            nestedWrappers: inners.map(n => describeNode(n)),
            sampleInnerHTMLLength: mc.innerHTML ? Math.min(mc.innerHTML.length, 200) : 0
        });
    });

    return report;
};


// Runtime enforcement: ensure modals follow the single-scroll-container pattern
(function enforceSingleScrollModals(){
    function normalizeModalContent(mc) {
        if (!mc) return { added:false, unwrapped:0 };
        let added = false;
        if (!mc.classList.contains('single-scroll-modal')) {
            mc.classList.add('single-scroll-modal');
            added = true;
        }
        // Move children out of any nested .modal-body-scrollable wrappers
        const inners = Array.from(mc.querySelectorAll('.modal-body-scrollable'));
        let unwrapped = 0;
        inners.forEach(inner => {
            try {
                while (inner.firstChild) mc.appendChild(inner.firstChild);
                inner.remove();
                unwrapped++;
            } catch(e) { console.warn('[SingleScroll] Failed to unwrap inner container', e); }
        });
        // Ensure touch-scrolling styles present (defensive)
        try {
            mc.style.webkitOverflowScrolling = mc.style['-webkit-overflow-scrolling'] = mc.style['-webkit-overflow-scrolling'] || 'touch';
            mc.style.overflowY = mc.style.overflowY || 'auto';
            if (!mc.style.maxHeight) mc.style.maxHeight = 'calc(100vh - 80px)';
        } catch(e) {}
        return { added, unwrapped };
    }

    function run() {
        try {
            const modalContents = document.querySelectorAll('.modal .modal-content');
            const report = { total: modalContents.length, changed: 0, unwrapped: 0 };
            modalContents.forEach(mc => {
                const r = normalizeModalContent(mc);
                if (r.added) report.changed++;
                report.unwrapped += r.unwrapped || 0;
            });
            if (report.changed || report.unwrapped) {
                console.info('[SingleScroll] Enforced single-scroll on', report.total, 'modals — added class to', report.changed, 'and unwrapped', report.unwrapped, 'inner containers.');
            } else {
                console.debug('[SingleScroll] No changes required — modals already normalized (count:', report.total, ')');
            }
        } catch(e) { console.warn('[SingleScroll] Enforcement failed', e); }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', run, { once: true });
    } else {
        // Run ASAP if DOM already loaded
// Runtime enforcement: ensure modals follow the single-scroll-container pattern
(function enforceSingleScrollModals(){
    function normalizeModalContent(mc) {
        if (!mc) return { added:false, unwrapped:0 };
        let added = false;
        if (!mc.classList.contains('single-scroll-modal')) {
            mc.classList.add('single-scroll-modal');
            added = true;
        }
        // Move children out of any nested .modal-body-scrollable wrappers
        const inners = Array.from(mc.querySelectorAll('.modal-body-scrollable'));
        let unwrapped = 0;
        inners.forEach(inner => {
            try {
                while (inner.firstChild) mc.appendChild(inner.firstChild);
                inner.remove();
                unwrapped++;
            } catch(e) { console.warn('[SingleScroll] Failed to unwrap inner container', e); }
        });
        // Ensure touch-scrolling styles present (defensive)
        try {
            mc.style.overflowY = mc.style.overflowY || 'auto';
            mc.style.webkitOverflowScrolling = 'touch';
            if (!mc.style.maxHeight) mc.style.maxHeight = 'calc(100vh - 80px)';
        } catch(e) {}
        return { added, unwrapped };
    }

    function run() {
        try {
            const modalContents = document.querySelectorAll('.modal .modal-content');
            const report = { total: modalContents.length, changed: 0, unwrapped: 0 };
            modalContents.forEach(mc => {
                const r = normalizeModalContent(mc);
                if (r.added) report.changed++;
                report.unwrapped += r.unwrapped || 0;
            });
            if (report.changed || report.unwrapped) {
                console.info('[SingleScroll] Enforced single-scroll on', report.total, 'modals — added class to', report.changed, 'and unwrapped', report.unwrapped, 'inner containers.');
            } else {
                console.debug('[SingleScroll] No changes required — modals already normalized (count:', report.total, ')');
            }
        } catch(e) { console.warn('[SingleScroll] Enforcement failed', e); }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', run, { once: true });
    } else {
        setTimeout(run, 0);
    }

    // Re-run automatically when DOM changes (e.g., modals injected dynamically)
    (function installObserver(){
        let timer = null;
        const debouncedRun = () => {
            if (timer) clearTimeout(timer);
            timer = setTimeout(() => { run(); timer = null; }, 120);
        };

        try {
            const observer = new MutationObserver((mutations) => {
                for (const m of mutations) {
                    if (m.type === 'childList' && m.addedNodes && m.addedNodes.length) {
                        // If any modal or modal-content nodes were added, trigger normalization
                        for (const n of m.addedNodes) {
                            if (n.nodeType === 1) {
                                const el = /** @type {Element} */ (n);
                                if (el.classList && (el.classList.contains('modal') || el.classList.contains('modal-content') || el.querySelector && el.querySelector('.modal-content'))) {
                                    debouncedRun();
                                    return;
                                }
                            }
                        }
                    } else if (m.type === 'attributes' && m.attributeName === 'class') {
                        debouncedRun();
                        return;
                    }
                }
            });
            observer.observe(document.documentElement || document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class'] });
        } catch(e) {
            // If observer installation fails, still expose manual trigger
        }
    })();

    // Expose for manual debugging from console
    window.__enforceSingleScrollModals = run;
})();
        setTimeout(run, 0);
    }

    // Re-run automatically when DOM changes (e.g., modals injected dynamically)
    (function installObserver(){
        let timer = null;
        const debouncedRun = () => {
            if (timer) clearTimeout(timer);
            timer = setTimeout(() => { run(); timer = null; }, 120);
        };

        try {
            const observer = new MutationObserver((mutations) => {
                for (const m of mutations) {
                    if (m.type === 'childList' && m.addedNodes && m.addedNodes.length) {
                        // If any modal or modal-content nodes were added, trigger normalization
                        for (const n of m.addedNodes) {
                            if (n.nodeType === 1) {
                                const el = /** @type {Element} */ (n);
                                if (el.classList && (el.classList.contains('modal') || el.classList.contains('modal-content') || el.querySelector && el.querySelector('.modal-content'))) {
                                    debouncedRun();
                                    return;
                                }
                            }
                        }
                    } else if (m.type === 'attributes' && m.attributeName === 'class') {
                        debouncedRun();
                        return;
                    }
                }
            });
            observer.observe(document.documentElement || document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class'] });
        } catch(e) {
            // If observer installation fails, still expose manual trigger
        }
    })();

    // Expose for manual debugging from console
    window.__enforceSingleScrollModals = run;
})();
// === Typography Diagnostics ===
function logTypographyRatios(contextLabel='') {
    try {
        const root = document;
        const priceEl = root.querySelector('#shareDetailModal .live-price-display-section .live-price-large, #shareDetailModal .modal-share-name');
        const changeEl = root.querySelector('#shareDetailModal .live-price-display-section .price-change-large');
        const weekLowEl = root.querySelector('#shareDetailModal .live-price-display-section .fifty-two-week-value.low');
        const weekHighEl = root.querySelector('#shareDetailModal .live-price-display-section .fifty-two-week-value.high');
        const peEl = root.querySelector('#shareDetailModal .live-price-display-section .pe-ratio-value');
        const getSize = el => el ? parseFloat(getComputedStyle(el).fontSize) : NaN;
        const primarySize = getSize(priceEl);
        const report = {
            context: contextLabel || 'detail-modal',
            primaryPx: primarySize,
            changePx: getSize(changeEl),
            weekLowPx: getSize(weekLowEl),
            weekHighPx: getSize(weekHighEl),
            pePx: getSize(peEl)
        };
        ['changePx','weekLowPx','weekHighPx','pePx'].forEach(k => {
            if (!isNaN(report[k]) && !isNaN(primarySize) && primarySize>0) {
                report[k.replace('Px','Ratio')] = +(report[k] / primarySize).toFixed(3);
            }
        });
        console.log('[TypographyDiagnostics]', report);
    } catch(e) { console.warn('Typography diagnostics failed', e); }
}

function logSearchModalTypographyRatios() {
    try {
        const root = document;
        const priceEl = root.querySelector('#stockSearchModal .live-price-display-section .modal-share-name');
        const changeEl = root.querySelector('#stockSearchModal .live-price-display-section .price-change-large');
        const weekLowEl = root.querySelector('#stockSearchModal .live-price-display-section .fifty-two-week-value.low');
        const weekHighEl = root.querySelector('#stockSearchModal .live-price-display-section .fifty-two-week-value.high');
        const peEl = root.querySelector('#stockSearchModal .live-price-display-section .pe-ratio-value');
        const getSize = el => el ? parseFloat(getComputedStyle(el).fontSize) : NaN;
        const primarySize = getSize(priceEl);
        const report = {
            context:'search-modal',
            primaryPx: primarySize,
            changePx: getSize(changeEl),
            weekLowPx: getSize(weekLowEl),
            weekHighPx: getSize(weekHighEl),
            pePx: getSize(peEl)
        };
        ['changePx','weekLowPx','weekHighPx','pePx'].forEach(k => {
            if (!isNaN(report[k]) && !isNaN(primarySize) && primarySize>0) {
                report[k.replace('Px','Ratio')] = +(report[k] / primarySize).toFixed(3);
            }
        });
        console.log('[TypographyDiagnostics]', report);
    } catch(e) { console.warn('Search typography diagnostics failed', e); }
}
try {
    if (localStorage.getItem('lastSelectedView') === '__movers') {
        sessionStorage.setItem('preResetLastSelectedView','__movers');
    }
} catch(_) {}


// Live Price Data
const GOOGLE_APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwwwMEss5DIYblLNbjIbt_TAzWh54AwrfQlVwCrT_P0S9xkAoXhAUEUg7vSEPYUPOZp/exec';
// moved to state.js: livePrices
let livePriceFetchInterval = null; // To hold the interval ID for live price updates
const LIVE_PRICE_FETCH_INTERVAL_MS = 5 * 60 * 1000; // Fetch every 5 minutes
// Global discovery: store external (non-portfolio) price rows each fetch for global alert discovery logic
let globalExternalPriceRows = []; // [{ code, live, prevClose }]

// --- Live Price Timestamp Update ---
function updateLivePriceTimestamp(ts) {
    const el = document.getElementById('livePriceTimestamp');
    if (!el) {
        console.error('ERROR: livePriceTimestamp element not found!');
        return;
    }

    let dateObj;
    if (ts instanceof Date) {
        dateObj = ts;
    } else if (typeof ts === 'number') {
        dateObj = new Date(ts);
    } else {
        dateObj = new Date();
    }

    // Format: e.g. '12:34:56 pm' or '12:34 pm' (24h/12h based on locale)
    const timeStr = dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

    // Set the content and ensure it's visible
    el.textContent = timeStr;
    el.style.display = 'block';
    el.style.visibility = 'visible';
    el.style.opacity = '1';


    // Also ensure the label is visible
    const labelEl = el.parentElement?.querySelector('.live-price-label');
    if (labelEl) {
        labelEl.style.display = 'block';
        labelEl.style.visibility = 'visible';
        labelEl.style.opacity = '1';
                // label element initialized
    } else {
        console.error('Label element not found!');
    }
}

// Expose timestamp updater for other modules (e.g., priceService)
try { window.updateLivePriceTimestamp = updateLivePriceTimestamp; } catch(_) {}
// Ensure a global fetchLivePrices reference exists for legacy callers (no extra side-effects here)
try {
    if (typeof fetchLivePrices === 'function' && !window.fetchLivePrices) {
        window.fetchLivePrices = (...args) => fetchLivePrices.apply(null, args);
    }
} catch(_) {}

// Also update timestamp on DOMContentLoaded (in case prices are preloaded)
document.addEventListener('DOMContentLoaded', function() {
    updateLivePriceTimestamp(Date.now());

    // Stale snapshot handshake removed; snapshot restoration happens synchronously on module load.

});

// Click-to-Refresh on Timestamp Container
document.addEventListener('DOMContentLoaded', function() {
    try {
        const tsContainer = document.getElementById('livePriceTimestampContainer');
        if (tsContainer) {
            tsContainer.style.cursor = 'pointer';
            tsContainer.title = 'Click to refresh live prices';
            tsContainer.addEventListener('click', async (e) => {
                e.preventDefault();
                try { window.logDebug && window.logDebug('UI: Timestamp clicked — refreshing live prices.'); } catch(_) {}
                // Mirror sidebar behavior: show toast notification
                try { if (typeof window.showCustomAlert === 'function') window.showCustomAlert('Refreshing live prices...', 1000); } catch(_) {}
                // Provide quick visual feedback
                const tsEl = document.getElementById('livePriceTimestamp');
                if (tsEl) { tsEl.style.opacity = '0.6'; setTimeout(()=>{ tsEl.style.opacity = '1'; }, 250); }
                try {
                    if (typeof fetchLivePricesAndUpdateUI === 'function') {
                        await fetchLivePricesAndUpdateUI();
                    } else if (typeof fetchLivePrices === 'function') {
                        await fetchLivePrices({ cacheBust: true });
                    } else if (typeof window.fetchLivePrices === 'function') {
                        await window.fetchLivePrices({ cacheBust: true });
                    }
                    // Timestamp will be updated by priceService on success
                } catch (err) {
                    console.warn('Timestamp click refresh failed', err);
                }
            });
        }
    } catch (e) { console.warn('Failed to attach timestamp click-to-refresh', e); }
});

// Theme related variables
const CUSTOM_THEMES = [
    'bold-1', 'bold-2', 'bold-3', 'bold-4', 'bold-5', 'bold-6', 'bold-7', 'bold-8', 'bold-9', 'bold-10',
    'subtle-1', 'subtle-2', 'subtle-3', 'subtle-4', 'subtle-5', 'subtle-6', 'subtle-7', 'subtle-8', 'subtle-9', 'subtle-10',
    'Muted Blue', 'Muted Brown', 'Muted Pink', 'Muted Green', 'Muted Purple', 'Muted Orange', 'Muted Cyan', 'Muted Magenta', 'Muted Gold', 'Muted Grey'
];
let currentCustomThemeIndex = -1; // To track the current theme in the cycle
let currentActiveTheme = 'system-default'; // Tracks the currently applied theme string
let savedSortOrder = null; // GLOBAL: Stores the sort order loaded from user settings
let savedTheme = null; // GLOBAL: Stores the theme loaded from user settings
// GLOBAL: Directional global alert thresholds (null or number)
// (Legacy globalPercentAlert/globalDollarAlert replaced by the four below; migration handled in applyLoadedGlobalAlertSettings)
let globalPercentIncrease = null;
let globalDollarIncrease = null;
let globalPercentDecrease = null;
let globalDollarDecrease = null;
let globalMinimumPrice = null; // New minimum live price filter
// 52-Week Hi/Low global filters and email toggle
let hiLoMinimumPrice = null;
let hiLoMinimumMarketCap = null;
let emailAlertsEnabled = false;
let lastGlobalAlertsSessionId = null; // to avoid duplicating alerts within same fetch cycle if needed
// GLOBAL: References to Global Alerts modal elements (initialized on DOMContentLoaded)
let globalAlertsBtn = null;
let globalAlertsModal = null;
let saveGlobalAlertsBtn = null;
let closeGlobalAlertsBtn = null;
let globalPercentIncreaseInput = null;
let globalDollarIncreaseInput = null;
let globalPercentDecreaseInput = null;
let globalDollarDecreaseInput = null;
let globalMinimumPriceInput = null;
let hiLoMinimumPriceInput = null;
let hiLoMinimumMarketCapInput = null;
let emailAlertsEnabledInput = null;
// Note: sidebar summary element (#globalAlertsSettingsSummary) was removed from index.html.
// The in-modal summary card (gaSum*) is still updated below.

// Early preload: if user recently cleared thresholds and we saved a local snapshot, apply it immediately
// to avoid a flash of stale remote values before Firestore listener returns.
try {
    const lsSnap = localStorage.getItem('globalDirectionalSnapshot');
    if (lsSnap) {
        const parsed = JSON.parse(lsSnap);
        if (parsed && parsed.at && Date.now() - parsed.at < 1000 * 60 * 60 * 12) { // valid for 12h
            globalPercentIncrease = (typeof parsed.pInc === 'number' && parsed.pInc > 0) ? parsed.pInc : null;
            globalDollarIncrease = (typeof parsed.dInc === 'number' && parsed.dInc > 0) ? parsed.dInc : null;
            globalPercentDecrease = (typeof parsed.pDec === 'number' && parsed.pDec > 0) ? parsed.pDec : null;
            globalDollarDecrease = (typeof parsed.dDec === 'number' && parsed.dDec > 0) ? parsed.dDec : null;
            globalMinimumPrice = (typeof parsed.minP === 'number' && parsed.minP > 0) ? parsed.minP : null;
            console.log('[GlobalAlerts][preload] Applied local snapshot of directional thresholds before remote load', parsed);
        }
    }
} catch(e) { /* ignore */ }

let unsubscribeShares = null; // Holds the unsubscribe function for the Firestore shares listener
let unsubscribeCashCategories = null; // NEW: Holds the unsubscribe function for Firestore cash categories listener
let unsubscribeAlerts = null; // NEW: Holds the unsubscribe function for Firestore alerts listener

// moved to state.js: sharesAtTargetPrice
// NEW: Also track triggered but muted alerts so users can unmute from the hub
let sharesAtTargetPriceMuted = [];
// Global alert summary cache
let globalAlertSummary = null; // { increaseCount, decreaseCount, totalCount, threshold }
// NEW: Remember last shown alert count to avoid icon flicker on reload while prices are loading (persisted)
let lastKnownTargetCount = 0;
try {
    const persisted = parseInt(localStorage.getItem('lastKnownTargetCount') || '0', 10);
    if (!isNaN(persisted) && persisted > 0) lastKnownTargetCount = persisted;
} catch(e) {}

// NEW: Global variable to track the current mobile view mode ('default' or 'compact')
// SUPER ROBUST: Single source of truth for view mode with immediate DOM application
let currentMobileViewMode = 'default';
let viewModeInitialized = false;

// CENTRALIZED VIEW MODE MANAGER - Single point of control
function setMobileViewMode(newMode, source = 'unknown') {
    if (newMode !== 'compact' && newMode !== 'default') {
        console.warn('View Mode: Invalid mode requested:', newMode, 'from:', source);
        return false;
    }

    const oldMode = currentMobileViewMode;
    if (oldMode === newMode) {
        return true; // Already correct
    }

    console.log('View mode changed to:', newMode);
    currentMobileViewMode = newMode;
    viewModeInitialized = true;

    // IMMEDIATE DOM APPLICATION - Most critical part
    try {
        const container = getMobileShareCardsContainer();
        if (container) {
            // Always start with clean slate
            container.classList.remove('compact-view');

            if (newMode === 'compact') {
                container.classList.add('compact-view');
            }
        } else {
            console.warn('❌ View Mode: mobileShareCardsContainer not available for immediate application');
        }
    } catch (error) {
        console.error('❌ View Mode: Failed to apply mode to DOM:', error);
    }

    // Force re-render to ensure display properties are correct
    try {
        if (typeof renderWatchlist === 'function') {
            renderWatchlist();
            console.log('View Mode: Triggered renderWatchlist for display updates');
        }
    } catch (error) {
        console.warn('View Mode: Failed to trigger renderWatchlist:', error);
    }

    // Update UI elements
    try {
        if (typeof updateCompactViewButtonState === 'function') {
            updateCompactViewButtonState();
        }
        if (typeof adjustMainContentPadding === 'function') {
            adjustMainContentPadding();
        }
    } catch (error) {
        console.warn('View Mode: Failed to update UI elements:', error);
    }

    // AGGRESSIVE PERSISTENCE - Multiple layers
    persistViewModeAggressively(newMode, source);

    debugViewModeState('after_setMobileViewMode_' + source);
    console.log('✅ VIEW MODE SUCCESS:', newMode, 'from:', source);

    // Verify the view mode was applied correctly after a short delay
    setTimeout(() => {
        const container = getMobileShareCardsContainer();
        if (container) {
            const hasCompactClass = container.classList.contains('compact-view');
            const expectedCompact = currentMobileViewMode === 'compact';
            if (hasCompactClass === expectedCompact) {
            } else {
                console.warn('View mode mismatch detected');
                // Auto-correct if there's a mismatch
                if (expectedCompact && !hasCompactClass) {
                    container.classList.add('compact-view');
                } else if (!expectedCompact && hasCompactClass) {
                    container.classList.remove('compact-view');
                }
            }
        }
    }, 100);

    return true;
}

// AGGRESSIVE PERSISTENCE FUNCTION
function persistViewModeAggressively(mode, source) {
    // Layer 1: Immediate localStorage
    try {
        localStorage.setItem('currentMobileViewMode', mode);
    } catch (error) {
        console.error('View Mode: Failed to save to localStorage:', error);
    }

    // Layer 2: Firestore (if available)
    if (currentUserId && db && firestore) {
        saveViewModePreference(db, firestore, currentUserId, currentAppId, mode).catch(error => {
            console.error('View Mode: Failed to save to Firestore:', error);
        });
    }

    // Layer 3: Session storage as backup
    try {
        sessionStorage.setItem('lastViewMode', mode);
    } catch (error) {
        console.error('View Mode: Failed to save to sessionStorage:', error);
    }

    // Layer 4: Global variable backup
    try {
        window.__lastKnownViewMode = mode;
    } catch (error) {
        console.error('View Mode: Failed to save to global backup:', error);
    }
}

// VIEW MODE RECOVERY FUNCTION - Called when things might be wrong
async function recoverViewMode(source = 'unknown') {

    let recoveredMode = null;

    // Try multiple sources in order of preference (sync first, then async)
    const syncSources = [
        { name: 'global', getter: () => window.__lastKnownViewMode },
        { name: 'session', getter: () => sessionStorage.getItem('lastViewMode') },
        { name: 'localStorage', getter: () => localStorage.getItem('currentMobileViewMode') },
        { name: 'currentVariable', getter: () => currentMobileViewMode }
    ];

    // Try synchronous sources first
    for (const source of syncSources) {
        try {
            const mode = source.getter();
            if (mode === 'compact' || mode === 'default') {
                recoveredMode = mode;
                break;
            }
        } catch (error) {
            console.warn('View Mode: Failed to recover from', source.name + ':', error);
        }
    }

    // If no sync source worked, try Firestore (async)
    if (!recoveredMode && currentUserId && db && firestore) {
        try {
            const firestoreMode = await loadViewModePreference(db, firestore, currentUserId, currentAppId);
            if (firestoreMode) {
                recoveredMode = firestoreMode;
            }
        } catch (error) {
            console.warn('View Mode: Failed to recover from Firestore:', error);
        }
    }

    if (recoveredMode) {
        setMobileViewMode(recoveredMode, 'recovery_from_' + source);
        return true;
    } else {
        console.warn('View Mode: Could not recover mode from any source');
        return false;
    }
}

// FINAL SAFETY CHECK - Run when page is fully loaded
function performFinalViewModeCheck() {
    try {
        // Ensure we have a valid mode
        if (!currentMobileViewMode || !viewModeInitialized) {
            recoverViewMode('final_safety_check').catch(error => {
                console.warn('View Mode: Final safety check recovery failed:', error);
            });
        } else {
            // Double-check that DOM matches our state
            const container = getMobileShareCardsContainer();
            if (container) {
                const hasCompactClass = container.classList.contains('compact-view');
                const shouldHaveCompactClass = currentMobileViewMode === 'compact';

                if (hasCompactClass !== shouldHaveCompactClass) {
                    setMobileViewMode(currentMobileViewMode, 'final_safety_check_correction');
                }
            }
        }
    } catch (error) {
        console.error('View Mode: Final safety check failed:', error);
    }
}

// Run final check when page is fully loaded
if (typeof window !== 'undefined') {
    // Ensure view mode is applied as soon as DOM is ready
    const ensureViewModeApplied = () => {
        if (currentMobileViewMode && viewModeInitialized) {
            const container = getMobileShareCardsContainer();
            if (container) {
                // Double-check the current state
                const hasCompactClass = container.classList.contains('compact-view');
                const shouldHaveCompactClass = currentMobileViewMode === 'compact';

                if (hasCompactClass !== shouldHaveCompactClass) {
                    console.log('DOM Ready: Correcting view mode state');
                    setMobileViewMode(currentMobileViewMode, 'dom_ready_correction');
                }
            }
        }
        performFinalViewModeCheck();
    };

    if (document.readyState === 'complete') {
        // Page already loaded
        setTimeout(ensureViewModeApplied, 100);
    } else {
        // Wait for page to load
        window.addEventListener('load', () => {
            setTimeout(ensureViewModeApplied, 100);
        });
    }

    // Add global debug function for troubleshooting
    window.debugCompactView = function() {
        debugViewModeState('manual_debug');
        console.log('View Mode: Manual debug completed');
        return {
            currentMode: currentMobileViewMode,
            initialized: viewModeInitialized,
            container: !!getMobileShareCardsContainer(),
            localStorage: localStorage.getItem('currentMobileViewMode'),
            sessionStorage: sessionStorage.getItem('lastViewMode'),
            global: window.__lastKnownViewMode
        };
    };

    // Add function to force compact mode for testing
    window.forceCompactView = function() {
        console.log('View Mode: Forcing compact view for testing...');
        setMobileViewMode('compact', 'manual_force');
    };

    // Add function to force default mode for testing
    window.forceDefaultView = function() {
        console.log('View Mode: Forcing default view for testing...');
        setMobileViewMode('default', 'manual_force');
    };

    // Debug function to check compact view state
    window.checkCompactViewState = function() {
        console.log('View Mode State:', {
            mode: currentMobileViewMode,
            initialized: viewModeInitialized,
            container: !!getMobileShareCardsContainer(),
            compactClass: getMobileShareCardsContainer()?.classList.contains('compact-view')
        });
    };

    // Debug function to test view mode persistence
    window.testViewModePersistence = async function() {
        console.log('Testing view mode persistence...');

        try {
            // Test save/load cycle
            await saveViewModePreference(db, firestore, currentUserId, currentAppId, 'compact');
            const loaded = await loadViewModePreference(db, firestore, currentUserId, currentAppId);
            console.log('Persistence test result:', loaded === 'compact' ? 'PASS' : 'FAIL');
        } catch (error) {
            console.error('Persistence test failed:', error.message);
        }
    };

    // Debug function to check movers data
    window.debugMoversData = function() {
        try {
            const moversEntries = applyGlobalSummaryFilter({ silent: true, computeOnly: true }) || [];
            const base = dedupeSharesById(allSharesData);
            const codeSet = new Set(moversEntries.map(e => e.code));
            const matchingShares = base.filter(s => s.shareName && codeSet.has(s.shareName.toUpperCase()));

            console.log('Movers Debug:', {
                moversEntries: moversEntries.length,
                totalShares: base.length,
                matchingShares: matchingShares.length,
                watchlist: currentSelectedWatchlistIds
            });
        } catch(e) {
            console.error('Movers debug failed:', e.message);
        }
    };


    console.log('✅ State check complete');
};

// Debug function to check movers state
window.checkMoversState = function() {
    try {
        const moversResult = applyGlobalSummaryFilter({ silent: true, computeOnly: true });
        console.log('Movers State:', {
            selectedIds: getCurrentSelectedWatchlistIds(),
            livePrices: !!livePrices && Object.keys(livePrices).length,
            totalShares: getAllSharesData().length,
            moversCount: moversResult ? moversResult.length : 0,
            hasSnapshot: !!window.__lastMoversSnapshot
        });
    } catch(e) {
        console.error('Movers state check failed:', e.message);
    }
};

    // Set up a MutationObserver to watch for DOM changes and apply view mode when container appears
    const setupDOMWatcher = () => {
        // Guard against multiple registrations
        if (window.__domWatcherSetup) {
            try { console.debug('DOM Watcher: Already set up, skipping duplicate registration'); } catch(_) {}
            return;
        }
        window.__domWatcherSetup = true;
        if (typeof MutationObserver !== 'undefined') {
            const observer = new MutationObserver((mutations) => {
                for (const mutation of mutations) {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                // Check if the added element is our container or contains it
                                const container = node.id === 'mobileShareCards' ? node :
                                    node.querySelector ? node.querySelector('#mobileShareCards') : null;

                                if (container && currentMobileViewMode && viewModeInitialized) {
                                    console.log('DOM Watcher: mobileShareCardsContainer appeared, applying view mode');
                                    // Small delay to ensure element is fully ready
                                    setTimeout(() => {
                                        if (currentMobileViewMode === 'compact') {
                                            container.classList.add('compact-view');
                                        } else {
                                            container.classList.remove('compact-view');
                                        }
                                        console.log('DOM Watcher: Applied view mode to newly appeared container');
                                    }, 50);
                                }
                            }
                        });
                    }
                }
            });

            // Start observing the document body for changes
            if (document.body) {
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
                console.log('DOM Watcher: Started observing for mobileShareCardsContainer');
            }
        }
    };

    // Start the DOM watcher
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupDOMWatcher);
    } else {
        setupDOMWatcher();
    }
// Early restore of persisted mobile view mode using centralized manager
// Only set the mode variable, don't try to manipulate DOM yet
try {
    const __storedModeEarly = localStorage.getItem('currentMobileViewMode');
    if (__storedModeEarly === 'compact' || __storedModeEarly === 'default') {
        currentMobileViewMode = __storedModeEarly;
        viewModeInitialized = true;
        if (DEBUG_MODE) console.log('View Mode: Early restored mode =', currentMobileViewMode);
    }
} catch(_) {}

// Helper to ensure compact mode class is always applied
function applyCompactViewMode() {
    const container = getMobileShareCardsContainer();
    if (container) {
        if (currentMobileViewMode === 'compact') {
            container.classList.add('compact-view');
        } else {
            container.classList.remove('compact-view');
        }
    }
    // Re-apply ASX buttons visibility since compact view hides them
    if (typeof applyAsxButtonsState === 'function') {
        applyAsxButtonsState();
    }
    // Adjust layout after view mode change
    requestAnimationFrame(adjustMainContentPadding);
    // Update toggle button label/icon if present
    try { if (typeof updateCompactViewButtonState === 'function') updateCompactViewButtonState(); } catch(_) {}
}

// === User Preferences Persistence (Firestore-backed) ===
let userPreferences = {};
async function loadUserPreferences() {
    if (!db || !currentUserId || !firestore) return {};
    try {
        const prefsRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/preferences/ui');
        const snap = await firestore.getDoc(prefsRef);
        if (snap.exists()) {
            userPreferences = snap.data() || {};
            if (DEBUG_MODE) console.log('[Prefs] Loaded user preferences:', userPreferences);
            return userPreferences;
        }
        if (DEBUG_MODE) console.log('[Prefs] No existing preferences doc');
    } catch(e) { if (DEBUG_MODE) console.warn('Prefs: load failed', e); }
    return {};
}
async function persistUserPreference(key, value) {
    if (!db || !currentUserId || !firestore) return;
    try {
        const prefsRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/preferences/ui');
        const obj = {}; obj[key] = value; obj.updatedAt = firestore.serverTimestamp();
        await firestore.setDoc(prefsRef, obj, { merge: true });
        userPreferences[key] = value;
        if (DEBUG_MODE) console.log('[Prefs] Persisted', key, '=', value);
    } catch(e) { if (DEBUG_MODE) console.warn('Prefs: persist failed', e); }
}

// Helper: persist lastSelectedView to both localStorage & Firestore (if authenticated)
function setLastSelectedView(val) {
    if (!val) return;
    // Skip if unchanged (avoid noisy duplicate writes)
    const currentLocal = (()=>{ try { return localStorage.getItem('lastSelectedView'); } catch(_) { return null; } })();
    if (currentLocal === val && userPreferences.lastSelectedView === val) {
        if (DEBUG_MODE) console.log('[Prefs] setLastSelectedView unchanged ->', val);
        return;
    }
    try { localStorage.setItem('lastSelectedView', val); } catch(_) {}
    userPreferences.lastSelectedView = val;
    if (db && currentUserId && firestore) {
        // Debounce Firestore writes within a short window
        if (!window.__lastViewPersist) window.__lastViewPersist = { value: null, ts: 0, timer: null };
        const rec = window.__lastViewPersist;
        rec.value = val; rec.ts = Date.now();
        if (rec.timer) { clearTimeout(rec.timer); rec.timer = null; }
        rec.timer = setTimeout(()=>{
            try { persistUserPreference('lastSelectedView', rec.value); } catch(_) {}
        }, 500); // 500ms debounce collects rapid consecutive changes
    }
    if (DEBUG_MODE) console.log('[Prefs] setLastSelectedView ->', val);
}

// Post-auth preference bootstrap & restore (A & B)
function restoreViewAndModeFromPreferences() {
    try {
        // Last selected view: prefer localStorage, else Firestore preference
        let lastView = localStorage.getItem('lastSelectedView');
        if (!lastView && userPreferences && userPreferences.lastSelectedView) {
            lastView = userPreferences.lastSelectedView;
            if (DEBUG_MODE) console.log('[Restore] Using Firestore lastSelectedView fallback:', lastView);
        }
        if (lastView) {
            if (lastView === 'portfolio') {
                showPortfolioView();
                try { scrollMainToTop(true); } catch(_) {}
            } else if (typeof watchlistSelect !== 'undefined' && watchlistSelect) {
                // If movers virtual view
                if (lastView === '__movers') {
                    try { watchlistSelect.value = ALL_SHARES_ID; } catch(_) {}
                    setCurrentSelectedWatchlistIds(['__movers']);
                    renderWatchlist();
                    enforceMoversVirtualView();
                    updateMainTitle('Movers');
                    // Schedule re-enforcement after first prices (C)
                    scheduleMoversDeferredEnforce();
                } else {
                    // Regular watchlist id
                    const opt = Array.from(watchlistSelect.options).find(o => o.value === lastView);
                    if (opt) {
                        watchlistSelect.value = lastView;
                        setCurrentSelectedWatchlistIds([lastView]);

                        // Restore per-watchlist sort order if available
                        const watchlistSortOrder = getSortOrderForWatchlist(lastView);
                        if (watchlistSortOrder) {
                            setCurrentSortOrder(watchlistSortOrder);
                            if (DEBUG_MODE) console.log('[Restore] Restored sort order for watchlist:', lastView, watchlistSortOrder);
                            try {
                                if (sortSelect) sortSelect.value = watchlistSortOrder;
                                updateSortIcon();
                                setTimeout(() => updateSortPickerButtonText(), 100);
                            } catch (e) {
                                console.warn('[Restore] Failed to update sort select UI:', e);
                            }
                        } else {
                            // No saved sort order, use default
                            const defaultSort = (lastView === CASH_BANK_WATCHLIST_ID) ? 'name-asc' : 'percentageChange-desc';
                            setCurrentSortOrder(defaultSort);
                            if (DEBUG_MODE) console.log('[Restore] Using default sort order for watchlist:', lastView, defaultSort);
                            try {
                                if (sortSelect) sortSelect.value = defaultSort;
                                updateSortIcon();
                                setTimeout(() => updateSortPickerButtonText(), 100);
                            } catch (e) {
                                console.warn('[Restore] Failed to update sort select UI:', e);
                            }
                        }

                        renderWatchlist();
                        try { scrollMainToTop(); } catch(_) {}
                        updateMainTitle();
                    }
                }
            }
        }

        // Compact mode: prefer localStorage; else Firestore; else bootstrap default
        let storedMode = localStorage.getItem('currentMobileViewMode');
        if (!storedMode && userPreferences && userPreferences.compactViewMode) {
            storedMode = userPreferences.compactViewMode;
            if (DEBUG_MODE) console.log('[Restore] Using Firestore compactViewMode fallback:', storedMode);
        }
        if (storedMode !== 'compact' && storedMode !== 'default') {
            storedMode = 'default';
            // Bootstrap Firestore doc with default if missing
            if (Object.keys(userPreferences||{}).length === 0 || userPreferences.compactViewMode === undefined) {
                try { persistUserPreference('compactViewMode', storedMode); } catch(_) {}
            }
        }
        currentMobileViewMode = storedMode;
        try { localStorage.setItem('currentMobileViewMode', currentMobileViewMode); } catch(_) {}
        // applyCompactViewMode(); // Disabled - conflicts with robust restoration
    } catch(e) { console.warn('Restore preferences failed', e); }
}

function scheduleMoversDeferredEnforce() {
    try {
        if (window.__moversDeferredEnforceTimer) return; // debounce
        window.__moversDeferredEnforceTimer = setTimeout(()=>{
            window.__moversDeferredEnforceTimer = null;
            try {
                if (localStorage.getItem('lastSelectedView') === '__movers' || (userPreferences && userPreferences.lastSelectedView === '__movers')) {
                    enforceMoversVirtualView();
                }
            } catch(e){ console.warn('Deferred movers enforce failed', e); }
        }, 1800); // after first live price fetch cycle likely done
    } catch(_) {}
}

// Auto-open suppression sentinel: require user interaction (clicking alert icon) before any passive auto-open
let ALLOW_ALERT_MODAL_AUTO_OPEN = false;

// NEW: Global variable to track if the target hit icon is dismissed for the current session
let targetHitIconDismissed = false;
// Map of alert enable states loaded from Firestore: shareId -> boolean (true = enabled)
let alertsEnabledMap = new Map();
// Removed: manual EOD toggle state; behavior is automatic based on Sydney market hours

// Tracks if share detail modal was opened from alerts
let wasShareDetailOpenedFromTargetAlerts = false;
// Track if the edit form was opened from the share detail modal, so back can return to detail
let wasEditOpenedFromShareDetail = false;

// NEW: Global variable to store cash categories data
let userCashCategories = [];
let selectedCashAssetDocId = null; // NEW: To track which cash asset is selected for editing/details
let originalCashAssetData = null; // NEW: To store original cash asset data for dirty state check
// NEW: Global variable to store visibility state of cash assets (temporary, not persisted)
// This will now be managed directly by the 'isHidden' property on the cash asset object itself.
// isHidden is now stored on each cash category model and toggled via the on-card control


// [moved to top after imports]
// Centralized single-code snapshot handling
let _latestAddFormSnapshotReq = 0; // monotonic counter to avoid race conditions

// Reusable: force a modal layout refresh after dynamic DOM updates inside an open modal
function refreshActiveModalLayout(reason) {
    try {
        const refresh = window.ModalViewportManager && window.ModalViewportManager.refresh;
        if (typeof refresh === 'function') {
            try { if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) console.debug('[ModalRefresh] Trigger', reason || ''); } catch(_) {}
            // Run on next frame and once more shortly after to allow reflow/paint to settle
            try { requestAnimationFrame(refresh); } catch(_) { try { refresh(); } catch(_) {} }
            try { setTimeout(refresh, 60); } catch(_) {}
        }
    } catch(_) { /* no-op */ }
}
try { window.refreshActiveModalLayout = refreshActiveModalLayout; } catch(_) {}

async function updateAddFormLiveSnapshot(code) {
    try {
        if (!code || !GOOGLE_APPS_SCRIPT_URL || !addShareLivePriceDisplay) return;
        const reqId = ++_latestAddFormSnapshotReq;
        const upper = String(code).toUpperCase();
        addShareLivePriceDisplay.dataset.loading = 'true';
        // Lightweight loading indicator (optional)
        addShareLivePriceDisplay.style.display = 'block';
        addShareLivePriceDisplay.innerHTML = '<div class="mini-loading">Loading...</div>';
        const resp = await fetch(`${GOOGLE_APPS_SCRIPT_URL}?stockCode=${encodeURIComponent(upper)}&_ts=${Date.now()}`);
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (reqId !== _latestAddFormSnapshotReq) return; // stale
        if (!Array.isArray(data) || data.length === 0) { addShareLivePriceDisplay.innerHTML = '<p class="ghosted-text">No price data.</p>'; return; }
        let row = data.find(r => {
            const c = r.ASXCode || r.ASX_Code || r['ASX Code'] || r.Code || r.code;
            return c && String(c).toUpperCase().trim() === upper;
        }) || data[0];
        if (row && row !== data[0] && DEBUG_MODE) logDebug('Snapshot: matched exact row for', upper);
        if (row === data[0] && (row.ASXCode || row.Code) && String(row.ASXCode||row.Code).toUpperCase().trim() !== upper && DEBUG_MODE) {
            logDebug('Snapshot: exact match not found, using first row', { requested: upper, first: row.ASXCode||row.Code });
        }
        const live = parseFloat(row.LivePrice ?? row['Live Price'] ?? row.live ?? row.price ?? row.Last ?? row.LastPrice ?? row['Last Price'] ?? row.LastTrade ?? row['Last Trade']);
        const prev = parseFloat(row.PrevClose ?? row['Prev Close'] ?? row.prevClose ?? row.prev ?? row['Previous Close'] ?? row.Close ?? row['Last Close']);
        const pe = parseFloat(row.PE ?? row['PE Ratio'] ?? row.pe);
        const hi = parseFloat(row.High52 ?? row['High52'] ?? row['High 52'] ?? row['52WeekHigh'] ?? row['52 High']);
        const lo = parseFloat(row.Low52 ?? row['Low52'] ?? row['Low 52'] ?? row['52WeekLow'] ?? row['52 Low']);
        const change = (!isNaN(live) && !isNaN(prev)) ? (live - prev) : null;
        const pct = (!isNaN(live) && !isNaN(prev) && prev !== 0) ? ((live - prev) / prev) * 100 : null;
        const priceClass = change === null ? '' : (change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral'));
        // Stash snapshot so saveShareData can use prevClose/live immediately for sorting
        try {
            window.__addFormSnapshot = {
                code: upper,
                live: !isNaN(live) ? live : null,
                prev: !isNaN(prev) ? prev : null,
                lastLivePrice: !isNaN(live) ? live : null,
                lastPrevClose: !isNaN(prev) ? prev : null,
                ts: Date.now()
            };
        } catch(_) {}
        // Guard against user switching code mid-flight
        if (shareNameInput && shareNameInput.value.toUpperCase().trim() !== upper) {
            if (DEBUG_MODE) logDebug('Snapshot: Discarding stale update; input changed.', { requested: upper, current: shareNameInput.value });
            return;
        }
        // Prefill reference price field with latest live price (always override for accuracy)
        if (!isNaN(live) && currentPriceInput) {
            currentPriceInput.value = Number(live).toFixed(2);
        }
        addShareLivePriceDisplay.innerHTML = `
            <div class="fifty-two-week-row">
                <span class="fifty-two-week-value low">Low: ${!isNaN(lo) ? formatMoney(lo) : 'N/A'}</span>
                <span class="fifty-two-week-value high">High: ${!isNaN(hi) ? formatMoney(hi) : 'N/A'}</span>
            </div>
            <div class="live-price-main-row">
                <span class="live-price-large ${priceClass}">${!isNaN(live) ? formatMoney(live) : 'N/A'}</span>
                <span class="price-change-large ${priceClass}">${(change !== null && pct !== null) ? formatDailyChange(change, pct) : 'N/A'}</span>
            </div>
            <div class="pe-ratio-row">
                <span class="pe-ratio-value">P/E: ${!isNaN(pe) ? formatAdaptivePrice(pe) : 'N/A'}</span>
            </div>`;
        addShareLivePriceDisplay.style.display = 'block';
        addShareLivePriceDisplay.removeAttribute('data-loading');
        // Ensure modal scroll area recalculates after content injection (esp. with keyboard visible)
        refreshActiveModalLayout('after live snapshot render');
    } catch (e) {
        if (DEBUG_MODE) console.warn('Snapshot: failed for', code, e);
        if (addShareLivePriceDisplay) {
            addShareLivePriceDisplay.innerHTML = '<p class="ghosted-text">Price unavailable.</p>';
            addShareLivePriceDisplay.style.display = 'block';
            addShareLivePriceDisplay.removeAttribute('data-loading');
            // Also refresh layout after error-state content update
            refreshActiveModalLayout('after live snapshot error render');
        }
    }
}
const shareNameInput = document.getElementById('shareName');
// Removed manual Reference Price input; currentPrice now auto-captured
const targetPriceInput = document.getElementById('targetPrice');
const dividendAmountInput = document.getElementById('dividendAmount');
const frankingCreditsInput = document.getElementById('frankingCredits');
const shareRatingSelect = document.getElementById('shareRating');
const commentsFormContainer = document.getElementById('dynamicCommentsArea');
const modalStarRating = document.getElementById('modalStarRating');

// Ensure currentPriceInput exists in this scope before building helper arrays
const currentPriceInput = document.getElementById('currentPrice');

// UX improvement: clear default 0 / 0.0 values on focus for numeric inputs (behave like true placeholders)
const zeroClearInputs = [currentPriceInput, targetPriceInput, dividendAmountInput, frankingCreditsInput].filter(Boolean);
zeroClearInputs.forEach(inp => {
    inp.addEventListener('focus', () => {
        const v = inp.value.trim();
        if (v === '0' || v === '0.0' || v === '0.00') {
            inp.dataset.wasZeroPlaceholder = '1';
            inp.value = '';
        } else {
            delete inp.dataset.wasZeroPlaceholder;
        }
    });
    inp.addEventListener('blur', () => {
        // If user leaves it empty, restore a clean 0 (or leave blank?) — choose to leave blank to avoid confusion
        if (inp.dataset.wasZeroPlaceholder && inp.value.trim() === '') {
            inp.value = ''; // blank so validation can decide; remove flag
            delete inp.dataset.wasZeroPlaceholder;
        }
    });
});
// --- ASX Code Toggle Button Functionality (moved to uiService) ---

console.log('[ELEMENT CHECK] toggleAsxButtonsBtn exists:', !!document.getElementById('toggleAsxButtonsBtn'));
console.log('[ELEMENT CHECK] asxCodeButtonsContainer exists:', !!document.getElementById('asxCodeButtonsContainer'));

if (toggleAsxButtonsBtn && asxCodeButtonsContainer) {
    console.log('[TOGGLE SETUP] ASX toggle button found, binding click handler');

    // Debug: Check toggle button visibility and position
    console.log('[TOGGLE DEBUG] Toggle button style:', {
        display: toggleAsxButtonsBtn.style.display,
        visibility: toggleAsxButtonsBtn.style.visibility,
        pointerEvents: toggleAsxButtonsBtn.style.pointerEvents,
        position: toggleAsxButtonsBtn.style.position,
        zIndex: toggleAsxButtonsBtn.style.zIndex,
        opacity: toggleAsxButtonsBtn.style.opacity
    });

    const computedStyle = window.getComputedStyle(toggleAsxButtonsBtn);
    console.log('[TOGGLE DEBUG] Toggle button computed style:', {
        display: computedStyle.display,
        visibility: computedStyle.visibility,
        pointerEvents: computedStyle.pointerEvents,
        position: computedStyle.position,
        zIndex: computedStyle.zIndex,
        opacity: computedStyle.opacity,
        width: computedStyle.width,
        height: computedStyle.height
    });

    // Update ASX button toggle visibility based on current state
    applyAsxButtonsState();

    // Helper: aggressively reset any inner scrollable containers inside main
    function resetInnerScrollPositions() {
        try {
            const mainRoot = document.querySelector('main.container') || document.querySelector('main') || document.body;
            if (!mainRoot) return;
            const candidates = Array.from(mainRoot.querySelectorAll('*'));
            candidates.forEach(el => {
                try {
                    const style = window.getComputedStyle(el);
                    const overflowY = style && (style.overflowY || style.overflow);
                    if ((overflowY === 'auto' || overflowY === 'scroll' || overflowY === 'overlay') && el.scrollHeight > el.clientHeight && el.scrollTop > 0) {
                        try { el.scrollTop = 0; } catch(_){}
                    }
                } catch(_){}
            });
            // also reset some known containers
            try { const tc = document.querySelector('.table-container'); if (tc && tc.scrollTop) tc.scrollTop = 0; } catch(_){}
            try { const mc = document.getElementById('mobileShareCards'); if (mc && mc.scrollTop) mc.scrollTop = 0; } catch(_){}
            try { const pf = document.querySelector('.portfolio-scroll-wrapper'); if (pf && pf.scrollTop) pf.scrollTop = 0; } catch(_){}
        } catch(_){}
    }

    console.log('[TOGGLE SETUP] About to bind click event listener');

    // Add multiple event listeners to debug click issues
    ['mousedown', 'mouseup', 'click'].forEach(eventType => {
        toggleAsxButtonsBtn.addEventListener(eventType, (e) => {
            console.log(`[EVENT DEBUG] ${eventType} event fired on toggle button`, {
                target: e.target.id,
                currentTarget: e.currentTarget.id,
                type: e.type,
                button: e.button,
                clientX: e.clientX,
                clientY: e.clientY
            });
        });
    });

    // Add global click listener to monitor clicks near toggle button
    document.addEventListener('click', (e) => {
        // Respect a short-lived sentinel used by smaller modules (e.g., Sort Picker)
        // to avoid immediate global-close races when a modal is programmatically opened.
        try {
            if (window.__sortPickerOpeningUntil && Date.now() < window.__sortPickerOpeningUntil) {
                // Suppress this global click handling while Sort Picker is opening
                return;
            }
        } catch (_) {}

        const toggleBtn = document.getElementById('toggleAsxButtonsBtn');
        if (toggleBtn) {
            const rect = toggleBtn.getBoundingClientRect();
            const clickX = e.clientX;
            const clickY = e.clientY;

            // Check if click is within 50px of the toggle button
            const isNearToggle = clickX >= rect.left - 50 && clickX <= rect.right + 50 &&
                                clickY >= rect.top - 50 && clickY <= rect.bottom + 50;

            if (isNearToggle) {
                console.log('[GLOBAL CLICK] Click near toggle button area', {
                    clickX, clickY,
                    buttonRect: { left: rect.left, right: rect.right, top: rect.top, bottom: rect.bottom },
                    targetElement: e.target.tagName + (e.target.id ? '#' + e.target.id : ''),
                    targetClasses: e.target.className
                });
            }
        }
    });

    toggleAsxButtonsBtn.addEventListener('click', (e) => {
        console.log('[CLICK DEBUG] ASX toggle button clicked!');
        // Prevent the click from falling through to the sort select and other handlers
        try { e.stopPropagation(); e.preventDefault(); } catch(_) {}

        const currentExpanded = getAsxButtonsExpanded();
        console.log('[CLICK DEBUG] Current expanded state:', currentExpanded);
        const newExpanded = !currentExpanded;
        console.log('[CLICK DEBUG] New expanded state:', newExpanded);

        setAsxButtonsExpanded(newExpanded);
        applyAsxButtonsState();

        const actualExpanded = getAsxButtonsExpanded();
        console.log('[CLICK DEBUG] Actual expanded state after toggle:', actualExpanded);

        // Set the scroll flag
        console.log('[CLICK DEBUG] Setting __asxToggleWantsScroll = true');
        window.__asxToggleWantsScroll = true;

        // Also trigger scroll immediately with a short delay to ensure it happens
        setTimeout(() => {
            try {
                const targetPosition = calculateWatchlistScrollPosition();
                if (window.scrollMainToTop) {
                    window.scrollMainToTop(false, targetPosition);
                } else {
                    scrollMainToTop(false, targetPosition);
                }
                adjustMainContentPadding();
            } catch(error) {
                console.error('Error in immediate scroll:', error);
            }
        }, 100);

        // Fallback: If transitionend doesn't fire within 500ms, trigger scroll manually
        setTimeout(() => {
            if (window.__asxToggleWantsScroll) {
                try {
                    // Reset known inner scrollers first
                    const tc = document.querySelector('.table-container'); if (tc && tc.scrollTop) tc.scrollTop = 0;
                    const mc = document.getElementById('mobileShareCards'); if (mc && mc.scrollTop) mc.scrollTop = 0;
                    const pf = document.querySelector('.portfolio-scroll-wrapper'); if (pf && pf.scrollTop) pf.scrollTop = 0;

                    // Calculate target position and perform scroll
                    const targetPosition = calculateWatchlistScrollPosition();
                    if (window.scrollMainToTop) {
                        window.scrollMainToTop(false, targetPosition);
                    } else {
                        scrollMainToTop(false, targetPosition);
                    }

                    // Adjust padding
                    adjustMainContentPadding();

                    // Clear flag
                    delete window.__asxToggleWantsScroll;
                } catch(error) {
                    console.error('Fallback scroll error:', error);
                }
            }
        }, 500);

        // Close native select popup if it is open
        try { if (typeof sortSelect !== 'undefined' && sortSelect && document.activeElement === sortSelect) sortSelect.blur(); } catch(_) {}
        // Schedule padding adjustment after the CSS transition window
        setTimeout(adjustMainContentPadding, 450);
        setTimeout(adjustMainContentPadding, 700);
        // Update aria states and visual pressed attribute for button
        try {
            toggleAsxButtonsBtn.setAttribute('aria-pressed', String(!!getAsxButtonsExpanded()));
            toggleAsxButtonsBtn.setAttribute('aria-expanded', String(!!getAsxButtonsExpanded()));
            const tri = toggleAsxButtonsBtn.querySelector('.asx-toggle-triangle'); if (tri) tri.classList.toggle('expanded', !!getAsxButtonsExpanded());
        } catch(_) {}
        // Set flag for transitionend handler to perform proper scrolling after transition completes
        try { window.__asxToggleWantsScroll = true; } catch(_) {}
        // Note: Primary scrolling is now handled by transitionend event for precise timing
        // Simple fallback scroll after transition completes (kept as safety net)
        setTimeout(() => {
            try {
                const targetPosition = calculateWatchlistScrollPosition();
                if (window.scrollMainToTop) window.scrollMainToTop(false, targetPosition); else scrollMainToTop(false, targetPosition);
            } catch(_){}
        }, 600);
    });

    // Allow clicking the surrounding sort-select-wrapper to toggle ASX Codes as well
    try {
        const sortWrapper = document.querySelector('.sort-select-wrapper');
        if (sortWrapper) {
            // Clicking the wrapper should open the sort select by default.
            // Only allow the ASX toggle button itself to toggle ASX codes.
            sortWrapper.addEventListener('click', (e) => {
                const target = e.target;
                // If the native select (or something inside it) was clicked, let the browser handle it
                if (target && (target.tagName === 'SELECT' || (target.closest && target.closest('select')))) {
                    return; // let select handle interaction
                }
                // If the click originated on the ASX toggle button (or inside it), do nothing here;
                // the toggle button has its own click handler that will run.
                if (toggleAsxButtonsBtn && (target === toggleAsxButtonsBtn || (target.closest && target.closest('#toggleAsxButtonsBtn')))) {
                    return;
                }
                // Otherwise, open/focus the native sort select so the options are shown
                try {
                    if (typeof sortSelect !== 'undefined' && sortSelect) {
                        // Focus first
                        sortSelect.focus();
                        // Attempt to open the native select dropdown by simulating a click
                        try { sortSelect.click(); } catch(_) {}
                    }
                } catch(_) {}
            }, { passive: false });
        }
    } catch(_) {}

    // Also adjust precisely on transition end of the container and perform deferred scroll if needed
    // Listen for transitionend on the container and its children
    const handleTransitionEnd = (ev) => {

        // Check if this is the container itself transitioning with relevant properties
        const isContainerTransition = ev.target === asxCodeButtonsContainer &&
            (ev.propertyName === 'max-height' || ev.propertyName === 'padding' || ev.propertyName === 'opacity' || ev.propertyName === 'border-width');

        // Also check if this is a child element with relevant transitions
        const isChildRelevantTransition = asxCodeButtonsContainer.contains(ev.target) &&
            (ev.propertyName === 'max-height' || ev.propertyName === 'padding' || ev.propertyName === 'opacity' || ev.propertyName === 'border-width');

        // Also listen for any transition on the container itself, even if it's not the properties we expect
        const isAnyContainerTransition = ev.target === asxCodeButtonsContainer;

        if (isContainerTransition || isChildRelevantTransition || isAnyContainerTransition) {
            console.log('[TRANSITION DEBUG] Transition end fired, property:', ev.propertyName, 'target:', ev.target.id || ev.target.className);
            console.log('[TRANSITION DEBUG] __asxToggleWantsScroll:', window.__asxToggleWantsScroll);

            // If a scroll was requested while toggling ASX buttons, perform it BEFORE adjusting padding
            try {
                if (window.__asxToggleWantsScroll) {
                    console.log('[TRANSITION DEBUG] Performing scroll before padding adjustment');
                    // Reset known inner scrollers first to ensure top-of-list is reachable
                    try { const tc = document.querySelector('.table-container'); if (tc && tc.scrollTop) tc.scrollTop = 0; } catch(_){}
                    try { const mc = document.getElementById('mobileShareCards'); if (mc && mc.scrollTop) mc.scrollTop = 0; } catch(_){}
                    try { const pf = document.querySelector('.portfolio-scroll-wrapper'); if (pf && pf.scrollTop) pf.scrollTop = 0; } catch(_){}

                    // Calculate target position and perform scroll
                    const targetPosition = calculateWatchlistScrollPosition();
                    try { if (window.scrollMainToTop) window.scrollMainToTop(false, targetPosition); else scrollMainToTop(false, targetPosition); } catch(error) { console.error('Error calling scrollMainToTop:', error); }
                } else {
                    console.log('[TRANSITION DEBUG] No scroll requested, skipping');
                }
            } catch(_){}

            // Now adjust the padding to account for the new header height
            adjustMainContentPadding();

            // Perform a final scroll adjustment in case the padding change affected positioning
            console.log('[TRANSITION DEBUG] Checking for final scroll adjustment, __asxToggleWantsScroll:', window.__asxToggleWantsScroll);
            try {
                if (window.__asxToggleWantsScroll) {
                    console.log('[TRANSITION DEBUG] Scheduling final scroll adjustment');
                    setTimeout(() => {
                        console.log('[TRANSITION DEBUG] Performing final scroll adjustment');
                        const targetPosition = calculateWatchlistScrollPosition();
                        try { if (window.scrollMainToTop) window.scrollMainToTop(false, targetPosition); else scrollMainToTop(false, targetPosition); } catch(_){}
                        try { delete window.__asxToggleWantsScroll; } catch(_){}
                        console.log('[TRANSITION DEBUG] Final scroll completed, clearing flag');
                    }, 50);
                } else {
                    console.log('[TRANSITION DEBUG] No final scroll needed');
                }
            } catch(_){}
        }
    };

    // Attach the transitionend handler to the container
    asxCodeButtonsContainer.addEventListener('transitionend', handleTransitionEnd);

    // Also listen for transitionend on child elements (use capture to catch events before they bubble)
    asxCodeButtonsContainer.addEventListener('transitionend', handleTransitionEnd, true);
}

// Bind header two-line text toggle to existing logic
try {
    if (asxCodeButtonsToggle) {
        const syncAria = () => {
            try {
                const expanded = getAsxButtonsExpanded();
                asxCodeButtonsToggle.setAttribute('aria-pressed', String(!!expanded));
                asxCodeButtonsToggle.setAttribute('aria-expanded', String(!!expanded));
            } catch(_) {}
        };
        asxCodeButtonsToggle.addEventListener('click', (e) => {
            e.preventDefault();
            const currentExpanded = getAsxButtonsExpanded();
            setAsxButtonsExpanded(!currentExpanded);
            applyAsxButtonsState();
            syncAria();
        });
        asxCodeButtonsToggle.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const currentExpanded = getAsxButtonsExpanded();
                setAsxButtonsExpanded(!currentExpanded);
                applyAsxButtonsState();
                syncAria();
            }
        });
        // Initial aria sync
        syncAria();
    }
} catch(_) {}
const addCommentSectionBtn = document.getElementById('addCommentSectionBtn');
const shareTableBody = document.querySelector('#shareTable tbody');
// Dynamic container getter to handle DOM timing issues
function getMobileShareCardsContainer() {
    // Always get fresh reference to handle DOM timing
    const container = document.getElementById('mobileShareCards');
    if (!container) {
        console.warn('View Mode: mobileShareCardsContainer not found in DOM');
        console.warn('View Mode: Current DOM elements with "mobile" in ID:', Array.from(document.querySelectorAll('[id*="mobile"]')).map(el => el.id));
        console.warn('View Mode: Document readyState:', document.readyState);
        console.warn('View Mode: All elements with ID containing "card":', Array.from(document.querySelectorAll('[id*="card"]')).map(el => el.id));
    }
    return container;
}

function getToggleCompactViewBtn() {
    // Always get fresh reference to handle DOM timing
    return document.getElementById('toggleCompactViewBtn');
}

// Debug function to log current view mode state
function debugViewModeState(source = 'unknown') {
    const container = getMobileShareCardsContainer();
    console.log('=== VIEW MODE DEBUG ===');
    console.log('Source:', source);
    console.log('currentMobileViewMode:', currentMobileViewMode);
    console.log('viewModeInitialized:', viewModeInitialized);
    console.log('Container exists:', !!container);
    if (container) {
        console.log('Container has compact-view class:', container.classList.contains('compact-view'));
        console.log('Container display style:', container.style.display);
    }
    console.log('localStorage value:', localStorage.getItem('currentMobileViewMode'));
    console.log('sessionStorage value:', sessionStorage.getItem('lastViewMode'));
    console.log('Global backup:', window.__lastKnownViewMode);
    console.log('=======================');
}

// Keep for backwards compatibility, but make it dynamic
let mobileShareCardsContainer = null;
const tableContainer = document.querySelector('.table-container');
const loadingIndicator = document.getElementById('loadingIndicator');
const shareDetailModal = document.getElementById('shareDetailModal');
const modalShareName = document.getElementById('modalShareName');
const modalCompanyName = document.getElementById('modalCompanyName');
const modalEnteredPrice = document.getElementById('modalEnteredPrice');
const modalTargetPrice = document.getElementById('modalTargetPrice');
const modalDividendAmount = document.getElementById('modalDividendAmount');
const modalFrankingCredits = document.getElementById('modalFrankingCredits');
const modalEntryDate = document.getElementById('modalEntryDate');
const modalCommentsContainer = document.getElementById('modalCommentsContainer');
const modalUnfrankedYieldSpan = document.getElementById('modalUnfrankedYield');
const modalFrankedYieldSpan = document.getElementById('modalFrankedYield');
const modalPortfolioShares = document.getElementById('modalPortfolioShares');
const modalPortfolioAvgPrice = document.getElementById('modalPortfolioAvgPrice');
// New computed fields in Share Details modal
const modalPurchaseCost = document.getElementById('modalPurchaseCost');
const modalCurrentValue = document.getElementById('modalCurrentValue');
const modalCapitalGain = document.getElementById('modalCapitalGain');
const editShareFromDetailBtn = document.getElementById('editShareFromDetailBtn');
const deleteShareFromDetailBtn = document.getElementById('deleteShareFromDetailBtn');
const modalNewsLink = document.getElementById('modalNewsLink');
const modalMarketIndexLink = document.getElementById('modalMarketIndexLink');
const modalFoolLink = document.getElementById('modalFoolLink');
const modalListcorpLink = document.getElementById('modalListcorpLink'); // NEW: Reference for Listcorp link
const modalCommSecLink = document.getElementById('modalCommSecLink');
const commSecLoginMessage = document.getElementById('commSecLoginMessage');
// NEW: Auto (read-only) fields in Other Details section of Share Form
const autoEntryDateDisplay = document.getElementById('autoEntryDateDisplay');
const autoReferencePriceDisplay = document.getElementById('autoReferencePriceDisplay');
const dividendCalculatorModal = document.getElementById('dividendCalculatorModal');
const calcCloseButton = document.querySelector('.calc-close-button');
const calcCurrentPriceInput = document.getElementById('calcCurrentPrice');
const calcDividendAmountInput = document.getElementById('calcDividendAmount');
const calcFrankingCreditsInput = document.getElementById('calcFrankingCredits');
const calcUnfrankedYieldSpan = document.getElementById('calcUnfrankedYield');
const calcFrankedYieldSpan = document.getElementById('calcFrankedYield');
const investmentValueSelect = document.getElementById('investmentValueSelect');
const calcEstimatedDividend = document.getElementById('calcEstimatedDividend');
const sortSelect = document.getElementById('sortSelect');
// Legacy customDialogModal removed; toast system fully replaces it.
const calculatorModal = document.getElementById('calculatorModal');
const calculatorInput = document.getElementById('calculatorInput');
const calculatorResult = document.getElementById('calculatorResult');
const calculatorButtons = document.querySelector('.calculator-buttons');
// Dynamic watchlist title + picker modal + sort display (new UI layer)
const dynamicWatchlistTitle = document.getElementById('dynamicWatchlistTitle');
const dynamicWatchlistTitleText = document.getElementById('dynamicWatchlistTitleText');
// --- Watchlist Title Click: Open Watchlist Picker Modal ---
// Use the unified binding further below (openPicker). We deliberately avoid binding here
// to prevent double-open and duplicate back-stack pushes.
// (Moved below watchlistPickerModal initialization to avoid ReferenceError)
const watchlistPickerModal = document.getElementById('watchlistPickerModal');
const watchlistPickerList = document.getElementById('watchlistPickerList');
const closeWatchlistPickerBtn = document.getElementById('closeWatchlistPickerBtn');

// --- Close Watchlist Picker Modal ---
// Binding handled later alongside openPicker to avoid duplicate listeners.
// ...rest of the code...

// Removed legacy currentSortDisplay element (text summary of sort) now that dropdown itself is visible
const themeToggleBtn = document.getElementById('themeToggleBtn');
const colorThemeSelect = document.getElementById('colorThemeSelect');
const revertToDefaultThemeBtn = document.getElementById('revertToDefaultThemeBtn');
const scrollToTopBtn = document.getElementById('scrollToTopBtn');
const hamburgerBtn = document.getElementById('hamburgerBtn');
const appSidebar = document.getElementById('appSidebar');
const closeMenuBtn = document.getElementById('closeMenuBtn');
const addWatchlistBtn = document.getElementById('addWatchlistBtn');
const editWatchlistBtn = document.getElementById('editWatchlistBtn');
const addWatchlistModal = document.getElementById('addWatchlistModal');
const newWatchlistNameInput = document.getElementById('newWatchlistName');
const saveWatchlistBtn = document.getElementById('saveWatchlistBtn');
const manageWatchlistModal = document.getElementById('manageWatchlistModal');
const editWatchlistNameInput = document.getElementById('editWatchlistName');
const saveWatchlistNameBtn = document.getElementById('saveWatchlistNameBtn');
const deleteWatchlistInModalBtn = document.getElementById('deleteWatchlistInModalBtn');
const shareContextMenu = document.getElementById('shareContextMenu');
const contextEditShareBtn = document.getElementById('contextEditShareBtn');
const contextDeleteShareBtn = document.getElementById('contextDeleteShareBtn');
const logoutBtn = document.getElementById('logoutBtn');
const deleteAllUserDataBtn = document.getElementById('deleteAllUserDataBtn');
const exportWatchlistBtn = document.getElementById('exportWatchlistBtn');
const refreshLivePricesBtn = document.getElementById('refreshLivePricesBtn');
let shareWatchlistSelect = document.getElementById('shareWatchlistSelect');
// Defensive: if the DOM does not include the native select (we use enhanced toggles), create a hidden off-DOM select
if (!shareWatchlistSelect) {
    try {
        shareWatchlistSelect = document.createElement('select');
        shareWatchlistSelect.id = 'shareWatchlistSelect';
        shareWatchlistSelect.style.display = 'none';
        shareWatchlistSelect.multiple = true;
        // Keep it off-DOM but accessible to scripts. Some older code queries by id; this preserves behavior.
        // Do not append to document.body to avoid duplicate UI; remain off-DOM.
    } catch(_) {
        shareWatchlistSelect = null;
    }
}
const shareWatchlistCheckboxes = document.getElementById('shareWatchlistCheckboxes');
const shareWatchlistDropdownBtn = document.getElementById('shareWatchlistDropdownBtn');
const modalLivePriceDisplaySection = document.getElementById('modalLivePriceDisplaySection'); 
const targetHitIconBtn = document.getElementById('targetHitIconBtn'); // NEW: Reference to the icon button
const targetHitIconCount = document.getElementById('targetHitIconCount'); // NEW: Reference to the count span
// NEW: Target Hit Details Modal Elements
const targetHitDetailsModal = document.getElementById('targetHitDetailsModal');
const targetHitModalTitle = document.getElementById('targetHitModalTitle');
// Removed: minimizeTargetHitModalBtn, dismissAllTargetHitsBtn (now explicit buttons at bottom)
const targetHitSharesList = document.getElementById('targetHitSharesList');
const toggleCompactViewBtn = document.getElementById('toggleCompactViewBtn');
    // Initial load suppression flags (prevent auto reopening of Target Hit modal after hard reload)
    window.__initialLoadPhase = true; // cleared after first interaction or timeout
    let __userInitiatedTargetModal = false;
    window.addEventListener('pointerdown', ()=>{ window.__initialLoadPhase=false; }, { once:true, passive:true });
    window.addEventListener('keydown', ()=>{ window.__initialLoadPhase=false; }, { once:true });
    setTimeout(()=>{ window.__initialLoadPhase=false; }, 6000);

// Ensure initial ARIA state for hamburger
if (hamburgerBtn && !hamburgerBtn.hasAttribute('aria-expanded')) {
    hamburgerBtn.setAttribute('aria-expanded','false');
}

// NEW: References for the reconfigured buttons in the Target Hit Details Modal
const targetHitModalCloseTopBtn = document.getElementById('targetHitModalCloseTopBtn'); // New 'X' button at the top
const alertModalMinimizeBtn = document.getElementById('alertModalMinimizeBtn'); // New "Minimize" button at the bottom
const alertModalDismissAllBtn = document.getElementById('alertModalDismissAllBtn'); // New "Dismiss All" button at the bottom

// NEW: Target Direction Checkbox UI Elements
const targetAboveCheckbox = document.getElementById('targetAboveCheckbox');
const targetBelowCheckbox = document.getElementById('targetBelowCheckbox');
// New Phase 1 segmented toggle buttons (UI-only)
const targetIntentBuyBtn = document.getElementById('targetIntentBuyBtn');
const targetIntentSellBtn = document.getElementById('targetIntentSellBtn');
const targetDirAboveBtn = document.getElementById('targetDirAboveBtn');
const targetDirBelowBtn = document.getElementById('targetDirBelowBtn');
let userManuallyOverrodeDirection = false; // reset per form open
// Debounced auto-save for target alert related inputs (intent, direction, target price)
let _alertAutoSaveTimer = null;
function scheduleAlertAutoSave(trigger){
    // Only auto-save when editing an existing share (avoid accidental creation of duplicates during new entry form fills)
    if (!selectedShareDocId) { try { logDebug('AlertAutoSave: skipped (no selectedShareDocId) trigger='+trigger); } catch(_){} return; }
    try { logDebug('AlertAutoSave: schedule ('+trigger+') for shareId='+selectedShareDocId); } catch(_){ }
    if (_alertAutoSaveTimer) clearTimeout(_alertAutoSaveTimer);
    _alertAutoSaveTimer = setTimeout(()=>{
        try { if (typeof saveShareData === 'function') saveShareData(true); } catch(e){ console.warn('AlertAutoSave failed', e); }
    }, 400);
}
const splashScreen = document.getElementById('splashScreen');
const searchStockBtn = document.getElementById('searchStockBtn'); // NEW: Search Stock button
const stockSearchModal = document.getElementById('stockSearchModal'); // NEW: Stock Search Modal
// Ensure stock search modal is hidden on script load
if (stockSearchModal) {
    stockSearchModal.classList.remove('show');
}
const stockSearchTitle = document.getElementById('stockSearchTitle'); // NEW: Title for search modal
const asxSearchInput = document.getElementById('asxSearchInput'); // NEW: Search input field
const asxSuggestions = document.getElementById('asxSuggestions'); // NEW: Autocomplete suggestions container
const shareNameSuggestions = document.getElementById('shareNameSuggestions'); // NEW: Autocomplete for share form code input
const searchResultDisplay = document.getElementById('searchResultDisplay'); // NEW: Display area for search results
const searchModalActionButtons = document.querySelector('#stockSearchModal .modal-action-buttons-footer'); // NEW: Action buttons container
const searchModalCloseButton = document.querySelector('.search-close-button'); // NEW: Close button for search modal

// moved to state.js: allAsxCodes
let currentSelectedSuggestionIndex = -1; // For keyboard navigation in autocomplete
let shareNameAutocompleteBound = false; // Prevent duplicate binding

function initializeShareNameAutocomplete(force=false){
    if (shareNameAutocompleteBound && !force) return;
    if (!shareNameInput || !shareNameSuggestions) return;
    // If already has an input listener tagged, skip unless force
    if (shareNameInput.dataset.autocompleteBound && !force) return;
    shareNameInput.dataset.autocompleteBound = '1';
    shareNameAutocompleteBound = true;
    // Listeners are already defined further below (conditional block). This function can serve as a future hook.
}
let currentSearchShareData = null; // Stores data of the currently displayed stock in search modal
const splashKangarooIcon = document.getElementById('splashKangarooIcon');
const splashSignInBtn = document.getElementById('splashSignInBtn');
const alertPanel = document.getElementById('alertPanel'); // NEW: Reference to the alert panel (not in current HTML, but kept for consistency)
const alertList = document.getElementById('alertList'); // NEW: Reference to the alert list container (not in current HTML, but kept for consistency)
const closeAlertPanelBtn = document.getElementById('closeAlertPanelBtn'); // NEW: Reference to close alert panel button (not in current HTML, but kept for consistency)
const clearAllAlertsBtn = document.getElementById('clearAllAlertsBtn'); // NEW: Reference to clear all alerts button (not in current HTML, but kept for consistency)

// NEW: Cash & Assets UI Elements (1)
const stockWatchlistSection = document.getElementById('stockWatchlistSection');

// Global helpers for consistent numeric formatting across the UI


// Lean wrappers for adaptive decimals outside of currency symbol contexts
// Revised adaptive price: default 2 decimals; optionally preserve up to 3 if user entered (pass userRaw); force2 to clamp.

// Fallback for missing formatUserDecimalStrict (called in edit form population)
if (typeof window.formatUserDecimalStrict !== 'function') {
    window.formatUserDecimalStrict = function(v){
        if (v === null || v === undefined || v === '') return '';
        const num = Number(v);
        if (isNaN(num)) return '';
        // Keep up to 4 decimals if needed, trim trailing zeros
        let str = num.toFixed(4); // start with 4
        str = str.replace(/\.0+$/,'');
        str = str.replace(/(\.\d*[1-9])0+$/,'$1');
        return str;
    };
}

// ----- Lightweight Back Stack Handling (with debug) -----
function logBackDebug(...args){ try { console.log('[Back]', ...args); } catch(_) {} }
const appBackStack = [];
function pushAppStateEntry(type, ref) {
    appBackStack.push({type, ref});
    // Allow up to ten shallow steps to avoid accidental truncation in mixed flows
    if (appBackStack.length > 10) appBackStack.shift();
    logBackDebug('PUSH', type, ref && (ref.id || ref), 'stack=', appBackStack.map(e=>e.type+':'+(e.ref && (e.ref.id||e.ref))).join(' | '));
}
function popAppStateEntry() { const e = appBackStack.pop(); logBackDebug('POP', e && e.type, e && e.ref && (e.ref.id||e.ref), 'stack=', appBackStack.map(x=>x.type+':'+(x.ref && (x.ref.id||x.ref))).join(' | ')); return e; }
// Expose a safe, minimal hook so other modules (e.g., ui.js) can push into the back stack
try { window.__appBackStackPush = function(type, ref){ pushAppStateEntry(type, ref); }; } catch(_) {}

// Back/Modal Diagnostics & Auto-History for modals (helps in mobile/devtools where some open paths skip push)
try {
    if (!window.__backHistoryObserverInstalled) {
        window.__backDiag = window.__backDiag || false; // enable manually to get verbose logs
        window.__backAutoPushModal = true; // auto-push history entries for visible modals when they open
        window.__backHistoryObserverInstalled = true;

        const modalVisibilityCheck = (m) => {
            try {
                if (!m) return false;
                if (m.classList && m.classList.contains('show')) return true;
                const ds = (m.style && m.style.display) || '';
                if (ds === 'flex' || ds === 'block') return true;
                if (window.getComputedStyle) {
                    const cs = window.getComputedStyle(m);
                    if (cs && (cs.display === 'flex' || cs.display === 'block')) return true;
                }
            } catch(_){}
            return false;
        };

        const modalObserver = new MutationObserver((mutationsList) => {
            for (const mut of mutationsList) {
                try {
                    if (mut.type === 'attributes' && mut.target && mut.target.classList && mut.target.classList.contains('modal')) {
                        const modal = mut.target;
                        const nowVisible = modalVisibilityCheck(modal);
                        if (nowVisible) {
                            // Only push if not already tracked
                            try {
                                if (window.__backAutoPushModal && !stackHasModal(modal)) {
                                    pushAppStateEntry('modal', modal);
                                    try { if (typeof pushAppState === 'function') pushAppState({ modalId: modal.id || true }, '', '#modal'); } catch(_) {}
                                    if (window.__backDiag) logBackDebug('Auto-pushed modal history for', modal.id || modal);
                                }
                            } catch(e) { if (window.__backDiag) console.warn('Auto-push modal failed', e); }
                        }
                    }
                    if (mut.type === 'childList' && mut.addedNodes && mut.addedNodes.length) {
                        for (const n of Array.from(mut.addedNodes)) {
                            try {
                                if (n && n.classList && n.classList.contains && n.classList.contains('modal')) {
                                    const modal = n;
                                    if (modalVisibilityCheck(modal) && window.__backAutoPushModal && !stackHasModal(modal)) {
                                        pushAppStateEntry('modal', modal);
                                        try { if (typeof pushAppState === 'function') pushAppState({ modalId: modal.id || true }, '', '#modal'); } catch(_) {}
                                        if (window.__backDiag) logBackDebug('Auto-pushed modal history for (added node)', modal.id || modal);
                                    }
                                }
                            } catch(_){}
                        }
                    }
                } catch(_){}
            }
        });

        try {
            modalObserver.observe(document.body, { attributes: true, subtree: true, childList: true });
        } catch(e) { if (window.__backDiag) console.warn('Modal history observer failed to start', e); }

        // Optional runtime popstate logging when enabled
        const originalPop = window.onpopstate;
        window.__backPopLogger = function(ev){
            try {
                if (window.__backDiag) {
                    console.log('[BackDiag] popstate', ev && ev.state, 'appBackStack=', appBackStack.map(x=>x.type+':' + (x.ref && (x.ref.id||x.ref))).join('|'));
                }
            } catch(_){ }
            try { if (typeof originalPop === 'function') originalPop(ev); } catch(_){ }
        };
        try { window.addEventListener('popstate', window.__backPopLogger); } catch(_){ }

        // Provide a safe global wrapper for history.pushState used across the app.
        // This was missing in some builds, causing no history entries to be created
        // for modals/watchlists/view toggles and breaking Back semantics.
        try {
            if (typeof window.pushAppState !== 'function') {
                window.pushAppState = function(state, title, url){
                    try { history.pushState(state || {}, title || '', url || location.href); } catch(_) {}
                };
            }
        } catch(_) {}

        // Default: never exit the PWA/app via Back. You can override at runtime by setting
        // window.__preventAppExit = false to restore double-back-to-exit.
        try { if (typeof window.__preventAppExit === 'undefined') window.__preventAppExit = true; } catch(_) {}

        // Ensure a toast container exists early so exit-toast can render even if UI module
        // hasn't initialized yet. This prevents race conditions where ToastManager is present
        // but has no container to render into (causing missing exit warning).
        try {
            if (!document.getElementById('toastContainer')) {
                const tc = document.createElement('div');
                tc.id = 'toastContainer';
                tc.className = 'toast-container';
                // Keep minimal inline styles so it's visible on mobile in most themes (bottom-center)
                tc.style.position = 'fixed';
                tc.style.zIndex = '9999';
                tc.style.left = '12px';
                tc.style.right = '12px';
                tc.style.bottom = '24px';
                tc.style.display = 'flex';
                tc.style.flexDirection = 'column';
                tc.style.gap = '10px';
                tc.style.alignItems = 'center';
                tc.style.pointerEvents = 'none';
                document.body.appendChild(tc);
            }
        } catch(_) {}

        // Helper to push a preserve entry with a unique URL hash ("jitter") so hostile webviews
        // create a distinct history entry every time. This keeps Back routed to our handler.
        function pushPreserveHistoryEntry(){
            try {
                const base = location.href.split('#')[0];
                const jitter = 'bk-' + Date.now().toString(36) + '-' + Math.floor(Math.random()*1e4).toString(36);
                history.pushState({ asx_back_preserve: true, jitter }, '', base + '#'+ jitter);
            } catch(_) {}
        }

        // Unified popstate handler with "bounce": immediately go forward to keep the user
        // on our top guard state, then perform in-app back handling. This prevents exiting
        // even on platforms that don't allow adding history during back.
        try {
            // Global popstate handler: call handleGlobalBack (sync or async). Only push a
            // preservation history entry when the action was the exit-toast. This avoids
            // trapping normal back flows (modals, sidebar, watchlist) while restoring the
            // double-back-to-exit behaviour reliably.
            let __backBounceInProgress = false;
            let __backSkipCount = 0;
            window.__globalPopHandler = function(ev) {
                try {
                    if (window.logBackDebug) window.logBackDebug('[Back] popstate fired', ev && ev.state, 'skipCount=', __backSkipCount);
                    // If this popstate was induced by our forward bounce, ignore it.
                    if (__backSkipCount > 0) { __backSkipCount--; return; }
                    // Bounce forward to the latest guard entry if possible.
                    if (!__backBounceInProgress) {
                        __backBounceInProgress = true;
                        try {
                            __backSkipCount += 1;
                            setTimeout(() => { try { history.go(1); } finally { __backBounceInProgress = false; } }, 0);
                            // Extra safety: clear skip if forward didn't fire
                            setTimeout(() => { __backSkipCount = 0; }, 400);
                        } catch(_) { __backBounceInProgress = false; __backSkipCount = 0; }
                    }
                    if (typeof handleGlobalBack === 'function') {
                        const result = handleGlobalBack();
                        Promise.resolve(result).then((consumed) => {
                            try {
                                // We always bounce and handle in-app; no further history mutation needed here.
                            } catch (e) { if (window.logBackDebug) console.warn('Global pop handler inner failure', e); }
                        }).catch((err) => {
                            console.warn('Global pop handler: handleGlobalBack promise failed', err);
                        });
                    }
                } catch (e) {
                    console.warn('Global popstate handler failed', e);
                }
            };
            window.addEventListener('popstate', window.__globalPopHandler);
        } catch(_) {}

        // Install a two-entry guard ring so back always lands on one of our guards rather than
        // exiting the app. We use stable hashes so the URL bar (if present) isn't spammed.
        try {
            // Do this on DOMContentLoaded to avoid interfering with other early scripts.
            const pushInitial = () => {
                try {
                    const base = location.href.split('#')[0];
                    history.replaceState({ asx_guard: true, idx: 0 }, '', base + '#g0');
                    history.pushState({ asx_guard: true, idx: 1 }, '', base + '#g1');
                    history.pushState({ asx_guard: true, idx: 2 }, '', base + '#g2');
                } catch(_) {}
            };
            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', pushInitial, { once: true }); else pushInitial();
            // No keepalive required with bounce; the ring keeps us safe.
        } catch(_) {}
    }
} catch(_) {}

// Helpers: modal stack maintenance
function stackHasModal(modalEl){
    try {
        const id = modalEl && (modalEl.id || (modalEl.ref && modalEl.ref.id));
        return appBackStack.some(e => e.type === 'modal' && (e.ref === modalEl || (e.ref && (e.ref.id||e.ref) === id)));
    } catch(_) { return false; }
}
function removeModalFromStack(modalEl){
    try {
        const id = modalEl && (modalEl.id || (modalEl.ref && modalEl.ref.id));
        let removed = false;
        for (let i = appBackStack.length - 1; i >= 0; i--) {
            const e = appBackStack[i];
            const eid = e && e.ref && (e.ref.id || e.ref);
            if (e && e.type === 'modal' && (e.ref === modalEl || eid === id)) { appBackStack.splice(i,1); removed = true; }
        }
        if (removed) logBackDebug('STACK purge modal', id, 'stack=', appBackStack.map(e=>e.type+':'+(e.ref && (e.ref.id||e.ref))).join(' | '));
    } catch(_) {}
}

// Removed legacy early hamburger push listener (consolidated later) – now handled in unified sidebar setup
// Remove legacy wrapper that caused duplicate pushes; use central window.UI.showModal path only

function handleGlobalBack(){
    // Prevent duplicate handling from closely-spaced popstate events (bounce, quirky webviews)
    try {
        const now = Date.now();
    if (now - (__lastBackHandleAt || 0) < 240) {
            if (window.logBackDebug) window.logBackDebug('Back: deduped handleGlobalBack');
            return true; // consume silently to avoid double-pop and duplicate toasts
        }
        __lastBackHandleAt = now;
    } catch(_) {}
    // 1) Close the currently active/top modal if any tracked in our stack
    const last = appBackStack[appBackStack.length - 1];
    if (last && last.type === 'modal') {
        const entry = popAppStateEntry();
        const currentModal = entry && entry.ref && entry.ref.nodeType === 1 ? entry.ref : (entry && entry.ref ? document.getElementById(entry.ref.id || entry.ref) : null);
        if (currentModal && currentModal.id === 'shareFormSection') {
            try { autoSaveShareFormOnClose(); } catch(e) { console.warn('Auto-save on back (share form) failed', e); }
        }
        if (currentModal) {
            hideModal(currentModal);
        } else {
            // No resolvable modal ref: only close if at least one modal is visibly open
            try {
                const anyOpen = Array.from(document.querySelectorAll('.modal')).some(m => {
                    const ds = (m.style && m.style.display) || '';
                    const hasShow = m.classList && m.classList.contains('show');
                    const cs = window.getComputedStyle ? window.getComputedStyle(m).display : '';
                    return ds === 'flex' || hasShow || cs === 'flex';
                });
                if (anyOpen) closeModals();
            } catch(_) {}
        }
        // If previous is also a modal, restore it without pushing history
        const prev = appBackStack[appBackStack.length - 1];
        if (prev && prev.type === 'modal') {
            const prevModal = prev.ref && prev.ref.nodeType === 1 ? prev.ref : (prev.ref ? document.getElementById(prev.ref.id || prev.ref) : null);
            if (prevModal) { try { showModalNoHistory(prevModal); } catch(e){ console.warn('Restore modal failed', e); } }
        }
        try { window.__lastBackAction = 'sidebar'; } catch(_) {}
        return true;
    }
    // 1a) If any modal is visible but not on stack (legacy open path), close it to avoid coupling to watchlist
    try {
        const candidates = Array.from(document.querySelectorAll('.modal'));
        const openModal = candidates.find(m => {
            const ds = (m.style && m.style.display) || '';
            const hasShow = m.classList && m.classList.contains('show');
            const cs = window.getComputedStyle ? window.getComputedStyle(m).display : '';
            return ds === 'flex' || hasShow || cs === 'flex';
        });
    if (openModal && (!last || last.type !== 'modal')) { logBackDebug('Closing visible modal (no stack)', openModal && openModal.id); hideModal(openModal); try { window.__lastBackAction = 'modal'; } catch(_) {} ; return true; }
    } catch(_) {}
    // 2) Close the sidebar if open
    if (window.appSidebar && window.appSidebar.classList.contains('open')) {
        if (typeof toggleAppSidebar === 'function') toggleAppSidebar(false);
        else {
            try {
                appSidebar.classList.remove('open');
                document.body.classList.remove('sidebar-active');
                document.body.style.overflow = '';
                if (sidebarOverlay){ sidebarOverlay.classList.remove('open'); sidebarOverlay.style.pointerEvents='none'; }
            } catch(_){}
        }
        try { window.__lastBackAction = 'watchlist'; } catch(_) {}
        return true;
    }
    // 2b) Revert a watchlist change: restore the previous selection directly (no picker)
    if (last && last.type === 'watchlist') {
        const entry = popAppStateEntry();
        const prevIds = (entry && Array.isArray(entry.ref)) ? entry.ref.slice(0) : [];
        try {
            const restoreIds = prevIds.length ? prevIds : [ALL_SHARES_ID];
            // Apply state
            setCurrentSelectedWatchlistIds(restoreIds);
            updateSortPickerButtonText();
            // Reflect in dropdown if present
            if (typeof watchlistSelect !== 'undefined' && watchlistSelect) {
                watchlistSelect.value = restoreIds[0] || '';
            }
            // Persist locally and remotely if available
            try { localStorage.setItem('lastWatchlistSelection', JSON.stringify(restoreIds)); } catch(_) {}
            try { if (typeof saveLastSelectedWatchlistIds === 'function') saveLastSelectedWatchlistIds(restoreIds); } catch(_) {}
            // Switch broader UI context
            if (restoreIds[0] === 'portfolio') {
                try { showPortfolioView(); } catch(_) {}
            } else {
                try { showWatchlistView(); } catch(_) {}
            }
            // Re-render current view
            try { if (typeof renderWatchlist === 'function') renderWatchlist(); } catch(_) {}
        } catch(e) { console.warn('Back: failed to restore previous watchlist selection', e); }
        return true;
    }
    // 2c) Revert a view mode change
    if (last && last.type === 'viewMode') {
        const entry = popAppStateEntry();
        const prevMode = entry && entry.ref;
        if (prevMode === 'compact' || prevMode === 'default') {
            try { setMobileViewMode(prevMode, 'back_restore'); } catch(e){ console.warn('Back: view mode restore failed', e); }
            try { showCustomAlert(prevMode === 'compact' ? 'Compact View' : 'Default View', 700); } catch(_) {}
            try { window.__lastBackAction = 'viewMode'; } catch(_) {}
            return true;
        }
    }
    // 3) No UI to reverse: default to preventing app exit, with an informative toast.
    // You can opt back into double-back-to-exit by setting window.__preventAppExit = false.
    try {
        const preventExit = (typeof window.__preventAppExit === 'boolean') ? window.__preventAppExit : true;
        if (preventExit) {
            try {
                const now = Date.now();
                if (now - (__lastBackToastAt || 0) > 250) {
                    __lastBackToastAt = now;
                    if (window.ToastManager && typeof window.ToastManager.info === 'function') {
                        window.ToastManager.info('Press back again to exit the app', 1500);
                    } else if (typeof window.showCustomAlert === 'function') {
                        window.showCustomAlert('Press back again to exit the app', 1500);
                    } else {
                        console.log('Press back again to exit the app');
                    }
                } else {
                    if (window.logBackDebug) window.logBackDebug('Back toast deduped');
                }
                try { window.__lastBackAction = 'preventExit'; } catch(_) {}
            } catch(_) {}
            return true; // consume
        } else {
            // Double-back-to-exit mode
            const now = Date.now();
            if (now - (__lastBackPressAt || 0) <= EXIT_BACK_TOAST_TIMEOUT_MS) {
                __lastBackPressAt = 0;
                return false; // allow exit on second press
            }
            __lastBackPressAt = now;
            try {
                if (window.ToastManager && typeof window.ToastManager.info === 'function') {
                    window.ToastManager.info('Press back again to exit the app', { duration: EXIT_BACK_TOAST_TIMEOUT_MS });
                } else if (typeof window.showCustomAlert === 'function') {
                    window.showCustomAlert('Press back again to exit the app', EXIT_BACK_TOAST_TIMEOUT_MS);
                } else {
                    console.log('Press back again to exit the app');
                }
                try { window.__lastBackAction = 'exitToast'; } catch(_) {}
            } catch (e) { console.warn('Exit toast failed', e); }
            return true;
        }
    } catch (e) {
        // On any unexpected failure, fall back to allowing browser back so user isn't trapped
        return false;
    }
}

// NOTE: popstate handled by unified handler installed earlier to centralize logic.

// Hardware / browser back key mapping (mobile)
window.addEventListener('keydown', e=>{
    if (e.key === 'Escape') {
        const last = appBackStack[appBackStack.length-1];
        if (last) { e.preventDefault(); history.back(); }
    }
});
// Expose a simple in-app back function for buttons to call
window.goBack = function(){
    if (!handleGlobalBack()) {
        try { history.back(); } catch(_){ /* no-op */ }
    }
};
const cashAssetsSection = document.getElementById('cashAssetsSection'); // UPDATED ID
const cashCategoriesContainer = document.getElementById('cashCategoriesContainer');
const addCashCategoryBtn = document.getElementById('addCashCategoryBtn'); // This will be removed or repurposed
const saveCashBalancesBtn = document.getElementById('saveCashBalancesBtn'); // This will be removed or repurposed
const totalCashDisplay = document.getElementById('totalCashDisplay');
const addCashAssetSidebarBtn = document.getElementById('addCashAssetSidebarBtn'); // NEW: Sidebar button for cash asset

// NEW: Cash Asset Modal Elements (2.1, 2.2)
const cashAssetFormModal = document.getElementById('cashAssetFormModal');
const cashFormTitle = document.getElementById('cashFormTitle');
const cashAssetNameInput = document.getElementById('cashAssetName');
const cashAssetBalanceInput = document.getElementById('cashAssetBalance');
const saveCashAssetBtn = document.getElementById('saveCashAssetBtn');
const deleteCashAssetBtn = document.getElementById('deleteCashAssetBtn');
const cashAssetFormCloseButton = document.querySelector('.cash-form-close-button'); // NEW: Specific close button for cash asset form
const cashAssetCommentsContainer = document.getElementById('cashAssetCommentsArea'); // NEW: Comments container for cash asset form
const addCashAssetCommentBtn = document.getElementById('addCashAssetCommentBtn'); // NEW: Add comment button for cash asset form

const cashAssetDetailModal = document.getElementById('cashAssetDetailModal');
const modalCashAssetName = document.getElementById('modalCashAssetName');
const detailCashAssetName = document.getElementById('detailCashAssetName');
const detailCashAssetBalance = document.getElementById('detailCashAssetBalance');
const detailCashAssetLastUpdated = document.getElementById('detailCashAssetLastUpdated');
const editCashAssetFromDetailBtn = document.getElementById('editCashAssetFromDetailBtn');
const deleteCashAssetFromDetailBtn = document.getElementById('deleteCashAssetFromDetailBtn');
const modalCashAssetCommentsContainer = document.getElementById('modalCashAssetCommentsContainer'); // NEW: Comments container for cash asset details


let sidebarOverlay = document.querySelector('.sidebar-overlay');
if (!sidebarOverlay) {
    sidebarOverlay = document.createElement('div');
    sidebarOverlay.classList.add('sidebar-overlay');
    document.body.appendChild(sidebarOverlay);
}
// Ensure Force Update button exists in sidebar (idempotent injection for diagnostics)
try {
    if (appSidebar && !document.getElementById('forceUpdateBtn')) {
        const btn = document.createElement('button');
        btn.id = 'forceUpdateBtn';
        btn.className = 'menu-button-item';
        btn.textContent = 'Force Update';
        btn.setAttribute('data-action-closes-menu','true');
        // Insert near end
        appSidebar.appendChild(btn);
    }
} catch(_) {}

const formInputs = [
    shareNameInput,
    // currentPriceInput removed (auto mode)
    targetPriceInput,
    dividendAmountInput,
    frankingCreditsInput,
    // Include portfolio-specific fields so Save enables when they change
    document.getElementById('portfolioShares'),
    document.getElementById('portfolioAvgPrice'),
    shareRatingSelect
];

// NEW: Form inputs for Cash Asset Modal
const cashFormInputs = [
    cashAssetNameInput, cashAssetBalanceInput
];


// --- GLOBAL HELPER FUNCTIONS ---

// Function to update the sort icon based on the selected sort order
function updateSortIcon() {
    const sortSelect = document.getElementById('sortSelect');
    const sortIcon = document.getElementById('sortIcon');
    if (!sortSelect || !sortIcon) return;

    const selectedOption = sortSelect.options[sortSelect.selectedIndex];
    if (!selectedOption) return;

    const sortValue = selectedOption.value;

    sortIcon.className = 'sort-icon'; // Reset classes

    // Green up arrow for descending (e.g., price_desc -> high to low)
    if (sortValue.endsWith('_desc')) {
        sortIcon.classList.add('up');
    }
    // Red down arrow for ascending (e.g., price_asc -> low to high)
    else if (sortValue.endsWith('_asc')) {
        sortIcon.classList.add('down');
    }
}


const appsScriptUrl = 'https://script.google.com/macros/s/AKfycbwwwMEss5DIYblLNbjIbt_TAzWh54AwrfQlVwCrT_P0S9xkAoXhAUEUg7vSEPYUPOZp/exec';
try { window.appsScriptUrl = appsScriptUrl; } catch(_) {}

async function fetchLivePricesAndUpdateUI() {
    logDebug('UI: Refresh Live Prices button clicked.');
    // Show a loading state if needed
    // You may have a function like showLoadingIndicator();
    
    // Call the newly updated live price fetch function
    await fetchLivePrices({ cacheBust: true });

    // Hide the loading state
    // You may have a function like hideLoadingIndicator();
}

/**
 * Fetches live price data from the Google Apps Script Web App.
 * Updates the `livePrices` global object.
 */
/* moved to priceService.js */
/* async function fetchLivePrices(opts = {}) {
    logDebug('Live Price: Fetching from Apps Script...');
    try {
        // Set last updated timestamp for portfolio view
        window._portfolioLastUpdated = new Date().toLocaleString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' });
        // Prefer GOOGLE_APPS_SCRIPT_URL if defined, fallback to appsScriptUrl constant.
    const baseUrl = typeof GOOGLE_APPS_SCRIPT_URL !== 'undefined' ? GOOGLE_APPS_SCRIPT_URL : (typeof appsScriptUrl !== 'undefined' ? appsScriptUrl : null);
    if (!baseUrl) throw new Error('Apps Script URL not defined');
    // Optional query params: cacheBust, stockCode support
    const qs = new URLSearchParams();
    if (opts && opts.cacheBust) qs.set('_ts', Date.now().toString());
    if (opts && opts.stockCode) qs.set('stockCode', String(opts.stockCode).toUpperCase());
    const url = qs.toString() ? (baseUrl + (baseUrl.includes('?') ? '&' : '?') + qs.toString()) : baseUrl;
    const response = await fetch(url, { cache: 'no-store' }); // no-store to avoid stale cached 302 chain
        if (!response.ok) throw new Error('HTTP ' + response.status);
        const data = await response.json();
        if (!Array.isArray(data)) {
            console.warn('Live Price: Response not an array, got:', data);
            window._livePricesLoaded = true; hideSplashScreenIfReady(); return;
        }
        if (DEBUG_MODE && data[0]) console.log('Live Price: Sample keys', Object.keys(data[0]));

        const haveShares = Array.isArray(allSharesData) && allSharesData.length > 0;
        const needed = haveShares ? new Set(allSharesData.filter(s => s && s.shareName).map(s => s.shareName.toUpperCase())) : null;
        const LOG_LIMIT = 30;
        let skipped = 0, skippedLogged = 0, accepted = 0, surrogate = 0, filtered = 0;
    const newLivePrices = {};
    // Reset external rows container for this cycle
    globalExternalPriceRows = [];

        // Helper: normalize numeric fields; treat null / undefined / '' / '#N/A' as zero
        const numOrNull = v => {
            if (v === null || v === undefined) return 0;
            if (typeof v === 'string') {
                const t = v.trim();
                if (!t || t.toUpperCase() === '#N/A') return 0;
                const parsed = parseFloat(t.replace(/,/g,''));
                return isNaN(parsed) ? 0 : parsed;
            }
            if (typeof v === 'number') return isNaN(v) ? 0 : v;
            return 0;
        };

    data.forEach(item => {
            if (!item) return;
            const codeRaw = item.ASXCode || item.ASX_Code || item['ASX Code'] || item.Code || item.code;
            if (!codeRaw) return; // no code
            const code = String(codeRaw).toUpperCase().trim();
            if (!code) return;
            const liveParsed = numOrNull(
                item.LivePrice || item['Live Price'] || item.live || item.price ||
                item.Last || item['Last Price'] || item.LastPrice || item['Last Trade'] || item.LastTrade
            );
            const prevParsed = numOrNull(
                item.PrevClose || item['Prev Close'] || item.previous || item.prev || item.prevClose ||
                item['Previous Close'] || item.Close || item['Last Close']
            );
            if (needed && !needed.has(code)) {
                // Keep a lean record for discovery if we have sufficient data for threshold evaluation
                if (liveParsed !== null && prevParsed !== null) {
                    globalExternalPriceRows.push({ code, live: liveParsed, prevClose: prevParsed });
                }
                filtered++; return;
            }
            const peParsed = numOrNull(item.PE || item['PE Ratio'] || item.pe);
            const high52Parsed = numOrNull(item.High52 || item['High52'] || item['High 52'] || item['52WeekHigh'] || item['52 High']);
            const low52Parsed = numOrNull(item.Low52 || item['Low52'] || item['Low 52'] || item['52WeekLow'] || item['52 Low']);

            const hasLive = liveParsed !== null;
            const hasPrev = prevParsed !== null;
            const effectiveLive = hasLive ? liveParsed : (hasPrev ? prevParsed : NaN);
            if (isNaN(effectiveLive)) {
                skipped++; if (DEBUG_MODE && skippedLogged < LOG_LIMIT) { console.warn('Live Price skip (no usable price)', code, item); skippedLogged++; }
                return;
            }
            if (!hasLive && hasPrev) surrogate++;
            accepted++;

            // Target evaluation
            const shareData = haveShares ? allSharesData.find(s => s && s.shareName && s.shareName.toUpperCase() === code) : null;
            const targetPrice = shareData && !isNaN(parseFloat(shareData.targetPrice)) ? parseFloat(shareData.targetPrice) : undefined;
            const dir = shareData && shareData.targetDirection ? shareData.targetDirection : 'below';
            let hit = false;
            if (targetPrice !== undefined) {
                hit = dir === 'above' ? (effectiveLive >= targetPrice) : (effectiveLive <= targetPrice);
            }

            const companyName = (item.CompanyName || item['Company Name'] || item.Name || item.name || '').toString().trim() || null;
            if (companyName && Array.isArray(allAsxCodes) && !allAsxCodes.some(c => c.code === code)) {
                allAsxCodes.push({ code, name: companyName });
            }

            newLivePrices[code] = {
                live: effectiveLive,
                prevClose: hasPrev ? prevParsed : null,
                PE: peParsed,
                High52: high52Parsed,
                Low52: low52Parsed,
                targetHit: hit,
                lastLivePrice: effectiveLive,
                lastPrevClose: hasPrev ? prevParsed : null,
                surrogateFromPrevClose: (!hasLive && hasPrev) || undefined,
                companyName: companyName || undefined
            };
        });

        setLivePrices(newLivePrices);
    // After updating livePrices but before recomputeTriggeredAlerts, evaluate global alert thresholds
    console.log('[GlobalAlerts] About to call evaluateGlobalPriceAlerts from script.js fetchLivePrices');
    try { evaluateGlobalPriceAlerts(); } catch(e){ console.warn('Global Alerts: evaluation failed', e); }
        if (DEBUG_MODE) {
            const parts = [`accepted=${accepted}`];
            if (surrogate) parts.push(`surrogate=${surrogate}`);
            if (skipped) parts.push(`skipped=${skipped}`);
            if (filtered) parts.push(`filtered=${filtered}`);
            if (skipped > LOG_LIMIT) parts.push(`skippedNotLogged=${skipped - LOG_LIMIT}`);
            console.log('Live Price: Summary ' + parts.join(', '));
        }
        // --- 52-Week Low Alert Detection ---
        if (!window.__isTesting52WeekLowAlerts) {
            sharesAt52WeekLow = [];
        }
        if (!window.__isTesting52WeekLowAlerts) {
            if (Array.isArray(allSharesData)) {
                allSharesData.forEach(share => {
                    const code = (share.shareName || '').toUpperCase();
                    const lpObj = livePrices ? livePrices[code] : undefined;
                    if (!lpObj || lpObj.live == null || isNaN(lpObj.live) || lpObj.Low52 == null || isNaN(lpObj.Low52)) return;
                    const isMuted = !!(window.__low52MutedMap && window.__low52MutedMap[code + '_low']);
                    if (lpObj.live <= lpObj.Low52 && !triggered52WeekLowSet.has(code)) {
                        // Try to get the correct company name from allAsxCodes
                        let displayName = code;
                        if (Array.isArray(allAsxCodes)) {
                            const match = allAsxCodes.find(c => c.code === code);
                            if (match && match.name) displayName = match.name;
                        }
                        if (!displayName && share.companyName) displayName = share.companyName;
                        sharesAt52WeekLow.push({
                            code,
                            name: displayName,
                            live: lpObj.live,
                            low52: lpObj.Low52,
                            type: 'low',
                            muted: isMuted
                        });
                        triggered52WeekLowSet.add(code);
                    }
                });
            }
            // Test card removed - 52-week low detection is now working properly
        }
        onLivePricesUpdated();
        window._livePricesLoaded = true;
        hideSplashScreenIfReady();
    // Recompute triggered alerts purely from live price targetHit flags + alert enabled map
    try { recomputeTriggeredAlerts(); } catch(e) { console.warn('Alerts: recompute after live price fetch failed', e); }
    updateTargetHitBanner();
    } catch (e) {
        console.error('Live Price: Fetch error', e);
        window._livePricesLoaded = true;
        hideSplashScreenIfReady();
    }
} */
/**
 * Dynamically adjusts the top padding of the main content area
 * to prevent it from being hidden by the fixed header.
 * Uses scrollHeight to get the full rendered height, including wrapped content.
 */
function adjustMainContentPadding() {
    console.log('[PADDING DEBUG] adjustMainContentPadding called');
    // Ensure both the header and main content container elements exist.
    if (appHeader && mainContainer) {
        // Get the current rendered height of the fixed header, including any wrapped content.
        // offsetHeight is usually sufficient, but scrollHeight can be more robust if content overflows.

// --- Mobile Keyboard Scroll Fix for Add/Edit Share Modal ---
function enableShareFormMobileScrollFix() {
    // If the new global keyboard-aware modal manager is present, defer to it entirely.
    // This avoids conflicting inline height/padding between two systems.
    if (window.ModalViewportManager && typeof window.ModalViewportManager.refresh === 'function') {
        try { window.ModalViewportManager.refresh(); } catch(_) {}
        return; // unified manager handles sizing and scrolling across all modals
    }
    if (!shareFormSection) return;
    // Only apply on mobile devices
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    if (!isMobile) return;
    // Better focus handling: scroll the focused input into the visible area of the modal
    shareFormSection.addEventListener('focusin', function(e) {
        const target = e.target;
        if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT')) {
            // Short timeout to allow virtual keyboard to appear and visualViewport to stabilize
            setTimeout(() => {
                try {
                    const modalContent = shareFormSection.querySelector('.single-scroll-modal') || shareFormSection;
                    // Determine the visible viewport rect (prefer visualViewport when available)
                    let vvTop = 0, vvHeight = window.innerHeight;
                    if (window.visualViewport) { vvTop = window.visualViewport.offsetTop || 0; vvHeight = window.visualViewport.height; }

                    // Compute target position relative to modal
                    const targetRect = target.getBoundingClientRect();
                    const modalRect = modalContent.getBoundingClientRect();
                    const relativeTop = targetRect.top - modalRect.top;

                    // If target is outside the visible area (above or below), scroll it into view within modal
                    if (relativeTop < 0 || (relativeTop + targetRect.height) > modalRect.height) {
                        // Preferred: use modal's scrollTo with an offset so the input sits comfortably above keyboard
                        const desiredTop = Math.max(0, relativeTop - 80);
                        try { modalContent.scrollTo({ top: desiredTop, behavior: 'smooth' }); } catch(_) { modalContent.scrollTop = desiredTop; }
                    }
                } catch(_) {}
            }, 140);
        }
    });

    // Adjust modal container height/padding when visualViewport changes (keyboard show/hide)
    const applyViewportSizing = () => {
        const modalContent = shareFormSection.querySelector('.single-scroll-modal') || shareFormSection;
        if (!modalContent) return;
        if (window.visualViewport) {
            try {
                // Use the visualViewport height as the usable area and set padding-bottom to account for keyboard
                const vv = window.visualViewport;
                modalContent.style.height = vv.height + 'px';
                modalContent.style.maxHeight = vv.height + 'px';
                // Add padding-bottom equal to viewport offset (some browsers expose offsetTop when keyboard present)
                const extraBottom = Math.max(12, Math.floor((window.innerHeight - vv.height)));
                modalContent.style.paddingBottom = (18 + extraBottom) + 'px';
            } catch(_) {}
        } else {
            // Fallback: ensure modal fills viewport
            modalContent.style.height = '100vh';
            modalContent.style.maxHeight = '100vh';
            modalContent.style.paddingBottom = '24px';
        }
    };

    if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', applyViewportSizing);
        window.visualViewport.addEventListener('scroll', applyViewportSizing);
    }
    // Also run once to initialize sizes
    setTimeout(applyViewportSizing, 60);
}

// Enable the fix on DOMContentLoaded
document.addEventListener('DOMContentLoaded', enableShareFormMobileScrollFix);
        // For a fixed header, offsetHeight should reflect its full rendered height.
        const headerHeight = appHeader.offsetHeight;
        const oldPadding = mainContainer.style.paddingTop;

        console.log('[PADDING DEBUG] Header height:', headerHeight, 'Old padding:', oldPadding);

        // Apply this height as padding to the top of the main content container.
        mainContainer.style.paddingTop = `${headerHeight}px`;
        logDebug('Layout: Adjusted main content padding-top to: ' + headerHeight + 'px (Full Header Height).');

        console.log('[PADDING DEBUG] New padding set to:', headerHeight + 'px');
    } else {
        console.warn('[PADDING DEBUG] Could not adjust main content padding-top: appHeader or mainContainer not found.');
        console.log('[PADDING DEBUG] appHeader found:', !!appHeader, 'mainContainer found:', !!mainContainer);
    }
}

/**
 * Calculates the target scroll position to place watchlist directly underneath the header
 * @returns {number} The scroll position where watchlist should start
 */
function calculateWatchlistScrollPosition() {
    console.log('[SCROLL CALC] calculateWatchlistScrollPosition called');
    if (!appHeader) {
        console.warn('[SCROLL CALC] appHeader not found, returning 0');
        return 0;
    }

    const headerHeight = appHeader.offsetHeight;
    console.log('[SCROLL CALC] Header height:', headerHeight, 'Target scroll position:', headerHeight);
    return headerHeight;
}

/**
 * Helper function to apply/remove a disabled visual state to non-button elements (like spans/icons).
 * This adds/removes the 'is-disabled-icon' class, which CSS then styles.
 * @param {HTMLElement} element The element to disable/enable.
 * @param {boolean} isDisabled True to disable, false to enable.
 */
function setIconDisabled(element, isDisabled) {
    if (!element) {
        console.warn('setIconDisabled: Element is null or undefined. Cannot set disabled state.');
        return;
    }
    if (isDisabled) {
        element.classList.add('is-disabled-icon');
    } else {
        element.classList.remove('is-disabled-icon');
    }
}

// Phase 2 helper: create or update a per-share alert document for the current user
async function upsertAlertForShare(shareId, shareCode, shareData, isNew) {
    if (!db || !currentUserId || !firestore) {
        console.warn('Alerts: Firestore not available; skipping alert upsert.');
        return;
    }
    if (!shareId) {
        console.warn('Alerts: Missing shareId for alert upsert; skipping.');
        return;
    }
    // Collection path: artifacts/{appId}/users/{userId}/alerts
    const alertsCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/alerts');
    // We'll use a deterministic doc id per share to keep one alert document per share
    const alertDocId = shareId; // 1:1 mapping; adjust if multiple alerts per share later
    const alertDocRef = firestore.doc(alertsCol, alertDocId);

    // Interpret UI intent and direction
    // Intent: buy when direction is below; sell when direction is above (can extend later to explicit intent buttons)
    const direction = (shareData && shareData.targetDirection) === 'above' ? 'above' : 'below';
    let intent = 'buy';
    try {
        const buyActive = !!(typeof targetIntentBuyBtn !== 'undefined' && targetIntentBuyBtn && targetIntentBuyBtn.classList.contains('is-active'));
        const sellActive = !!(typeof targetIntentSellBtn !== 'undefined' && targetIntentSellBtn && targetIntentSellBtn.classList.contains('is-active'));
        intent = buyActive && !sellActive ? 'buy' : (sellActive && !buyActive ? 'sell' : (direction === 'above' ? 'sell' : 'buy'));
    } catch(_) {
        intent = direction === 'above' ? 'sell' : 'buy';
    }

    const payload = {
        shareId: shareId,
        shareCode: String(shareCode || '').toUpperCase(),
        userId: currentUserId,
        appId: currentAppId,
        intent: intent, // 'buy' | 'sell'
        direction: direction, // 'above' | 'below'
        targetPrice: (typeof shareData?.targetPrice === 'number' && !isNaN(shareData.targetPrice)) ? shareData.targetPrice : null,
        // createdAt added below only when isNew to avoid undefined writes
        updatedAt: firestore.serverTimestamp(),
        enabled: true
    };

    if (isNew) {
        payload.createdAt = firestore.serverTimestamp();
    }

    // Compute initial targetHit status immediately so the listener can pick it up
    try {
        const codeUpper = String(shareCode || '').toUpperCase();
        const lp = (typeof livePrices === 'object' && livePrices) ? livePrices[codeUpper] : null;
        const latestLive = (lp && lp.live !== null && !isNaN(lp.live)) ? lp.live
            : (lp && lp.lastLivePrice !== null && !isNaN(lp.lastLivePrice)) ? lp.lastLivePrice
            : null;
        const fallbackRef = (typeof shareData?.currentPrice === 'number' && !isNaN(shareData.currentPrice)) ? shareData.currentPrice : null;
        const current = (latestLive !== null) ? latestLive : (fallbackRef !== null ? fallbackRef : null);
        const tPrice = (typeof payload.targetPrice === 'number' && !isNaN(payload.targetPrice)) ? payload.targetPrice : null;
        let isHit = false;
        if (current !== null && tPrice !== null) {
            isHit = direction === 'above' ? (current >= tPrice) : (current <= tPrice);
        }
        payload.targetHit = !!isHit;
        payload.lastEvaluatedAt = firestore.serverTimestamp();
    } catch (e) {
        console.warn('Alerts: Failed to compute initial targetHit; defaulting to false.', e);
        payload.targetHit = false;
        payload.lastEvaluatedAt = firestore.serverTimestamp();
    }

    // Use setDoc with merge to avoid overwriting createdAt when updating
    await firestore.setDoc(alertDocRef, payload, { merge: true });
    logDebug('Alerts: Upserted alert for ' + shareCode + ' with intent ' + intent + ' and direction ' + direction + '.');
}

// Centralized Modal Closing Function
function closeModals() {
    // If callers specifically set this flag, skip any auto-save logic while closing modals.
    const __suppressAutoSaveOnClose = !!(window && window.__suppressAutoSaveOnClose);
    // Auto-save logic for share form
    if (!__suppressAutoSaveOnClose && shareFormSection && shareFormSection.style.display !== 'none') {
        logDebug('Auto-Save: Share form modal is closing. Checking for unsaved changes.');


        const currentData = getCurrentFormData();
        const isShareNameValid = currentData.shareName.trim() !== '';

        // The cancel button fix means clearForm() is called before closeModals()
        // For auto-save on clicking outside or other non-cancel closes:
        if (selectedShareDocId) { // Existing share
            if (originalShareData && !areShareDataEqual(originalShareData, currentData)) { // Check if originalShareData exists and if form is dirty
                logDebug('Auto-Save: Unsaved changes detected for existing share. Attempting silent save.');
                saveShareData(true); // true indicates silent save
            } else {
                logDebug('Auto-Save: No changes detected for existing share.');
            }
        } else { // New share
            // Only attempt to save if a share name was entered AND a watchlist was selected (if applicable)
            const isWatchlistSelected = shareWatchlistSelect && shareWatchlistSelect.value !== '';
            const needsWatchlistSelection = getCurrentSelectedWatchlistIds().includes(ALL_SHARES_ID);
            
            if (isShareNameValid && isWatchlistSelected) { // Always require watchlist selection for new shares
                logDebug('Auto-Save: New share detected with valid name and watchlist. Attempting silent save.');
                saveShareData(true); // true indicates silent save
            } else {
                logDebug('Auto-Save: New share has no name or invalid watchlist. Discarding changes.');
            }
        }
    }

    // NEW: Auto-save logic for watchlist modals
    if (!__suppressAutoSaveOnClose && addWatchlistModal && addWatchlistModal.style.display !== 'none') {
        logDebug('Auto-Save: Add Watchlist modal is closing. Checking for unsaved changes.');
        const currentWatchlistData = getCurrentWatchlistFormData(true); // true for add modal
        if (currentWatchlistData.name.trim() !== '') {
            logDebug('Auto-Save: New watchlist detected with name. Attempting silent save.');
            saveWatchlistChanges(true, currentWatchlistData.name); // true indicates silent save, pass name
        } else {
            logDebug('Auto-Save: New watchlist has no name. Discarding changes.');
        }
    }

    if (!__suppressAutoSaveOnClose && manageWatchlistModal && manageWatchlistModal.style.display !== 'none') {
        logDebug('Auto-Save: Manage Watchlist modal is closing. Checking for unsaved changes.');
        const currentWatchlistData = getCurrentWatchlistFormData(false); // false for edit modal
        if (originalWatchlistData && !areWatchlistDataEqual(originalWatchlistData, currentWatchlistData)) {
            logDebug('Auto-Save: Unsaved changes detected for existing watchlist. Attempting silent save.');
            saveWatchlistChanges(true, currentWatchlistData.name, watchlistSelect.value); // true indicates silent save, pass name and ID
        } else {
            logDebug('Auto-Save: No changes detected for existing watchlist.');
        }
    }

    // Close target hit details modal (no auto-save needed for this one)
    if (targetHitDetailsModal && targetHitDetailsModal.style.display !== 'none') {
        logDebug('Auto-Close: Target Hit Details modal is closing.');
        // No auto-save or dirty check needed for this display modal
    }
    // Leave a blank line here for readability.

    // NEW: Auto-save logic for cash asset form modal (2.1)
    if (!__suppressAutoSaveOnClose && cashAssetFormModal && cashAssetFormModal.style.display !== 'none') {
        logDebug('Auto-Save: Cash Asset form modal is closing. Checking for unsaved changes.');
        const currentCashData = getCurrentCashAssetFormData();
        const isCashAssetNameValid = currentCashData.name.trim() !== '';
        // Avoid triggering auto-save if a save is already in progress (prevents duplicate saves and races)
        if (window.__modalSaveInProgress) {
            logDebug('Auto-Save: Skipping cash asset auto-save because a save is already in progress.');
        } else {
            if (selectedCashAssetDocId) { // Existing cash asset
                if (originalCashAssetData && !areCashAssetDataEqual(originalCashAssetData, currentCashData)) {
                    logDebug('Auto-Save: Unsaved changes detected for existing cash asset. Attempting silent save.');
                    saveCashAsset(true); // true indicates silent save
                } else {
                    logDebug('Auto-Save: No changes detected for existing cash asset.');
                }
            } else { // New cash asset
                if (isCashAssetNameValid) {
                    logDebug('Auto-Save: New cash asset detected with valid name. Attempting silent save.');
                    saveCashAsset(true); // true indicates silent save
                } else {
                    logDebug('Auto-Save: New cash asset has no name. Discarding changes.');
                }
            }
        }
    }


    // Purge any modal entries from the back stack (we're closing all modals)
    try {
        if (Array.isArray(appBackStack) && appBackStack.length) {
            for (let i = appBackStack.length - 1; i >= 0; i--) {
                if (appBackStack[i] && appBackStack[i].type === 'modal') appBackStack.splice(i,1);
            }
            logBackDebug('STACK purge all modals', 'stack=', appBackStack.map(e=>e.type+':'+(e.ref && (e.ref.id||e.ref))).join(' | '));
        }
    } catch(_) {}

    // Delegate actual DOM closing/cleanup to UI module if available
    if (window.UI && typeof window.UI.closeModals === 'function') {
        try { window.UI.closeModals(); } catch(e) { console.warn('UI.closeModals failed', e); }
    } else {
    document.querySelectorAll('.modal').forEach(modal => {
        if (modal) {
            modal.style.setProperty('display', 'none', 'important');
        }
    });
        try { resetCalculator(); } catch(_) {}
        try { deselectCurrentShare(); } catch(_) {}
        try { deselectCurrentCashAsset(); } catch(_) {}
    if (autoDismissTimeout) { clearTimeout(autoDismissTimeout); autoDismissTimeout = null; }
        try { hideContextMenu(); } catch(_) {}
        if (alertPanel) try { hideModal(alertPanel); } catch(_) {}
    logDebug('Modal: All modals closed.');
    }

    // Clear any lingering active highlight on ASX code buttons when closing modals
    if (asxCodeButtonsContainer) {
        asxCodeButtonsContainer.querySelectorAll('button.asx-code-btn.active').forEach(btn=>btn.classList.remove('active'));
    }

    // Restore Target Price Alerts modal if share detail was opened from it (only if a share remains selected)
    if (wasShareDetailOpenedFromTargetAlerts) {
        if (selectedShareDocId) {
            logDebug('Restoring Target Price Alerts modal after closing share detail modal.');
            if (targetHitDetailsModal) {
                showModal(targetHitDetailsModal);
            }
        } else {
            logDebug('Skipping restore of Target Price Alerts modal because no share is selected.');
        }
        wasShareDetailOpenedFromTargetAlerts = false;
    }

    // Restore Share Detail modal only if it was the source AND a share is still selected
    if (wasEditOpenedFromShareDetail) {
        if (selectedShareDocId) {
            logDebug('Restoring Share Detail modal after closing edit modal.');
            if (shareDetailModal) {
                showModal(shareDetailModal);
            }
        } else {
            logDebug('Skipping restore of Share Detail modal because no share is selected.');
        }
        wasEditOpenedFromShareDetail = false;
    }
}

// Attach closeModals to window for use in other modules
window.closeModals = closeModals;

// Toast-based lightweight alert; keeps API but renders a toast instead of blocking modal
function showCustomAlert(message, duration = 3000, type = 'info') {
    if (window.UI && typeof window.UI.showCustomAlert === 'function') return window.UI.showCustomAlert(message, duration, type);
    // Minimal fallback
    try { window.alert(message); } catch(_) { console.log('ALERT:', message); }
}

// Expose globally for use in other modules
window.showCustomAlert = showCustomAlert;

// ToastManager: centralized API
const ToastManager = (() => {
    const container = () => document.getElementById('toastContainer');
    const makeToast = (opts) => {
        const root = container();
        if (!root) return null;
        const { message, type = 'info', duration = 2000, actions = [] } = opts || {};
        // Enforce minimum 3000ms for auto-dismiss unless explicitly sticky (0)
        const effectiveDuration = (duration === 0) ? 0 : Math.max(duration || 3000, 3000);
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.setAttribute('role', type === 'error' ? 'alert' : 'status');
        const iconHTML = `<span class="icon"></span>`;
        const msgHTML = `<div class="message"></div>`;
        const actionsHTML = actions.length ? `<div class="actions">${actions.map(a=>`<button class=\"btn ${a.variant||''}\">${a.label}</button>`).join('')}</div>` : '';
        const closeHTML = ``; // REMOVED
        toast.innerHTML = `${iconHTML}${msgHTML}${actionsHTML}${closeHTML}`;
        toast.querySelector('.message').textContent = message || '';
        const remove = () => { toast.classList.remove('show'); setTimeout(()=> toast.remove(), 200); };
        // Wire actions
        const actionBtns = toast.querySelectorAll('.actions .btn');
        actionBtns.forEach((btn, idx) => {
            const cfg = actions[idx];
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                try { cfg && typeof cfg.onClick === 'function' && cfg.onClick(); } finally { remove(); }
            });
        });
        root.appendChild(toast);
        requestAnimationFrame(()=> toast.classList.add('show'));
        if (effectiveDuration && effectiveDuration > 0) setTimeout(remove, effectiveDuration);
        return { el: toast, close: remove };
    };
    return {
    info: (message, duration=3000) => makeToast({ message, type:'info', duration }),
    success: (message, duration=3000) => makeToast({ message, type:'success', duration }),
    error: (message, duration=3000) => makeToast({ message, type:'error', duration }),
        confirm: (message, { confirmText='Yes', cancelText='No', onConfirm, onCancel } = {}) => {
            return makeToast({
                message,
                type: 'info',
                duration: 0, // sticky until action
                actions: [
                    { label: confirmText, variant: 'primary', onClick: () => { onConfirm && onConfirm(true); } },
                    { label: cancelText, variant: 'danger', onClick: () => { onCancel && onCancel(false); } }
                ]
            });
        }
    };
})();

// Attach ToastManager to window for use in other modules
window.ToastManager = ToastManager;

// Expose showCustomConfirm globally via UI implementation
window.showCustomConfirm = function(message, callback){
    try {
        if (window.UI && typeof window.UI.showCustomConfirm === 'function') return window.UI.showCustomConfirm(message, callback);
    } catch(_) {}
    try {
        if (window.ToastManager && typeof window.ToastManager.confirm === 'function') {
            const res = window.ToastManager.confirm(message, { confirmText: 'Confirm', cancelText: 'Cancel', onConfirm: ()=>callback && callback(true), onCancel: ()=>callback && callback(false) });
            if (res) return;
        }
    } catch(_) {}
    try { callback && callback(false); } catch(_) {}
};
// Date Formatting Helper Functions (Australian Style)

/**
 * A centralized helper function to compute all display-related data for a share.
 * This avoids duplicating complex logic in multiple rendering functions.
 * @param {object} share The share object.
 * @returns {object} An object containing calculated values for display.
 */
function getShareDisplayData(share) {
    const livePriceData = livePrices[share.shareName.toUpperCase()];
    const isMarketOpen = isAsxMarketOpen();

    let displayLivePrice = 'N/A';
    let displayPriceChange = '';
    let priceClass = '';
    let cardPriceChangeClass = '';
    let yieldDisplayTable = '';
    let yieldDisplayMobile = '';
    let peRatio = 'N/A';
    let high52Week = 'N/A';
    let low52Week = 'N/A';
    let isNewShareIndicator = '';

    // Check if this is a completely new share that might need live pricing initialization
    const isNewShare = !livePriceData && share.shareName;
    const shareCode = share.shareName?.toUpperCase();

    if (livePriceData) {
        const currentLivePrice = livePriceData.live;
        const previousClosePrice = livePriceData.prevClose;
        const lastFetchedLive = livePriceData.lastLivePrice;
        const lastFetchedPrevClose = livePriceData.lastPrevClose;

        peRatio = livePriceData.PE !== null && !isNaN(livePriceData.PE) && livePriceData.PE !== 0 ? formatAdaptivePrice(livePriceData.PE) : (livePriceData.PE === 0 ? '0.00' : 'N/A');
        high52Week = livePriceData.High52 !== null && !isNaN(livePriceData.High52) && livePriceData.High52 !== 0 ? formatMoney(livePriceData.High52) : (livePriceData.High52 === 0 ? '0.00' : 'N/A');
        low52Week = livePriceData.Low52 !== null && !isNaN(livePriceData.Low52) && livePriceData.Low52 !== 0 ? formatMoney(livePriceData.Low52) : (livePriceData.Low52 === 0 ? '0.00' : 'N/A');

    // (Removed legacy halving; display full change values)

        if (isMarketOpen) {
            if (currentLivePrice !== null && !isNaN(currentLivePrice)) {
                displayLivePrice = formatMoney(currentLivePrice);
            }
            if (currentLivePrice !== null && previousClosePrice !== null && !isNaN(currentLivePrice) && !isNaN(previousClosePrice)) {
                let change = currentLivePrice - previousClosePrice;
                let percentageChange = (previousClosePrice !== 0 ? (change / previousClosePrice) * 100 : 0);
                displayPriceChange = formatDailyChange(change, percentageChange);
                priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                cardPriceChangeClass = change > 0 ? 'positive-change-card' : (change < 0 ? 'negative-change-card' : 'neutral-change-card');
            } else if (lastFetchedLive !== null && lastFetchedPrevClose !== null && !isNaN(lastFetchedLive) && !isNaN(lastFetchedPrevClose)) {
                let change = lastFetchedLive - lastFetchedPrevClose;
                let percentageChange = (lastFetchedPrevClose !== 0 ? (change / lastFetchedPrevClose) * 100 : 0);
                displayPriceChange = formatDailyChange(change, percentageChange);
                priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                cardPriceChangeClass = change > 0 ? 'positive-change-card' : (change < 0 ? 'negative-change-card' : 'neutral-change-card');
            }
        } else {
            displayLivePrice = lastFetchedLive !== null && !isNaN(lastFetchedLive) ? formatMoney(lastFetchedLive) : '0.00';
            displayPriceChange = '0.00 (0.00%)';
            priceClass = 'neutral';
            cardPriceChangeClass = '';
        }
    } else {
        // No live price data available - use entry price as fallback
        if (share.entryPrice && !isNaN(Number(share.entryPrice))) {
            displayLivePrice = formatMoney(Number(share.entryPrice));

            // Try to show meaningful price change information
            let priceChangeCalculated = false;

            // First priority: Use the share's stored price history (most reliable for new shares)
            if (share.lastFetchedPrice && share.previousFetchedPrice &&
                !isNaN(Number(share.lastFetchedPrice)) && !isNaN(Number(share.previousFetchedPrice)) &&
                Number(share.lastFetchedPrice) !== Number(share.previousFetchedPrice)) {
                // Use the share's own price history for change calculation
                let change = Number(share.lastFetchedPrice) - Number(share.previousFetchedPrice);
                let percentageChange = (Number(share.previousFetchedPrice) !== 0 ?
                    (change / Number(share.previousFetchedPrice)) * 100 : 0);

                // Use full change values (removed legacy 50% reduction)

                displayPriceChange = formatDailyChange(change, percentageChange);
                priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                cardPriceChangeClass = change > 0 ? 'positive-change-card' : (change < 0 ? 'negative-change-card' : 'neutral-change-card');
                priceChangeCalculated = true;

                console.log('[DISPLAY] Using stored price history for day change:', shareCode, 'change:', change, 'pct:', percentageChange);
            }

            // Second priority: Use live price data if stored data isn't available
            if (!priceChangeCalculated && livePrices && livePrices[shareCode]) {
                const liveData = livePrices[shareCode];
                if (liveData.live !== null && liveData.prevClose !== null &&
                    !isNaN(liveData.live) && !isNaN(liveData.prevClose) &&
                    liveData.live !== liveData.prevClose) {
                    let change = liveData.live - liveData.prevClose;
                    let percentageChange = (liveData.prevClose !== 0 ? (change / liveData.prevClose) * 100 : 0);

                    // Use full change values (removed legacy 50% reduction)

                    displayPriceChange = formatDailyChange(change, percentageChange);
                    priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                    cardPriceChangeClass = change > 0 ? 'positive-change-card' : (change < 0 ? 'negative-change-card' : 'neutral-change-card');
                    priceChangeCalculated = true;

                    console.log('[DISPLAY] Using live price data for day change:', shareCode, 'change:', change, 'pct:', percentageChange);
                }
            }

            // If still no price change data available, show nothing or zero
            if (!priceChangeCalculated) {
                displayPriceChange = '0.00 (0.00%)';
                priceClass = 'neutral';
                cardPriceChangeClass = '';
                console.log('[DISPLAY] No price change data available for:', shareCode, '- showing zero values');
            }

            console.log('[DISPLAY] Using entry price as fallback for', shareCode, ':', displayLivePrice, 'with change:', displayPriceChange, {
                entryPrice: share.entryPrice,
                lastFetchedPrice: share.lastFetchedPrice,
                previousFetchedPrice: share.previousFetchedPrice,
                hasPriceHistory: !!(share.lastFetchedPrice && share.previousFetchedPrice)
            });
        } else {
            displayLivePrice = 'N/A';
        }
    }

    // Apply movement background classes consistently
    try {
        let changeVal = null;
        if (livePriceData) {
            if (livePriceData.live != null && livePriceData.prevClose != null && !isNaN(livePriceData.live) && !isNaN(livePriceData.prevClose)) {
                changeVal = livePriceData.live - livePriceData.prevClose;
            } else if (livePriceData.lastLivePrice != null && livePriceData.lastPrevClose != null && !isNaN(livePriceData.lastLivePrice) && !isNaN(livePriceData.lastPrevClose)) {
                changeVal = livePriceData.lastLivePrice - livePriceData.lastPrevClose;
            }
        }
        row.classList.remove('positive-change-row','negative-change-row','neutral-change-row','entry-price-change-row');
    // Ensure unified side border helper present
    if (!row.classList.contains('movement-sides')) row.classList.add('movement-sides');
        if (changeVal > 0) row.classList.add('positive-change-row');
        else if (changeVal < 0) row.classList.add('negative-change-row');
        else if (priceClass === 'entry-price') row.classList.add('entry-price-change-row');
        else row.classList.add('neutral-change-row');
    } catch(_) {}

    // Set display for new shares without live pricing
    if (isNewShare) {
        // If we have entry price data, show it immediately instead of loading
        if (share.entryPrice && !isNaN(Number(share.entryPrice))) {
            displayLivePrice = formatMoney(Number(share.entryPrice));

            // Try to show meaningful price change information for new shares
            let priceChangeCalculated = false;

            // First priority: Use the share's stored price history (most reliable for new shares)
            if (share.lastFetchedPrice && share.previousFetchedPrice &&
                !isNaN(Number(share.lastFetchedPrice)) && !isNaN(Number(share.previousFetchedPrice)) &&
                Number(share.lastFetchedPrice) !== Number(share.previousFetchedPrice)) {
                // Use the share's own price history for change calculation
                let change = Number(share.lastFetchedPrice) - Number(share.previousFetchedPrice);
                let percentageChange = (Number(share.previousFetchedPrice) !== 0 ?
                    (change / Number(share.previousFetchedPrice)) * 100 : 0);

                // Use full change values (removed legacy 50% reduction)

                displayPriceChange = formatDailyChange(change, percentageChange);
                priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                cardPriceChangeClass = change > 0 ? 'positive-change-card' : (change < 0 ? 'negative-change-card' : 'neutral-change-card');
                priceChangeCalculated = true;

                console.log('[DISPLAY] New share using stored price history for day change:', shareCode, 'change:', change, 'pct:', percentageChange);
            }

            // Second priority: Use live price data if stored data isn't available
            if (!priceChangeCalculated && livePrices && livePrices[shareCode]) {
                const liveData = livePrices[shareCode];
                if (liveData.live !== null && liveData.prevClose !== null &&
                    !isNaN(liveData.live) && !isNaN(liveData.prevClose) &&
                    liveData.live !== liveData.prevClose) {
                    let change = liveData.live - liveData.prevClose;
                    let percentageChange = (liveData.prevClose !== 0 ? (change / liveData.prevClose) * 100 : 0);

                    // Use full change values (removed legacy 50% reduction)

                    displayPriceChange = formatDailyChange(change, percentageChange);
                    priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                    cardPriceChangeClass = change > 0 ? 'positive-change-card' : (change < 0 ? 'negative-change-card' : 'neutral-change-card');
                    priceChangeCalculated = true;

                    console.log('[DISPLAY] New share using live price data for day change:', shareCode, 'change:', change, 'pct:', percentageChange);
                }
            }

            // If still no price change data available, show zero values
            if (!priceChangeCalculated) {
                displayPriceChange = '0.00 (0.00%)';
                priceClass = 'neutral';
                cardPriceChangeClass = '';
                console.log('[DISPLAY] New share no price change data available for:', shareCode, '- showing zero values');
            }

            console.log('[DISPLAY] New share with entry price:', shareCode, '- showing entry price immediately with change:', displayPriceChange, {
                entryPrice: share.entryPrice,
                lastFetchedPrice: share.lastFetchedPrice,
                previousFetchedPrice: share.previousFetchedPrice,
                hasPriceHistory: !!(share.lastFetchedPrice && share.previousFetchedPrice)
            });
        } else {
            displayLivePrice = 'Loading...';
            isNewShareIndicator = 'new-share';
            console.log('[DISPLAY] New share detected:', shareCode, '- showing loading indicator');
        }
    }

    return {
        displayLivePrice,
        displayPriceChange,
        priceClass,
        cardPriceChangeClass,
        peRatio,
        high52Week,
        low52Week,
        isNewShareIndicator
    };
}
// --- UI State Management Functions ---

// Accordion (Share Form) Initialization
function initShareFormAccordion(force = false) {
    const root = document.getElementById('shareFormAccordion');
    if (!root) return;
    // If already initialized and not forced, but the handler was removed (e.g., element replaced), allow rebind
    if (root.dataset.accordionInit && !force && root._accordionClickHandler) return; // idempotent guard
    const sections = root.querySelectorAll('.accordion-section');
    sections.forEach(sec => {
        const isCore = sec.getAttribute('data-section') === 'core';
        if (isCore) sec.classList.add('open'); else sec.classList.remove('open');
        const toggleBtn = sec.querySelector('.accordion-toggle');
        if (toggleBtn) toggleBtn.setAttribute('aria-expanded', String(isCore));
    });
    // Event delegation for reliability
    // Remove any previous handler if present to avoid duplicate bindings when the DOM is re-rendered
    try {
        if (root._accordionClickHandler) root.removeEventListener('click', root._accordionClickHandler);
    } catch(_) {}

    const accordionClickHandler = function(e) {
        const header = e.target.closest('.accordion-toggle');
        if (!header || !root.contains(header)) return;
        e.preventDefault();
        const section = header.closest('.accordion-section');
        if (!section) return;
        toggleAccordionSection(section);
    };
    root.addEventListener('click', accordionClickHandler);
    // Store the handler reference so future inits can remove it if needed
    try { root._accordionClickHandler = accordionClickHandler; } catch(_) {}
    root.dataset.accordionInit = 'true';
}

// Watchlist pulse guidance
function updateWatchlistPulse(isNewShareContext = false) {
    if (!shareWatchlistDropdownBtn || !shareWatchlistSelect) return;
    const selected = Array.from(shareWatchlistCheckboxes?.querySelectorAll('input[type="checkbox"]:checked') || []).length > 0 || (shareWatchlistSelect.value && shareWatchlistSelect.value !== '');
    if (isNewShareContext && !selected) {
        shareWatchlistDropdownBtn.classList.add('watchlist-pulse');
    } else {
        shareWatchlistDropdownBtn.classList.remove('watchlist-pulse');
    }
}


// Function to setup automatic Portfolio watchlist selection
function setupPortfolioAutoSelection() {
    const portfolioSharesInput = document.getElementById('portfolioShares');
    const portfolioAvgPriceInput = document.getElementById('portfolioAvgPrice');

    if (!portfolioSharesInput || !portfolioAvgPriceInput) {
        console.warn('Portfolio auto-selection: Required input fields not found');
        return;
    }

    function autoSelectPortfolioWatchlist() {
        console.log('autoSelectPortfolioWatchlist called');

        // Check if either input has a value
        const hasSharesValue = portfolioSharesInput.value && portfolioSharesInput.value.trim() !== '';
        const hasPriceValue = portfolioAvgPriceInput.value && portfolioAvgPriceInput.value.trim() !== '';

        console.log('hasSharesValue:', hasSharesValue, 'hasPriceValue:', hasPriceValue);

        if (hasSharesValue || hasPriceValue) {
            // Try to find the Portfolio checkbox with retry logic
            let attempts = 0;
            const maxAttempts = 10;

            const tryFindCheckbox = () => {
                attempts++;
                console.log(`Attempt ${attempts} to find Portfolio checkbox`);

                const portfolioCheckbox = shareWatchlistEnhanced?.querySelector('input[type="checkbox"][value="portfolio"]');

                if (portfolioCheckbox) {
                    console.log('Portfolio checkbox found on attempt', attempts);
                    console.log('Portfolio checkbox currently checked:', portfolioCheckbox.checked);

                    if (!portfolioCheckbox.checked) {
                        console.log('Auto-selecting Portfolio watchlist');
                        portfolioCheckbox.checked = true;
                        // Dispatch change event to trigger UI updates
                        portfolioCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log('Portfolio checkbox checked and change event dispatched');
                    } else {
                        console.log('Portfolio checkbox already checked');
                    }
                } else if (attempts < maxAttempts) {
                    console.log('Portfolio checkbox not found, retrying in 50ms...');
                    setTimeout(tryFindCheckbox, 50);
                } else {
                    console.log('Portfolio checkbox not found after', maxAttempts, 'attempts');

                    // Debug: show all available checkboxes
                    if (shareWatchlistEnhanced) {
                        const allCheckboxes = shareWatchlistEnhanced.querySelectorAll('input[type="checkbox"]');
                        console.log('All available checkboxes:');
                        allCheckboxes.forEach(cb => {
                            console.log('  - Value:', cb.value, 'Checked:', cb.checked);
                        });
                    }
                }
            };

            tryFindCheckbox();
        }
    }

    // Remove any existing listeners to avoid duplicates
    portfolioSharesInput.removeEventListener('input', autoSelectPortfolioWatchlist);
    portfolioAvgPriceInput.removeEventListener('input', autoSelectPortfolioWatchlist);

    // Add input event listeners
    portfolioSharesInput.addEventListener('input', autoSelectPortfolioWatchlist);
    portfolioAvgPriceInput.addEventListener('input', autoSelectPortfolioWatchlist);

    console.log('Portfolio auto-selection setup complete');
}

// Monitor checkbox changes
document.addEventListener('change', (e) => {
    if (!shareWatchlistDropdownBtn) return;
    if (e.target && shareWatchlistCheckboxes && shareWatchlistCheckboxes.contains(e.target)) {
        updateWatchlistPulse(true); // assume add flow while editing selection
    }
});

// Remove pulse once dropdown is opened and a selection likely imminent
if (shareWatchlistDropdownBtn) {
    shareWatchlistDropdownBtn.addEventListener('click', () => {
        // Brief delay in case menu opens and user immediately picks
        setTimeout(() => updateWatchlistPulse(true), 500);
    });
}

function toggleAccordionSection(section) {
    const toggleBtn = section.querySelector('.accordion-toggle');
    if (!toggleBtn) return;
    const opening = !section.classList.contains('open');
    // If a temporary suppression is requested (e.g., during autocomplete selection on mobile),
    // do not allow passive auto-open behavior to run. Allow closing however.
    try {
        if (opening && window.__suppressShareFormAccordionOpen) return;
    } catch(_) {}
    section.classList.toggle('open');
    toggleBtn.setAttribute('aria-expanded', String(opening));
    
    // Handle scrolling adjustments for mobile and modal context
    if (opening && window.innerWidth < 650) {
        setTimeout(() => {
            try { toggleBtn.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch(e) {}
        }, 30);
    }
    
    // Additional scroll adjustment for modal context after accordion animation
    if (opening) {
        // Wait for the CSS transition to complete (350ms from .accordion-panel transition)
        setTimeout(() => {
            const modal = section.closest('.single-scroll-modal');
            if (modal) {
                // Check if the toggle button is still visible in the viewport
                const rect = toggleBtn.getBoundingClientRect();
                const modalRect = modal.getBoundingClientRect();
                
                // If toggle button is too close to the top (less than 100px from modal top)
                if (rect.top - modalRect.top < 100) {
                    modal.scrollBy({
                        top: (rect.top - modalRect.top) - 100,
                        behavior: 'smooth'
                    });
                }
                
                // If toggle button is below the visible area, scroll it into view
                if (rect.bottom > modalRect.bottom) {
                    modal.scrollBy({
                        top: rect.bottom - modalRect.bottom + 20,
                        behavior: 'smooth'
                    });
                }
            }
        }, 350); // Match the CSS transition duration
    }
}

// Initialize accordion when DOM ready; also on modal open via observer fallback
document.addEventListener('DOMContentLoaded', () => {
    initShareFormAccordion();
});

// MutationObserver safety net: if form content is replaced dynamically later
const accordionObserver = new MutationObserver(() => {
    const root = document.getElementById('shareFormAccordion');
    if (root && !root.dataset.accordionInit) initShareFormAccordion(true);
});
try { accordionObserver.observe(document.body, { childList: true, subtree: true }); } catch(e) {}

// Helper: Render unified Alert Target (Intent + Direction + Price) B/S + Arrow + $Price
function renderAlertTargetInline(share, opts = {}) {
    if (!share) return opts.emptyReturn || '';
    const priceNum = Number(share.targetPrice);
    const hasPrice = !isNaN(priceNum) && priceNum !== 0;
    // HARD GATE: Do not show anything (intent, arrow, or price) unless a valid target price is set
    if (!hasPrice) return opts.emptyReturn || '';
    const intentRaw = (share.alertIntent || share.intent || share.targetIntent || '').toString().toLowerCase();
    const intent = intentRaw === 'sell' ? 'S' : (intentRaw === 'buy' ? 'B' : '');
    const dirRaw = (share.targetDirection || share.direction || '').toString().toLowerCase();
    const isAbove = dirRaw === 'above';
    const isBelow = dirRaw === 'below';
    // Arrow direction: up for above, down for below. If user selects anomalous combination (e.g., sell above), respect direction only.
    const arrow = isAbove ? '▲' : (isBelow ? '▼' : '');
    const priceStr = '$' + priceNum.toFixed(2);
    const arrowClass = isAbove ? 'alert-target-arrow up' : (isBelow ? 'alert-target-arrow down' : 'alert-target-arrow');
    const parts = [];
    if (intent) parts.push('<span class="alert-target-intent">'+intent+'</span>');
    if (arrow) parts.push('<span class="'+arrowClass+'">'+arrow+'</span>');
    parts.push('<span class="alert-target-price">'+priceStr+'</span>');
    const core = parts.join(' ');
    if (opts.showLabel) return '<strong>Alert:</strong> ' + core;
    return core;
}

// --- Helper: Check if ASX code exists in any user watchlist ---
function isCodeInAnyWatchlist(code) {
    if (!code) return false;
    try {
        const target = code.toUpperCase();
        // Prefer authoritative in-memory list
        const shares = (typeof getAllSharesData === 'function') ? getAllSharesData() : (window.allSharesData || []);
        if (Array.isArray(shares)) {
            for (const s of shares) {
                if (s && s.shareName && s.shareName.toUpperCase() === target) return true;
            }
        }
    } catch(_) {}
    return false;
}
try { window.isCodeInAnyWatchlist = isCodeInAnyWatchlist; } catch(_) {}

// Unified click-through for research vs existing share detail
function openShareOrSearch(code) {
    if (!code) return;
    const upper = code.toUpperCase();
    try {
        const shares = (typeof getAllSharesData === 'function') ? getAllSharesData() : (window.allSharesData || []);
        const match = Array.isArray(shares) ? shares.find(s => s && s.shareName && s.shareName.toUpperCase() === upper) : null;
        if (match && match.id) {
            try { selectShare(match.id); showShareDetails(); } catch(e){ console.warn('Open share details failed', e); }
            return;
        }
    } catch(e) { /* ignore */ }
    // Fallback to search
    try { if (typeof showStockSearchModal === 'function') showStockSearchModal(upper); } catch(_) {}
}
try { window.openShareOrSearch = openShareOrSearch; } catch(_) {}

// Force open Search ASX Stocks modal with a prefilled code (always research path)
function openStockSearchForCode(code){
    if(!code) return;
    const upper = code.toUpperCase();
    try {
        if (typeof stockSearchModal !== 'undefined' && stockSearchModal) {
            showModal(stockSearchModal);
        } else if (typeof searchStockBtn !== 'undefined' && searchStockBtn && searchStockBtn.click) {
            searchStockBtn.click();
        }
    } catch(_) {}
    try {
        if (typeof asxSearchInput !== 'undefined' && asxSearchInput) {
            asxSearchInput.value = upper;
            if (typeof displayStockDetailsInSearchModal === 'function') {
                displayStockDetailsInSearchModal(upper);
            }
            try { asxSearchInput.focus(); asxSearchInput.setSelectionRange(upper.length, upper.length); } catch(_) {}
        }
    } catch(_) {}
}
try { window.openStockSearchForCode = openStockSearchForCode; } catch(_) {}

// --- Notifications Accordion Init (Target Hit / Global) ---
function initNotificationsAccordion() {
    const root = document.getElementById('notificationsAccordion');
    if (!root || root.dataset.accordionInit) return;
    const sections = root.querySelectorAll('.accordion-section');
    sections.forEach(sec => {
        const isDefaultOpen = sec.classList.contains('open');
        const btn = sec.querySelector('.accordion-toggle');
        if (btn) btn.setAttribute('aria-expanded', String(isDefaultOpen));
    });
    root.addEventListener('click', (e) => {
        const header = e.target.closest('.accordion-toggle');
        if (!header || !root.contains(header)) return;
        e.preventDefault();
        const section = header.closest('.accordion-section');
        if (!section) return;
        const willOpen = !section.classList.contains('open');
        section.classList.toggle('open');
        header.setAttribute('aria-expanded', String(willOpen));
    });
    root.dataset.accordionInit = 'true';
}
document.addEventListener('DOMContentLoaded', () => { try { initNotificationsAccordion(); } catch(_) {} });
// Safety net: if modal content is rebuilt dynamically, re-initialize notifications accordion
try {
    const notifObserver = new MutationObserver(() => {
        const root = document.getElementById('notificationsAccordion');
        if (root && !root.dataset.accordionInit) {
            try { initNotificationsAccordion(); } catch(_) {}
        }
    });
    notifObserver.observe(document.body, { childList: true, subtree: true });
} catch(_) {}

/**
 * Adds a single share to the desktop table view.
 * @param {object} share The share object to add.
 */
function addShareToTable(share) {
    if (share.shareName && share.shareName.toUpperCase() === 'S32') {
        const avgPrice = share.portfolioAvgPrice !== null && share.portfolioAvgPrice !== undefined && !isNaN(Number(share.portfolioAvgPrice)) ? Number(share.portfolioAvgPrice) : null;
        let priceNow = null;
        const lpObj = livePrices ? livePrices[share.shareName.toUpperCase()] : undefined;
        const marketOpen = typeof isAsxMarketOpen === 'function' ? isAsxMarketOpen() : true;
        if (lpObj) {
            if (marketOpen && lpObj.live !== null && !isNaN(lpObj.live)) priceNow = Number(lpObj.live);
            else if (!marketOpen && lpObj.lastLivePrice !== null && !isNaN(lpObj.lastLivePrice)) priceNow = Number(lpObj.lastLivePrice);
        }
        if (priceNow === null || isNaN(priceNow)) {
            if (share.currentPrice !== null && share.currentPrice !== undefined && !isNaN(Number(share.currentPrice))) {
                priceNow = Number(share.currentPrice);
            }
        }
        const shares = (share.portfolioShares !== null && share.portfolioShares !== undefined && !isNaN(Number(share.portfolioShares))) ? Math.trunc(Number(share.portfolioShares)) : '';
        const rowPL = (typeof shares === 'number' && typeof priceNow === 'number' && typeof avgPrice === 'number') ? (priceNow - avgPrice) * shares : null;
        console.log('[DEBUG][Portfolio Table] S32', { priceNow, avgPrice, shares, rowPL, share });
    }
    if (!shareTableBody) {
        console.error('addShareToTable: shareTableBody element not found.');
        return;
    }

    const row = document.createElement('tr');
    row.dataset.docId = share.id;

    // Add click listener to open share details modal
    row.addEventListener('click', () => {
        logDebug('Table Row Click: Share ID: ' + share.id);
        selectShare(share.id);
        // If this row is inside the Target Price Alerts modal, set the restoration flag
        if (row.closest('#targetHitSharesList')) {
            wasShareDetailOpenedFromTargetAlerts = true;
        }
        showShareDetails();
    });

    // Check if target price is hit for this share
    const livePriceData = livePrices[share.shareName.toUpperCase()];
    const isTargetHit = livePriceData ? livePriceData.targetHit : false;

    // No border styling; we'll render a pulsing dot next to the code instead

    // Use the new helper function to get all display data
    const displayData = getShareDisplayData(share);

    // AGGRESSIVE FIX: Get company name from ASX codes for display in table
    const companyInfo = allAsxCodes.find(c => c.code === share.shareName.toUpperCase());
    const companyName = companyInfo ? companyInfo.name : '';

    let desktopTargetDot = '';
    if (isTargetHit && !targetHitIconDismissed) {
        const lp = livePrices[share.shareName.toUpperCase()] || {};
        const marketOpen = typeof isAsxMarketOpen === 'function' ? isAsxMarketOpen() : true;
        let d = null;
        if (marketOpen && lp.live != null && lp.prevClose != null && !isNaN(lp.live) && !isNaN(lp.prevClose)) d = lp.live - lp.prevClose;
        else if (!marketOpen && lp.lastLivePrice != null && lp.lastPrevClose != null && !isNaN(lp.lastLivePrice) && !isNaN(lp.lastPrevClose)) d = lp.lastLivePrice - lp.lastPrevClose;
        const color = typeof d === 'number' ? (d>0 ? 'var(--brand-green)' : (d<0 ? 'var(--brand-red)' : 'var(--accent-color)')) : 'var(--accent-color)';
        desktopTargetDot = `<span class="target-hit-dot" aria-label="Alert target hit" style="background:${color}"></span>`;
    }
    row.innerHTML = `
        <td>
            <span class="share-code-display ${displayData.priceClass}">${share.shareName || ''}</span>${desktopTargetDot}
            ${companyName ? `<br><small class=\"company-name-small\">${companyName}</small>` : ''}
        </td>
        <td class="live-price-cell">
            <span class="live-price-value ${displayData.priceClass} ${displayData.isNewShareIndicator || ''}">${displayData.displayLivePrice}</span>
            <span class="price-change ${displayData.priceClass}">${displayData.displayPriceChange}</span>
        </td>
        <td class="numeric-data-cell alert-target-cell">${renderAlertTargetInline(share)}</td>
        <td class="star-rating-cell numeric-data-cell">
            ${share.starRating > 0 ? '⭐'.repeat(share.starRating) : ''}
        </td>
        <td class="numeric-data-cell">
            ${
                (() => {
                    const dividendAmount = Number(share.dividendAmount) || 0;
                    const frankingCredits = Math.trunc(Number(share.frankingCredits) || 0);
                    const enteredPrice = Number(share.currentPrice) || 0;
                    const priceForYield = (displayData.displayLivePrice !== 'N/A' && displayData.displayLivePrice.startsWith('$'))
                                        ? parseFloat(displayData.displayLivePrice.substring(1))
                                        : (enteredPrice > 0 ? enteredPrice : 0);
                    if (priceForYield === 0 || (dividendAmount === 0 && frankingCredits === 0)) return '';
                    const frankedYield = calculateFrankedYield(dividendAmount, priceForYield, frankingCredits);
                    const unfrankedYield = calculateUnfrankedYield(dividendAmount, priceForYield);
                    if (frankingCredits > 0 && frankedYield > 0) {
                        return formatAdaptivePercent(frankedYield) + '% (F)';
                    } else if (unfrankedYield > 0) {
                        return formatAdaptivePercent(unfrankedYield) + '% (U)';
                    }
                    return '';
                })()
            }
        </td>
    `;

    // Apply movement class (positive/negative/neutral)
    try {
        const lp = livePrices[share.shareName.toUpperCase()];
        let change = null;
        if (lp && lp.live != null && lp.prevClose != null && !isNaN(lp.live) && !isNaN(lp.prevClose)) change = lp.live - lp.prevClose;
        row.classList.remove('positive-change-row','negative-change-row','neutral-change-row','entry-price-change-row');
    if (!row.classList.contains('movement-sides')) row.classList.add('movement-sides');
        if (change > 0) row.classList.add('positive-change-row');
        else if (change < 0) row.classList.add('negative-change-row');
        else if (!lp && share.entryPrice && !isNaN(Number(share.entryPrice))) row.classList.add('entry-price-change-row');
        else row.classList.add('neutral-change-row');
    } catch(_) {}

    // Add long press / context menu for desktop
    let touchStartTime = 0;
    row.addEventListener('touchstart', (e) => {
        // Mobile long-hold disabled intentionally: do nothing special
        touchStartTime = Date.now();
        selectedElementForTap = row;
    }, { passive: true });

    row.addEventListener('touchmove', (e) => {
        const currentX = e.touches[0].clientX;
        const currentY = e.touches[0].clientY;
        const dist = Math.sqrt(Math.pow(currentX - touchStartX, 2) + Math.pow(currentY - touchStartY, 2));
        if (dist > TOUCH_MOVE_THRESHOLD) {
            clearTimeout(longPressTimer);
            touchStartTime = 0; // Reset
        }
    });

    row.addEventListener('touchend', () => {
        clearTimeout(longPressTimer);
        if (Date.now() - touchStartTime < LONG_PRESS_THRESHOLD && selectedElementForTap === row) {
            // This is a short tap, let the click event handler fire naturally if it hasn't been prevented.
            // No explicit click() call needed here as a short tap naturally dispatches click.
        }
        touchStartTime = 0;
        selectedElementForTap = null;
    });
    // Right-click / Context menu for desktop
    row.addEventListener('contextmenu', (e) => {
        if (window.innerWidth > 768) { // Only enable on desktop
            e.preventDefault();
            selectShare(share.id);
            showContextMenu(e, share.id);
        }
    });

    shareTableBody.appendChild(row);
    logDebug('Table: Added share ' + share.shareName + ' to table.');
}

function addShareToMobileCards(share) {
    const container = getMobileShareCardsContainer();
    if (!container) {
        console.error('addShareToMobileCards: mobileShareCardsContainer element not found.');
        return;
    }

    const template = document.getElementById('mobile-share-card-template');
    if (!template) {
        console.error('addShareToMobileCards: mobile-share-card-template not found.');
        return;
    }

    const card = template.content.cloneNode(true).querySelector('.mobile-card');
    card.dataset.docId = share.id;

    // Get display data
    const displayData = getShareDisplayData(share);
    const { displayLivePrice, displayPriceChange, priceClass, peRatio, high52Week, low52Week } = displayData;

    // Check if target price is hit for this share
    const livePriceData = livePrices[share.shareName.toUpperCase()];
    const isTargetHit = livePriceData ? livePriceData.targetHit : false;

    // Apply card-specific price change class
    if (displayData.cardPriceChangeClass) {
        card.classList.add(displayData.cardPriceChangeClass);
    }

    // Build code with optional colored pulsing dot next to the code (replaces old border-based alert)
    let codeWithDotForAdd = `${share.shareName || ''}`;
    if (isTargetHit && !targetHitIconDismissed) {
        try {
            const lp = livePrices[share.shareName.toUpperCase()] || {};
            const marketOpen = typeof isAsxMarketOpen === 'function' ? isAsxMarketOpen() : true;
            let d = null;
            if (marketOpen && lp.live != null && lp.prevClose != null && !isNaN(lp.live) && !isNaN(lp.prevClose)) d = lp.live - lp.prevClose;
            else if (!marketOpen && lp.lastLivePrice != null && lp.lastPrevClose != null && !isNaN(lp.lastLivePrice) && !isNaN(lp.lastPrevClose)) d = lp.lastLivePrice - lp.lastPrevClose;
            const color = (typeof d === 'number') ? (d > 0 ? 'var(--brand-green)' : (d < 0 ? 'var(--brand-red)' : 'var(--accent-color)')) : 'var(--accent-color)';
            codeWithDotForAdd = `${share.shareName || ''}<span class="target-hit-dot" aria-label="Alert target hit" style="background:${color}"></span>`;
        } catch(_) { /* fall back to plain code */ }
    }
    // Ensure unified side border helper
    if (!card.classList.contains('movement-sides')) card.classList.add('movement-sides');

    // Build directional arrow for displayPriceChange
    let arrowSymbol = '';
    if (priceClass === 'positive') {
        arrowSymbol = '▲';
    } else if (priceClass === 'negative') {
        arrowSymbol = '▼';
    }

    // Populate the template
    // Insert the code (with dot if applicable)
    const codeElAdd = card.querySelector('.card-code');
    if (codeElAdd) codeElAdd.innerHTML = codeWithDotForAdd;
    card.querySelector('.card-chevron').textContent = arrowSymbol;
    card.querySelector('.card-chevron').className = `change-chevron card-chevron ${priceClass}`;
    const livePriceElement = card.querySelector('.card-live-price');
    livePriceElement.textContent = displayLivePrice;
    livePriceElement.className = `card-live-price ${displayData.isNewShareIndicator || ''}`;
    card.querySelector('.card-price-change').textContent = displayPriceChange;
    card.querySelector('.card-price-change').className = `price-change-large card-price-change ${priceClass}`;
    // Removed 52-week and P/E ratio elements for compact design

    // Handle conditional alert target
    const alertTargetRow = card.querySelector('[data-template-conditional="alertTarget"]');
    const alertTargetValue = renderAlertTargetInline(share);
    if (alertTargetValue) {
        alertTargetRow.querySelector('.data-value').innerHTML = alertTargetValue;
        alertTargetRow.style.display = '';
    } else {
        alertTargetRow.style.display = 'none';
    }

    // Handle bottom info row: raw comment title (left) and star symbols (right)
    const bottomInfoRow = card.querySelector('.bottom-info-row');
    if (bottomInfoRow) {
        const commentsTitleSpan = bottomInfoRow.querySelector('.comments-title');
        const starRatingSpan = bottomInfoRow.querySelector('.star-rating');

        // Determine compact state for mobile container; if compact we must not inject comments or stars
        const mobileContainerRef = getMobileShareCardsContainer();
        const isCompact = (mobileContainerRef && mobileContainerRef.classList && mobileContainerRef.classList.contains('compact-view')) || currentMobileViewMode === 'compact';

        // Clear existing content
        if (commentsTitleSpan) commentsTitleSpan.textContent = '';
        if (starRatingSpan) starRatingSpan.textContent = '';

        if (isCompact) {
            // Never show comments or star rating in compact mode
            if (commentsTitleSpan) commentsTitleSpan.style.display = 'none';
            if (starRatingSpan) starRatingSpan.style.display = 'none';
            bottomInfoRow.style.display = 'none';
        } else {
            // Display raw comment title on the left (only if comments exist)
            if (share.comments && Array.isArray(share.comments) && share.comments.length > 0) {
                const firstComment = share.comments[0];
                if (firstComment && firstComment.title && firstComment.title.trim()) {
                    if (commentsTitleSpan) {
                        commentsTitleSpan.textContent = firstComment.title.trim();
                        commentsTitleSpan.style.display = '';
                    }
                }
            }

            // Display star symbols on the right (only if rating > 0)
            if (share.starRating && share.starRating > 0) {
                if (starRatingSpan) {
                    starRatingSpan.textContent = '⭐'.repeat(share.starRating);
                    starRatingSpan.style.display = '';
                }
            }

            // Show bottom row only if there's content to display
            if ((commentsTitleSpan && commentsTitleSpan.textContent) || (starRatingSpan && starRatingSpan.textContent)) {
                bottomInfoRow.style.display = '';
            } else {
                bottomInfoRow.style.display = 'none';
            }
        }
    }


    card.addEventListener('click', () => {
        logDebug('Mobile Card Click: Share ID: ' + share.id);
        selectShare(share.id);
        showShareDetails();
    });

    // Add long press / context menu for mobile
    let touchStartTime = 0;
    card.addEventListener('touchstart', () => {
        // Long-hold disabled
        touchStartTime = Date.now();
        selectedElementForTap = card;
    }, { passive: true });

    card.addEventListener('touchmove', (e) => {
        const currentX = e.touches[0].clientX;
        const currentY = e.touches[0].clientY;
        const dist = Math.sqrt(Math.pow(currentX - touchStartX, 2) + Math.pow(currentY - touchStartY, 2));
        if (dist > TOUCH_MOVE_THRESHOLD) {
            clearTimeout(longPressTimer);
            touchStartTime = 0; // Reset
        }
    });

    card.addEventListener('touchend', () => {
        clearTimeout(longPressTimer);
        if (Date.now() - touchStartTime < LONG_PRESS_THRESHOLD && selectedElementForTap === card) {
            // This is a short tap, let the click event handler fire naturally if it hasn't been prevented.
        }
        touchStartTime = 0;
        selectedElementForTap = null;
    });

    const mobileContainer = getMobileShareCardsContainer();
    if (mobileContainer) {
        mobileContainer.appendChild(card);
    }
    logDebug('Mobile Cards: Added share ' + share.shareName + ' to mobile cards using template.');
}
/**
 * Updates an existing share row in the table or creates a new one if it doesn't exist.
 * @param {object} share The share object.
 */
function updateOrCreateShareTableRow(share) {
    if (!shareTableBody) {
        console.error('updateOrCreateShareTableRow: shareTableBody element not found.');
        return;
    }

    let row = shareTableBody.querySelector(`tr[data-doc-id="${share.id}"]`);

    if (!row) {
        row = document.createElement('tr');
        row.dataset.docId = share.id;
        // Add event listeners only once when the row is created
        row.addEventListener('click', () => {
            logDebug('Table Row Click: Share ID: ' + share.id);
            selectShare(share.id);
            showShareDetails();
        });

        let touchStartTime = 0;
        row.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            selectedElementForTap = row;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;

            longPressTimer = setTimeout(() => {
                if (Date.now() - touchStartTime >= LONG_PRESS_THRESHOLD) {
                    selectShare(share.id);
                    showContextMenu(e, share.id);
                    e.preventDefault();
                }
            }, LONG_PRESS_THRESHOLD);
        }, { passive: false });

        row.addEventListener('touchmove', (e) => {
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            const dist = Math.sqrt(Math.pow(currentX - touchStartX, 2) + Math.pow(currentY - touchStartY, 2));
            if (dist > TOUCH_MOVE_THRESHOLD) {
                clearTimeout(longPressTimer);
                touchStartTime = 0;
            }
        });

        row.addEventListener('touchend', () => {
            clearTimeout(longPressTimer);
            if (Date.now() - touchStartTime < LONG_PRESS_THRESHOLD && selectedElementForTap === row) {
                // Short tap handled by click event
            }
            touchStartTime = 0;
            selectedElementForTap = null;
        });

        row.addEventListener('contextmenu', (e) => {
            if (window.innerWidth > 768) {
                e.preventDefault();
                selectShare(share.id);
                showContextMenu(e, share.id);
            }
        });

        shareTableBody.appendChild(row); // Append new rows at the end, sorting will reorder virtually
        logDebug('Table: Created new row for share ' + share.shareName + '.');
    }

    // Always update the content and classes for existing (or newly created) rows
    const livePriceData = livePrices[share.shareName.toUpperCase()];
    const isTargetHit = livePriceData ? livePriceData.targetHit : false;

    const isMarketOpen = isAsxMarketOpen();
    let displayLivePrice = 'N/A';
    let displayPriceChange = '';
    let priceClass = '';

    if (livePriceData) {
        const currentLivePrice = livePriceData.live;
        const previousClosePrice = livePriceData.prevClose;
        const lastFetchedLive = livePriceData.lastLivePrice;
        const lastFetchedPrevClose = livePriceData.lastPrevClose;

    if (isMarketOpen) {
            if (currentLivePrice !== null && !isNaN(currentLivePrice)) {
                displayLivePrice = '$' + formatAdaptivePrice(currentLivePrice);
            }
            if (currentLivePrice !== null && previousClosePrice !== null && !isNaN(currentLivePrice) && !isNaN(previousClosePrice)) {
                const change = currentLivePrice - previousClosePrice;
                const percentageChange = (previousClosePrice !== 0 ? (change / previousClosePrice) * 100 : 0);
                displayPriceChange = formatDailyChange(change, percentageChange);
                priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
            } else if (lastFetchedLive !== null && lastFetchedPrevClose !== null && !isNaN(lastFetchedLive) && !isNaN(lastFetchedPrevClose)) {
                const change = lastFetchedLive - lastFetchedPrevClose;
                const percentageChange = (lastFetchedPrevClose !== 0 ? (change / lastFetchedPrevClose) * 100 : 0);
                displayPriceChange = formatDailyChange(change, percentageChange);
                priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
            }
        } else {
            displayLivePrice = lastFetchedLive !== null && !isNaN(lastFetchedLive) ? '$' + formatAdaptivePrice(lastFetchedLive) : 'N/A';
            displayPriceChange = '0.00 (0.00%)';
            priceClass = 'neutral';
        }
    }

    const dividendAmount = Number(share.dividendAmount) || 0;
    const frankingCredits = Math.trunc(Number(share.frankingCredits) || 0);
    const enteredPrice = Number(share.currentPrice) || 0;
    const priceForYield = (displayLivePrice !== 'N/A' && displayLivePrice.startsWith('$'))
                            ? parseFloat(displayLivePrice.substring(1))
                            : (enteredPrice > 0 ? enteredPrice : 0);

    const yieldDisplay = (() => {
        // If price for yield is 0, or if both dividend and franking are 0, return empty string
        if (priceForYield === 0 || (dividendAmount === 0 && frankingCredits === 0)) return '';
        const frankedYield = calculateFrankedYield(dividendAmount, priceForYield, frankingCredits);
        const unfrankedYield = calculateUnfrankedYield(dividendAmount, priceForYield);
        if (frankingCredits > 0 && frankedYield > 0) {
            return formatAdaptivePercent(frankedYield) + '% (F)';
        } else if (unfrankedYield > 0) {
            return formatAdaptivePercent(unfrankedYield) + '% (U)';
        }
        return ''; // No valid yield or yield is 0, display empty string
    })();

    const companyInfo = allAsxCodes.find(c => c.code === share.shareName.toUpperCase());
    const companyName = companyInfo ? companyInfo.name : '';

    // Build optional colored pulsing dot (next to code) for target hits
    let desktopTargetDot2 = '';
    if (isTargetHit && !targetHitIconDismissed) {
        try {
            const lp = livePrices[share.shareName.toUpperCase()] || {};
            const marketOpen = typeof isAsxMarketOpen === 'function' ? isAsxMarketOpen() : true;
            let d = null;
            if (marketOpen && lp.live != null && lp.prevClose != null && !isNaN(lp.live) && !isNaN(lp.prevClose)) d = lp.live - lp.prevClose;
            else if (!marketOpen && lp.lastLivePrice != null && lp.lastPrevClose != null && !isNaN(lp.lastLivePrice) && !isNaN(lp.lastPrevClose)) d = lp.lastLivePrice - lp.lastPrevClose;
            const color = (typeof d === 'number') ? (d > 0 ? 'var(--brand-green)' : (d < 0 ? 'var(--brand-red)' : 'var(--accent-color)')) : 'var(--accent-color)';
            desktopTargetDot2 = `<span class="target-hit-dot" aria-label="Alert target hit" style="background:${color}"></span>`;
        } catch(_) { desktopTargetDot2 = '<span class="target-hit-dot" aria-label="Alert target hit"></span>'; }
    }
    row.innerHTML = `
        <td>
            <span class="share-code-display ${priceClass}">${share.shareName || ''}</span>${desktopTargetDot2}
            ${companyName ? `<br><small class=\"company-name-small\">${companyName}</small>` : ''}
        </td>
        <td class="live-price-cell">
            <span class="live-price-value ${priceClass}">${displayLivePrice}</span>
            <span class="price-change ${priceClass}">${displayPriceChange}</span>
        </td>
    <td class="numeric-data-cell">${formatMoney(Number(share.targetPrice), { hideZero: true })}</td>
    <td class="numeric-data-cell">${formatMoney(Number(share.currentPrice), { hideZero: true })}</td>
        <td class="star-rating-cell numeric-data-cell">
            ${share.starRating > 0 ? '⭐'.repeat(share.starRating) : ''}
        </td>
        <td class="numeric-data-cell">${yieldDisplay}</td>
    `;

    logDebug('Table: Updated/Created row for share ' + share.shareName + '.');
}

/**
 * Updates an existing share card or creates a new one if it doesn't exist.
 * @param {object} share The share object.
 */
function updateOrCreateShareMobileCard(share) {
    const container = getMobileShareCardsContainer();
    if (!container) {
        console.error('updateOrCreateShareMobileCard: mobileShareCardsContainer element not found.');
        return;
    }

    let card = container.querySelector(`div[data-doc-id="${share.id}"]`);

    if (!card) {
        card = document.createElement('div');
        card.classList.add('mobile-card');
        card.dataset.docId = share.id;
        // Add event listeners only once when the card is created
        card.addEventListener('click', () => {
            logDebug('Mobile Card Click: Share ID: ' + share.id);
            selectShare(share.id);
            showShareDetails();
        });

    // Mobile long-press disabled: we intentionally do NOT attach context-menu touch handlers.
    // Simple tap already handled by click listener above; no-op touch listeners keep scroll smooth.
    card.addEventListener('touchstart', () => { selectedElementForTap = card; }, { passive: true });
    card.addEventListener('touchend', () => { selectedElementForTap = null; }, { passive: true });

        container.appendChild(card); // Append new cards at the end, sorting will reorder virtually
        logDebug('Mobile Cards: Created new card for share ' + share.shareName + '.');
    }

    // Always update the content and classes for existing (or newly created) cards
    const livePriceData = livePrices[share.shareName.toUpperCase()];
    const isTargetHit = livePriceData ? livePriceData.targetHit : false;

    // No border-based class; we'll render a pulsing dot next to the code
    const isMarketOpen = isAsxMarketOpen();
    let displayLivePrice = 'N/A';
    let displayPriceChange = '';
    let priceClass = '';
    let cardPriceChangeClass = '';

    if (livePriceData) {
        const currentLivePrice = livePriceData.live;
        const previousClosePrice = livePriceData.prevClose;
        const lastFetchedLive = livePriceData.lastLivePrice;
        const lastFetchedPrevClose = livePriceData.lastPrevClose;

        if (isMarketOpen) {
                if (currentLivePrice !== null && !isNaN(currentLivePrice)) {
                    displayLivePrice = '$' + formatAdaptivePrice(currentLivePrice);
                }
                if (currentLivePrice !== null && previousClosePrice !== null && !isNaN(currentLivePrice) && !isNaN(previousClosePrice)) {
                    const change = currentLivePrice - previousClosePrice;
                    const percentageChange = (previousClosePrice !== 0 ? (change / previousClosePrice) * 100 : 0);
                    displayPriceChange = formatDailyChange(change, percentageChange);
                    priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                    cardPriceChangeClass = change > 0 ? 'positive-change-card' : (change < 0 ? 'negative-change-card' : 'neutral-change-card');
                } else if (lastFetchedLive !== null && lastFetchedPrevClose !== null && !isNaN(lastFetchedLive) && !isNaN(lastFetchedPrevClose)) {
                    const change = lastFetchedLive - lastFetchedPrevClose;
                    const percentageChange = (lastFetchedPrevClose !== 0 ? (change / lastFetchedPrevClose) * 100 : 0);
                    displayPriceChange = formatDailyChange(change, percentageChange);
                    priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                    cardPriceChangeClass = change > 0 ? 'positive-change-card' : (change < 0 ? 'negative-change-card' : 'neutral-change-card');
                }
            } else {
                displayLivePrice = lastFetchedLive !== null && !isNaN(lastFetchedLive) ? '$' + formatAdaptivePrice(lastFetchedLive) : 'N/A';
                if (lastFetchedLive !== null && lastFetchedPrevClose !== null && !isNaN(lastFetchedLive) && !isNaN(lastFetchedPrevClose)) {
                    const change = lastFetchedLive - lastFetchedPrevClose;
                    const percentageChange = (lastFetchedPrevClose !== 0 ? (change / lastFetchedPrevClose) * 100 : 0);
                    displayPriceChange = formatDailyChange(change, percentageChange);
                    priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                    cardPriceChangeClass = change > 0 ? 'positive-change-card' : (change < 0 ? 'negative-change-card' : 'neutral-change-card');
                } else {
                    displayPriceChange = '0.00 (0.00%)';
                    priceClass = 'neutral';
                    cardPriceChangeClass = 'neutral-change-card';
                }
            }
    }

    // Apply card-specific price change class
    // Remove previous price change classes before adding current one
    card.classList.remove('positive-change-card', 'negative-change-card', 'neutral-change-card', 'entry-price-card');
    if (cardPriceChangeClass) {
        card.classList.add(cardPriceChangeClass);
    } else if (priceClass === 'entry-price') {
        // Tag entry price cards for blue styling
        card.classList.add('entry-price-card');
    } else if (priceClass === 'neutral') {
        // Tag neutral cards for muted coffee fill styling
        card.classList.add('neutral');
    }
    // Ensure unified side border helper present
    if (!card.classList.contains('movement-sides')) card.classList.add('movement-sides');

    const dividendAmount = Number(share.dividendAmount) || 0;
    const frankingCredits = Math.trunc(Number(share.frankingCredits) || 0);
    const enteredPrice = Number(share.currentPrice) || 0;
    const priceForYield = (displayLivePrice !== 'N/A' && displayLivePrice.startsWith('$'))
                            ? parseFloat(displayLivePrice.substring(1))
                            : (enteredPrice > 0 ? enteredPrice : 0);

    const yieldDisplay = (() => {
        // If price for yield is 0, or if both dividend and franking are 0, return empty string
        if (priceForYield === 0 || (dividendAmount === 0 && frankingCredits === 0)) return '';
        const frankedYield = calculateFrankedYield(dividendAmount, priceForYield, frankingCredits);
        const unfrankedYield = calculateUnfrankedYield(dividendAmount, priceForYield);
        if (frankingCredits > 0 && frankedYield > 0) {
            return formatAdaptivePercent(frankedYield) + '% (Franked)';
        } else if (unfrankedYield > 0) {
            return formatAdaptivePercent(unfrankedYield) + '% (Unfranked)';
        }
        return ''; // No valid yield or yield is 0, display empty string
    })();


    // Look up company name for display under percentage change
    const companyInfo = allAsxCodes.find(c => c.code === share.shareName.toUpperCase());
    const companyName = companyInfo ? companyInfo.name : '';

    const arrowSymbol = priceClass === 'positive' ? '▲' : (priceClass === 'negative' ? '▼' : '');
    // Build code with optional colored pulsing dot
    let codeWithDotUpd = `${share.shareName || ''}`;
    if (isTargetHit && !targetHitIconDismissed) {
        try {
            const lp = livePrices[share.shareName.toUpperCase()] || {};
            const marketOpen = typeof isAsxMarketOpen === 'function' ? isAsxMarketOpen() : true;
            let d = null;
            if (marketOpen && lp.live != null && lp.prevClose != null && !isNaN(lp.live) && !isNaN(lp.prevClose)) d = lp.live - lp.prevClose;
            else if (!marketOpen && lp.lastLivePrice != null && lp.lastPrevClose != null && !isNaN(lp.lastLivePrice) && !isNaN(lp.lastPrevClose)) d = lp.lastLivePrice - lp.lastPrevClose;
            const color = (typeof d === 'number') ? (d > 0 ? 'var(--brand-green)' : (d < 0 ? 'var(--brand-red)' : 'var(--accent-color)')) : 'var(--accent-color)';
            codeWithDotUpd = `${share.shareName || ''}<span class="target-hit-dot" aria-label="Alert target hit" style="background:${color}"></span>`;
        } catch(_) { /* leave without dot */ }
    }
    // Markup: direct grid items without inner container to avoid unwanted box
    card.innerHTML = `
        <h3 class="neutral-code-text card-code">${codeWithDotUpd}</h3>
        <span class="change-chevron ${priceClass} card-chevron">${arrowSymbol}</span>
        <span class="live-price-large neutral-code-text card-live-price">${displayLivePrice}</span>
        <span class="price-change-large ${priceClass} card-price-change">${displayPriceChange}</span>
    <p class="data-row"><span class="label-text">Entered Price:</span><span class="data-value">${(val => (val !== null && !isNaN(val) && val !== 0) ? '$' + formatAdaptivePrice(val) : '')(Number(share.currentPrice))}</span></p>
    ${(() => { const n=Number(share.targetPrice); return (!isNaN(n)&&n!==0)? `<p class="data-row alert-target-row"><span class="label-text">Alert Target:</span><span class="data-value">${renderAlertTargetInline(share)}</span></p>` : '' })()}
        <p class="data-row"><span class="label-text">Star Rating:</span><span class="data-value">${share.starRating > 0 ? '⭐'.repeat(share.starRating) : ''}</span></p>
        <p class="data-row"><span class="label-text">Dividend Yield:</span><span class="data-value">${yieldDisplay}</span></p>
    `;

    // Re-apply selected class if it was previously selected
    if (selectedShareDocId === share.id) {
        card.classList.add('selected');
    }

    logDebug('Mobile Cards: Updated/Created card for share ' + share.shareName + '.');
}

function updateMainButtonsState(enable) {
    logDebug('UI State: Setting main buttons state to: ' + (enable ? 'ENABLED' : 'DISABLED'));
    if (newShareBtn) newShareBtn.disabled = !enable;
    if (standardCalcBtn) standardCalcBtn.disabled = !enable;
    if (dividendCalcBtn) dividendCalcBtn.disabled = !enable;
    if (exportWatchlistBtn) exportWatchlistBtn.disabled = !enable;
    if (addWatchlistBtn) addWatchlistBtn.disabled = !enable;
    if (editWatchlistBtn) {
        const selectedValue = watchlistSelect ? watchlistSelect.value : '';
        // Enable button if there's a selected watchlist and it's not ALL_SHARES or CASH_BANK
        const isAnEditableWatchlistSelected = selectedValue && selectedValue !== ALL_SHARES_ID && selectedValue !== CASH_BANK_WATCHLIST_ID;
        // Remove extra conditions and only check if an editable watchlist is selected
        editWatchlistBtn.disabled = !isAnEditableWatchlistSelected;
        logDebug('Edit Watchlist Button State: ' + (editWatchlistBtn.disabled ? 'disabled' : 'enabled') + 
                ' (selectedValue=' + selectedValue + ', isEditable=' + isAnEditableWatchlistSelected + ')');
    }
    // addShareHeaderBtn is now contextual, its disabled state is managed by updateAddHeaderButton
    if (logoutBtn) setIconDisabled(logoutBtn, !enable); 
    if (themeToggleBtn) themeToggleBtn.disabled = !enable;
    if (colorThemeSelect) colorThemeSelect.disabled = !enable;
    if (revertToDefaultThemeBtn) revertToDefaultThemeBtn.disabled = !enable;
    // sortSelect and watchlistSelect disabled state is managed by render functions
    if (refreshLivePricesBtn) refreshLivePricesBtn.disabled = !enable;
    
    // NEW: Disable/enable buttons specific to cash section
    // addCashCategoryBtn and saveCashBalancesBtn are removed from HTML/functionality is moved
    if (addCashAssetSidebarBtn) addCashAssetSidebarBtn.disabled = !enable;

    logDebug('UI State: Sort Select Disabled: ' + (sortSelect ? sortSelect.disabled : 'N/A'));
    logDebug('UI State: Watchlist Select Disabled: ' + (watchlistSelect ? watchlistSelect.disabled : 'N/A'));
    updateSortIcon();
}

/**
 * Enables or disables the 'Toggle Compact View' button based on screen width.
 * This feature is only intended for mobile views (<= 768px).
 */
function updateCompactViewButtonState() {
    const button = getToggleCompactViewBtn();
    if (!button) {
        return; // Exit if the button doesn't exist
    }
    // Always enable the button, regardless of screen width
    button.disabled = false;
    const isCompact = currentMobileViewMode === 'compact';
    button.title = isCompact ? 'Switch to Default View' : 'Switch to Compact View';
    // If button has data-label span or similar, update text without blowing away icon
    try {
        const labelSpan = button.querySelector('span') || button;
        if (labelSpan) labelSpan.textContent = isCompact ? 'Default View' : 'Compact View';
    } catch(_) {}
    logDebug('UI State: Compact view button enabled (mode=' + currentMobileViewMode + ').');
}

function showModal(modalElement) {
    try { console.debug && console.debug('TRACE showModal called for:', modalElement && modalElement.id); } catch(_){}
    // Prefer UI module if available
    if (window.UI && typeof window.UI.showModal === 'function') return window.UI.showModal(modalElement);
    // Fallback minimal implementation
    try {
        if (!modalElement) return;
    if (typeof pushAppState === 'function') pushAppState({ modalId: modalElement.id }, '', '');
    try { pushAppStateEntry('modal', modalElement); } catch(_){}
    // Ensure any defensive "app-hidden" class (used at load-time) is removed so
    // the .modal.show rule can make the element visible. Some CSS places
    // .app-hidden after .modal.show which prevents display unless we remove it here.
    try { modalElement.classList.remove('app-hidden'); } catch(_){}
    modalElement.classList.add('show');
        modalElement.scrollTop = 0;
        var scrollableContent = modalElement.querySelector('.modal-body-scrollable');
        if (scrollableContent) scrollableContent.scrollTop = 0;
        if (modalElement.id === 'shareFormSection' && typeof initializeShareNameAutocomplete === 'function') {
            try { initializeShareNameAutocomplete(true); } catch(_) {}
        }
        if (typeof logDebug === 'function') logDebug('Modal: Showing modal: ' + modalElement.id);
    } catch (e) { console.warn('showModal fallback failed', e); }
}

// Helper: Show modal without pushing a new browser/history state (used for modal-to-modal back restore)
function showModalNoHistory(modalElement) {
    try { console.debug && console.debug('TRACE showModalNoHistory called for:', modalElement && modalElement.id); } catch(_){}
    if (window.UI && typeof window.UI.showModalNoHistory === 'function') return window.UI.showModalNoHistory(modalElement);
    try {
        if (!modalElement) return;
    // Remove initial hide marker before showing (see comment in showModal)
    try { modalElement.classList.remove('app-hidden'); } catch(_){}
    modalElement.classList.add('show');
        modalElement.scrollTop = 0;
        var scrollableContent = modalElement.querySelector('.modal-body-scrollable');
        if (scrollableContent) scrollableContent.scrollTop = 0;
        if (typeof logDebug === 'function') logDebug('Modal (no-history): Showing modal: ' + modalElement.id);
    } catch (e) { console.warn('showModalNoHistory fallback failed', e); }
}

function hideModal(modalElement) {
    try { console.debug && console.debug('TRACE hideModal called for:', modalElement && modalElement.id); } catch(_){}
    if (window.UI && typeof window.UI.hideModal === 'function') return window.UI.hideModal(modalElement);
    try {
        if (!modalElement) return;


    // Hide the modal and restore the initial hidden marker so that
    // styles relying on `.app-hidden` remain consistent when closed.
    modalElement.classList.remove('show');
    try { modalElement.classList.add('app-hidden'); } catch(_){}
        if (typeof logDebug === 'function') logDebug('Modal: Hiding modal: ' + modalElement.id);
    } catch (e) { console.warn('hideModal fallback failed', e); }
}

// Extracted: auto-save logic for the share form so we can call it on back as well
function autoSaveShareFormOnClose() {
    if (!(shareFormSection && shareFormSection.style.display !== 'none')) return;
    const currentData = getCurrentFormData();
    const isShareNameValid = currentData.shareName.trim() !== '';
    if (selectedShareDocId) {
        if (originalShareData && !areShareDataEqual(originalShareData, currentData)) {
            logDebug('Auto-Save: Unsaved changes detected for existing share (back). Attempting silent save.');
            saveShareData(true);
        }
    } else {
        const isWatchlistSelected = shareWatchlistSelect && shareWatchlistSelect.value !== '';
        if (isShareNameValid && isWatchlistSelected) {
            logDebug('Auto-Save: New share with valid fields (back). Attempting silent save.');
            saveShareData(true);
        }
    }
}

function clearWatchlistUI() {
    if (!watchlistSelect) { console.error('clearWatchlistUI: watchlistSelect element not found.'); return; }
    // Always include Portfolio as a special option
    watchlistSelect.innerHTML = '<option value="" disabled selected>Watch List</option>';
    const portfolioOption = document.createElement('option');
    portfolioOption.value = 'portfolio';
    portfolioOption.textContent = 'Portfolio';
    watchlistSelect.appendChild(portfolioOption);
    setUserWatchlists([]);
    setCurrentSelectedWatchlistIds([]);
    logDebug('UI: Watchlist UI cleared.');
}

function clearShareListUI() {
    if (!shareTableBody) { console.error('clearShareListUI: shareTableBody element not found.'); return; }
    const container = getMobileShareCardsContainer();
    if (!container) { console.error('clearShareListUI: mobileShareCardsContainer element not found.'); return; }
    shareTableBody.innerHTML = '';
    container.innerHTML = '';
    logDebug('UI: Share list UI cleared.');
}

function clearShareList() {
    clearShareListUI();
    if (asxCodeButtonsContainer) asxCodeButtonsContainer.innerHTML = '';
    deselectCurrentShare();
    logDebug('UI: Full share list cleared (UI + buttons).');
}

function selectShare(shareId) {
    logDebug('Selection: Attempting to select share with ID: ' + shareId);
    deselectCurrentShare();

    const tableRow = document.querySelector('#shareTable tbody tr[data-doc-id="' + shareId + '"]');
    const mobileCard = document.querySelector('.mobile-card[data-doc-id="' + shareId + '"]');
    const portfolioRow = document.querySelector('#portfolioSection table.portfolio-table tbody tr[data-doc-id="' + shareId + '"]');

    if (tableRow) {
        tableRow.classList.add('selected');
        logDebug('Selection: Selected table row for ID: ' + shareId);
    }
    if (mobileCard) {
        mobileCard.classList.add('selected');
        logDebug('Selection: Selected mobile card for ID: ' + shareId);
    }
    if (portfolioRow) {
        portfolioRow.classList.add('selected');
        logDebug('Selection: Selected portfolio row for ID: ' + shareId);
    }
    selectedShareDocId = shareId;
}

function deselectCurrentShare() {
    const currentlySelected = document.querySelectorAll('.share-list-section tr.selected, .mobile-card.selected, #portfolioSection tr.selected');
    currentlySelected.forEach(el => {
        el.classList.remove('selected');
    });
    selectedShareDocId = null;
    logDebug('Selection: Share deselected. selectedShareDocId is now null.');
}

// NEW: Select/Deselect for Cash Assets (3.1)
function selectCashAsset(assetId) {
    logDebug('Selection: Attempting to select cash asset with ID: ' + assetId);
    deselectCurrentCashAsset();

    const assetCard = document.querySelector('.cash-category-item[data-id="' + assetId + '"]');
    if (assetCard) {
        assetCard.classList.add('selected');
        logDebug('Selection: Selected cash asset card for ID: ' + assetId);
    }
    selectedCashAssetDocId = assetId;
}

function deselectCurrentCashAsset() {
    const currentlySelected = document.querySelectorAll('.cash-category-item.selected');
    logDebug('Selection: Attempting to deselect ' + currentlySelected.length + ' cash asset elements.');
    currentlySelected.forEach(el => {
        el.classList.remove('selected');
    });
    selectedCashAssetDocId = null;
    logDebug('Selection: Cash asset deselected. selectedCashAssetDocId is now null.');
}


function addCommentSection(container, title = '', text = '', isCashAssetComment = false) {
    if (!container) { console.error('addCommentSection: comments container not found.'); return; }
    const commentSectionDiv = document.createElement('div');
    commentSectionDiv.className = 'comment-section';
    commentSectionDiv.innerHTML = `
        <div class="comment-section-header">
            <input type="text" class="comment-title-input" placeholder="Comment Title" value="">
            <button type="button" class="comment-delete-btn" title="Delete Comment"><i class="fas fa-trash-alt" aria-hidden="true"></i></button>
        </div>
        <textarea class="comment-text-input" placeholder="Your comments here..."></textarea>
    `;
    container.appendChild(commentSectionDiv);

    // Set values after creating elements to avoid HTML injection
    const titleInput = commentSectionDiv.querySelector('.comment-title-input');
    const textInput = commentSectionDiv.querySelector('.comment-text-input');

    if (titleInput) titleInput.value = title || '';
    if (textInput) textInput.value = text || '';
    
    const commentTitleInput = commentSectionDiv.querySelector('.comment-title-input');
    const commentTextInput = commentSectionDiv.querySelector('.comment-text-input');
    
    if (commentTitleInput) {
        commentTitleInput.addEventListener('input', isCashAssetComment ? checkCashAssetFormDirtyState : checkFormDirtyState);
    }
    if (commentTextInput) {
        commentTextInput.addEventListener('input', isCashAssetComment ? checkCashAssetFormDirtyState : checkFormDirtyState);
    }

    commentSectionDiv.querySelector('.comment-delete-btn').addEventListener('click', (event) => {
        logDebug('Comments: Delete comment button clicked.');
        event.target.closest('.comment-section').remove();
        isCashAssetComment ? checkCashAssetFormDirtyState() : checkFormDirtyState();
    });
    logDebug('Comments: Added new comment section.');
}
function clearForm() {
    formInputs.forEach(input => {
        if (input) { input.value = ''; }
    });
    // Explicitly clear portfolio fields
    const portfolioSharesInput = document.getElementById('portfolioShares');
    const portfolioAvgPriceInput = document.getElementById('portfolioAvgPrice');
    if (portfolioSharesInput) portfolioSharesInput.value = '';
    if (portfolioAvgPriceInput) portfolioAvgPriceInput.value = '';

    // Entry data is now handled by display elements, no input fields to clear
    if (commentsFormContainer) { // This now refers to #dynamicCommentsArea
        commentsFormContainer.innerHTML = ''; // Clears ONLY the dynamically added comments
    }
    formTitle.textContent = 'Add New Share'; // Reset title
    if (formCompanyName) formCompanyName.textContent = ''; // Clear company name
    // NEW: Also clear the live price display when clearing the form
    if (addShareLivePriceDisplay) {
        addShareLivePriceDisplay.style.display = 'none';
        addShareLivePriceDisplay.innerHTML = '';
    }
    // Reset auto displays in Other Details
    try {
        if (autoEntryDateDisplay) { autoEntryDateDisplay.textContent = 'Auto when saved'; autoEntryDateDisplay.classList.add('ghosted-text'); }
        if (autoReferencePriceDisplay) { autoReferencePriceDisplay.textContent = 'Auto when saved'; autoReferencePriceDisplay.classList.add('ghosted-text'); }
    } catch(_) {}
    selectedShareDocId = null;
    originalShareData = null; // IMPORTANT: Reset original data to prevent auto-save of cancelled edits
    if (deleteShareBtn) {
        deleteShareBtn.classList.add('hidden');
        logDebug('clearForm: deleteShareBtn hidden.');
    }
    // Reset shareWatchlistSelect to its default placeholder
    if (shareWatchlistSelect) {
        shareWatchlistSelect.value = ''; // Set to empty string to select the disabled option
        shareWatchlistSelect.disabled = false; // Ensure it's enabled for new share entry
    }
    setIconDisabled(saveShareBtn, true); // Save button disabled on clear
    logDebug('Form: Form fields cleared and selectedShareDocId reset. saveShareBtn disabled.');
    // Reset auto details read-only placeholders
    // Removed - old static display elements no longer exist
}

/**
 * Populates the 'Assign to Watchlist' dropdown in the share form modal.
 * Sets the default selection based on current view or existing share.
 * @param {string|null} currentShareWatchlistId The ID of the watchlist the share is currently in (for editing).
 * @param {boolean} isNewShare True if adding a new share, false if editing.
*/
function populateShareWatchlistSelect(currentShareWatchlistId = null, isNewShare = true) {
    logDebug('populateShareWatchlistSelect called. isNewShare: ' + isNewShare + ', currentShareWatchlistId: ' + currentShareWatchlistId);
    logDebug('Current currentSelectedWatchlistIds: ' + getCurrentSelectedWatchlistIds().join(', '));
    logDebug('User watchlists available: ' + userWatchlists.map(wl => wl.name + ' (' + wl.id + ')').join(', '));

    if (!shareWatchlistSelect) {
        console.error('populateShareWatchlistSelect: shareWatchlistSelect element not found.');
        return;
    }

    // Prepare native select (hidden) as multi-select for data binding; UI uses checkboxes
    try { shareWatchlistSelect.multiple = true; } catch(e) {}
    shareWatchlistSelect.innerHTML = '<option value="" disabled>Select a Watchlist</option>';

    // Always include Portfolio as a special option
    const PORTFOLIO_WATCHLIST_ID = 'portfolio';
    const PORTFOLIO_WATCHLIST_NAME = 'Portfolio';
    const portfolioOption = document.createElement('option');
    portfolioOption.value = PORTFOLIO_WATCHLIST_ID;
    portfolioOption.textContent = PORTFOLIO_WATCHLIST_NAME;
    shareWatchlistSelect.appendChild(portfolioOption);

    // Filter out the "Cash & Assets" option from the share watchlist dropdown
    const stockWatchlists = userWatchlists.filter(wl => wl.id !== CASH_BANK_WATCHLIST_ID);
    stockWatchlists.forEach(watchlist => {
        // Don't duplicate Portfolio if userWatchlists already has it
        if (watchlist.id === PORTFOLIO_WATCHLIST_ID) return;
        const option = document.createElement('option');
        option.value = watchlist.id;
        option.textContent = watchlist.name;
        shareWatchlistSelect.appendChild(option);
    });

    let preselectedIds = []; // For multi-select
    let selectedOptionId = ''; // For legacy single-select scenarios
    let disableDropdown = false; // Variable to control if dropdown should be disabled

    if (isNewShare) {
        // For new shares, always default to the blank placeholder and keep the dropdown enabled.
        selectedOptionId = ''; // Forces selection of the disabled placeholder option
        disableDropdown = false; // Always allow user to select a watchlist
        logDebug('Share Form: New share: Watchlist selector forced to blank placeholder, enabled for user selection.');
    } else { // Editing an existing share
        // If editing, prefer the share's existing watchlistIds array if present
        if (selectedShareDocId) {
            const s = allSharesData.find(w => w.id === selectedShareDocId);
            if (s && Array.isArray(s.watchlistIds) && s.watchlistIds.length) {
                preselectedIds = s.watchlistIds.slice();
            }
        }
        // Always honor 'portfolio' explicitly even if userWatchlists doesn't include it
        if (currentShareWatchlistId === 'portfolio') {
            selectedOptionId = 'portfolio';
            if (!preselectedIds.includes('portfolio')) preselectedIds.push('portfolio');
            logDebug('Share Form: Editing share: Detected portfolio watchlist, pre-selecting Portfolio.');
        } else if (currentShareWatchlistId && stockWatchlists.some(wl => wl.id === currentShareWatchlistId)) {
            selectedOptionId = currentShareWatchlistId;
            if (currentShareWatchlistId && !preselectedIds.includes(currentShareWatchlistId)) preselectedIds.push(currentShareWatchlistId);
            logDebug('Share Form: Editing share: Pre-selected to existing share\'s watchlist: ' + selectedOptionId);
        } else if (currentShareWatchlistId) {
            // If the original watchlist isn't in the filtered stock lists, inject a temporary option to preserve it
            const original = userWatchlists.find(wl => wl.id === currentShareWatchlistId);
            if (original && original.id !== CASH_BANK_WATCHLIST_ID) {
                const opt = document.createElement('option');
                opt.value = original.id;
                opt.textContent = original.name + ' (original)';
                shareWatchlistSelect.appendChild(opt);
                selectedOptionId = original.id;
                if (original.id && !preselectedIds.includes(original.id)) preselectedIds.push(original.id);
                console.warn('Share Form: Editing share: Original watchlist not in stock list; temporarily added original to dropdown.');
            } else {
                // Unknown/removed list or Cash; require explicit user choice instead of defaulting silently
                selectedOptionId = '';
                console.warn('Share Form: Editing share: Original watchlist missing or not applicable. Please select a watchlist.');
            }
        } else if (stockWatchlists.length > 0) {
            // No original ID on the share; default to current view if it's Portfolio, else leave blank
            if (Array.isArray(getCurrentSelectedWatchlistIds()) && getCurrentSelectedWatchlistIds()[0] === 'portfolio') {
                selectedOptionId = 'portfolio';
                if (!preselectedIds.includes('portfolio')) preselectedIds.push('portfolio');
                logDebug('Share Form: Editing share: No original watchlist; defaulting to current view Portfolio.');
            } else {
                selectedOptionId = '';
                logDebug('Share Form: Editing share: No original watchlist set; leaving blank for user to choose.');
            }
        } else {
            selectedOptionId = '';
            console.warn('Share Form: Editing share: No stock watchlists available to select.');
        }
        disableDropdown = false; // Always allow changing watchlist when editing
    }

    // Apply the determined selection(s) and disabled state to native select
    if (preselectedIds.length > 0) {
        Array.from(shareWatchlistSelect.options).forEach(option => {
            option.selected = preselectedIds.includes(option.value);
        });
    } else {
        shareWatchlistSelect.value = selectedOptionId;
    }
    shareWatchlistSelect.disabled = disableDropdown;

    // Explicitly set the 'selected' attribute on the option for visual update reliability
    // This loop is crucial to ensure the visual selection is correctly applied.
    Array.from(shareWatchlistSelect.options).forEach(option => {
        if (preselectedIds.length > 0) {
            option.selected = preselectedIds.includes(option.value);
        } else {
            option.selected = (option.value === selectedOptionId);
        }
    });

    // Build enhanced toggle list
    if (typeof shareWatchlistEnhanced !== 'undefined' && shareWatchlistEnhanced) {
        shareWatchlistEnhanced.innerHTML = '';
        const opts = Array.from(shareWatchlistSelect.options).filter(o => o.value !== '' && o.value !== CASH_BANK_WATCHLIST_ID);
        const selectedSet = new Set(preselectedIds.length ? preselectedIds : (selectedOptionId ? [selectedOptionId] : []));
        opts.forEach(o => {
            const item = document.createElement('div');
            item.className = 'watchlist-enhanced-item';
            const checked = selectedSet.has(o.value);
            item.innerHTML = `
                <span class="watchlist-enhanced-name">${o.textContent || o.value}</span>
                <label class="watchlist-toggle" aria-label="Toggle ${o.textContent || o.value}">
                    <input type="checkbox" value="${o.value}" ${checked ? 'checked' : ''}>
                    <span class="watchlist-toggle-track"><span class="watchlist-toggle-thumb"></span></span>
                </label>`;
            const input = item.querySelector('input');
            input.addEventListener('change', () => {
                const toggled = Array.from(shareWatchlistEnhanced.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value);
                Array.from(shareWatchlistSelect.options).forEach(opt => { opt.selected = toggled.includes(opt.value); });
                shareWatchlistSelect.value = toggled[0] || '';
                updateWatchlistDropdownButton();
                checkFormDirtyState();
            });
            shareWatchlistEnhanced.appendChild(item);
        });
    }

    // Initialize dropdown button label/state
    if (shareWatchlistDropdownBtn) {
        updateWatchlistDropdownButton();
        shareWatchlistDropdownBtn.setAttribute('aria-expanded','false');
        shareWatchlistDropdownBtn.onclick = (e) => {
            e.stopPropagation();
            if (!shareWatchlistEnhanced) return;
            const isOpen = shareWatchlistEnhanced.style.display === 'block';
            shareWatchlistEnhanced.style.display = isOpen ? 'none' : 'block';
            shareWatchlistDropdownBtn.setAttribute('aria-expanded', String(!isOpen));
        };
        document.addEventListener('click', (evt) => {
            if (!shareWatchlistEnhanced || shareWatchlistEnhanced.style.display !== 'block') return;
            const within = shareWatchlistEnhanced.contains(evt.target) || shareWatchlistDropdownBtn.contains(evt.target);
            if (!within) {
                shareWatchlistEnhanced.style.display='none';
                shareWatchlistDropdownBtn.setAttribute('aria-expanded','false');
            }
        });
    }

    // Listen for native select change too (in case of programmatic changes)
    shareWatchlistSelect.addEventListener('change', () => {
        if (!shareWatchlistEnhanced) return;
        const selected = Array.from(shareWatchlistSelect.options).filter(o => o.selected).map(o => o.value);
        shareWatchlistEnhanced.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = selected.includes(cb.value); });
        updateWatchlistDropdownButton();
        checkFormDirtyState();
    });
}

function updateWatchlistDropdownButton() {
    if (!shareWatchlistDropdownBtn) return;
    let selected = [];
    if (shareWatchlistEnhanced) {
        selected = Array.from(shareWatchlistEnhanced.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value);
    }
    if (selected.length === 0) { shareWatchlistDropdownBtn.textContent = 'Select Watchlists'; return; }
    const names = selected.map(id => {
        const opt = Array.from(shareWatchlistSelect.options).find(o => o.value === id);
        return opt ? (opt.textContent || opt.innerText || id) : id;
    });
    shareWatchlistDropdownBtn.textContent = names.length <=2 ? names.join(', ') : names.slice(0,2).join(', ') + ' +' + (names.length-2);
}

function showEditFormForSelectedShare(shareIdToEdit = null) {
    if (window.suppressShareFormReopen) {
        logDebug('Share Form: Suppression active; blocking unintended reopen.');
        return;
    }
    const targetShareId = shareIdToEdit || selectedShareDocId;

    if (!targetShareId) {
        showCustomAlert('Please select a share to edit.');
        return;
    }
    const shareToEdit = allSharesData.find(share => share.id === targetShareId);
    if (!shareToEdit) {
        showCustomAlert('Selected share not found.');
        return;
    }
    selectedShareDocId = targetShareId; 

    // Set the modal title to the share code and the subtitle to the company name
    formTitle.textContent = shareToEdit.shareName || 'N/A';
    const companyInfo = allAsxCodes.find(c => c.code === shareToEdit.shareName.toUpperCase());
    if (formCompanyName) {
        formCompanyName.textContent = companyInfo ? companyInfo.name : '';
    }

    if (shareNameInput) shareNameInput.value = shareToEdit.shareName || '';
    // Removed setting manual currentPrice input (field no longer present)
    if (targetPriceInput) targetPriceInput.value = Number(shareToEdit.targetPrice) !== null && !isNaN(Number(shareToEdit.targetPrice)) ? formatUserDecimalStrict(shareToEdit.targetPrice) : '';

    // Entry data is now handled by display elements above, no input fields to populate
    
    // Reset toggle state helpers
    userManuallyOverrodeDirection = false;
    // Set the correct state for the new target direction checkboxes
    if (targetAboveCheckbox && targetBelowCheckbox) {
        // Default to 'below' if not set
        const savedTargetDirection = shareToEdit.targetDirection || 'below';
        targetAboveCheckbox.checked = (savedTargetDirection === 'above');
        targetBelowCheckbox.checked = (savedTargetDirection === 'below');
        // Sync segmented buttons to match saved state
        try {
            const isAbove = (savedTargetDirection === 'above');
            if (targetDirAboveBtn && targetDirBelowBtn) {
                targetDirAboveBtn.classList.toggle('is-active', isAbove);
                targetDirAboveBtn.setAttribute('aria-pressed', String(isAbove));
                targetDirBelowBtn.classList.toggle('is-active', !isAbove);
                targetDirBelowBtn.setAttribute('aria-pressed', String(!isAbove));
            }
        } catch(_) {}
    }

    if (dividendAmountInput) dividendAmountInput.value = Number(shareToEdit.dividendAmount) !== null && !isNaN(Number(shareToEdit.dividendAmount)) ? formatUserDecimalStrict(shareToEdit.dividendAmount) : '';
    if (frankingCreditsInput) frankingCreditsInput.value = Number(shareToEdit.frankingCredits) !== null && !isNaN(Number(shareToEdit.frankingCredits)) ? Math.trunc(Number(shareToEdit.frankingCredits)).toString() : '';

    // Portfolio fields (optional per share)
    const portfolioSharesInput = document.getElementById('portfolioShares');
    const portfolioAvgPriceInput = document.getElementById('portfolioAvgPrice');
    if (portfolioSharesInput) {
        const v = Number(shareToEdit.portfolioShares);
        portfolioSharesInput.value = !isNaN(v) && v !== null ? String(Math.trunc(v)) : '';
    }
    if (portfolioAvgPriceInput) {
        const v = Number(shareToEdit.portfolioAvgPrice);
        portfolioAvgPriceInput.value = !isNaN(v) && v !== null ? formatUserDecimalStrict(v) : '';
    }

    // Set the star rating dropdown
    if (shareRatingSelect) {
        shareRatingSelect.value = shareToEdit.starRating !== undefined && shareToEdit.starRating !== null ? shareToEdit.starRating.toString() : '0';
    }

    // Populate and set selection for the watchlist dropdown
    populateShareWatchlistSelect(shareToEdit.watchlistId, false); // false indicates not a new share

    if (commentsFormContainer) { // This now refers to #dynamicCommentsArea
        commentsFormContainer.innerHTML = ''; // Clear existing dynamic comment sections
        if (shareToEdit.comments && Array.isArray(shareToEdit.comments) && shareToEdit.comments.length > 0) {
            shareToEdit.comments.forEach(comment => addCommentSection(commentsFormContainer, comment.title, comment.text));
        } else {
            // Add one empty comment section if no existing comments
            addCommentSection(commentsFormContainer); 
        }
    }
    if (deleteShareBtn) {
        deleteShareBtn.classList.add('hidden');
        setIconDisabled(deleteShareBtn, false);
        logDebug('showEditFormForSelectedShare: deleteShareBtn shown and enabled.');
    }

    originalShareData = getCurrentFormData();
    setIconDisabled(saveShareBtn, true); // Save button disabled initially for editing
    logDebug('showEditFormForSelectedShare: saveShareBtn initially disabled for dirty check.');
    // Populate read-only auto fields (Entry Date & Reference Price)
    try {
        if (autoEntryDateDisplay) {
            const ed = shareToEdit.entryDate ? formatDate(shareToEdit.entryDate) : '';
            if (ed) {
                autoEntryDateDisplay.textContent = ed;
                autoEntryDateDisplay.classList.remove('ghosted-text');
            } else {
                autoEntryDateDisplay.textContent = 'Auto when saved';
                autoEntryDateDisplay.classList.add('ghosted-text');
            }
        }
        if (autoReferencePriceDisplay) {
            const rp = (shareToEdit.entryPrice !== undefined && shareToEdit.entryPrice !== null && !isNaN(Number(shareToEdit.entryPrice))) ? Number(shareToEdit.entryPrice) : null;
            if (rp !== null) {
                autoReferencePriceDisplay.textContent = formatMoney(rp);
                autoReferencePriceDisplay.classList.remove('ghosted-text');
            } else {
                autoReferencePriceDisplay.textContent = 'Auto when saved';
                autoReferencePriceDisplay.classList.add('ghosted-text');
            }
        }
    } catch(e) { console.warn('Auto Details: Failed to populate auto fields', e); }

    showModal(shareFormSection);
    // Always clear accordion init flag before re-initializing (fixes edit modal bug)
    const accordion = document.getElementById('shareFormAccordion');
    if (accordion && accordion.dataset.accordionInit) {
        delete accordion.dataset.accordionInit;
    }
    setTimeout(() => initShareFormAccordion(true), 10);
    try { scrollMainToTop(); } catch(_) {}
    shareNameInput.focus();
    // Always show live price snapshot if code is present
    if (shareNameInput && shareNameInput.value.trim()) {
        updateAddFormLiveSnapshot(shareNameInput.value.trim());
    } else if (addShareLivePriceDisplay) {
        addShareLivePriceDisplay.style.display = 'none';
        addShareLivePriceDisplay.innerHTML = '';
    }
    logDebug('Form: Opened edit form for share: ' + shareToEdit.shareName + ' (ID: ' + selectedShareDocId + ')');
}

// Helper: select a share in-memory and open the edit form for it
function selectAndOpenShareForEdit(shareId) {
    try {
        if (!shareId) return;
        const found = allSharesData && allSharesData.find(s => s && s.id === shareId);
        if (!found) {
            showCustomAlert('Could not find the existing share to edit.');
            return;
        }
        selectedShareDocId = shareId;
        // ensure UI selection reflects this (some listeners read selectedShareDocId)
        try { if (typeof highlightSelectedRow === 'function') highlightSelectedRow(shareId); } catch(_) {}
        // Open the edit modal
        try { showEditFormForSelectedShare(shareId); } catch(e) { console.warn('selectAndOpenShareForEdit: showEditFormForSelectedShare failed', e); }
    } catch(e) { console.warn('selectAndOpenShareForEdit failed', e); }
}

/**
 * Gathers all current data from the share form inputs.
 * @returns {object} An object representing the current state of the form.
 */
function getCurrentFormData() {
    const comments = [];
    if (commentsFormContainer) { // This now refers to #dynamicCommentsArea
        commentsFormContainer.querySelectorAll('.comment-section').forEach(section => {
            const titleInput = section.querySelector('.comment-title-input');
            const textInput = section.querySelector('.comment-text-input');
            const title = titleInput ? titleInput.value.trim() : '';
            const text = textInput ? textInput.value.trim() : '';
            if (title || text) {
                comments.push({ title: title, text: text });
            }
        });
    }

    // Portfolio-specific fields (optional)
    const portfolioSharesEl = document.getElementById('portfolioShares');
    const portfolioAvgPriceEl = document.getElementById('portfolioAvgPrice');
    const portfolioSharesVal = portfolioSharesEl ? parseFloat(portfolioSharesEl.value) : null;
    const portfolioAvgPriceVal = portfolioAvgPriceEl ? parseFloat(portfolioAvgPriceEl.value) : null;

    return {
        shareName: shareNameInput?.value?.trim().toUpperCase() || '',
        currentPrice: null, // auto-derived on save
        targetPrice: parseFloat(targetPriceInput?.value),
        targetDirection: targetAboveCheckbox?.checked ? 'above' : 'below',
        dividendAmount: parseFloat(dividendAmountInput?.value),
        frankingCredits: parseFloat(frankingCreditsInput?.value),
        starRating: shareRatingSelect ? parseInt(shareRatingSelect.value) : 0,
        comments: comments,
        watchlistId: shareWatchlistSelect ? (shareWatchlistSelect.value || null) : null,
        watchlistIds: (() => {
            // 1. Enhanced multi-select (authoritative when present)
            try {
                if (typeof shareWatchlistEnhanced !== 'undefined' && shareWatchlistEnhanced) {
                    const enhancedVals = Array.from(shareWatchlistEnhanced.querySelectorAll('input[type="checkbox"]:checked')).map(cb=>cb.value).filter(Boolean);
                    if (enhancedVals.length) return enhancedVals;
                }
            } catch(_) {}
            // 2. Legacy checkbox container
            const legacyEls = document.querySelectorAll('#shareWatchlistCheckboxes input.watchlist-checkbox:checked');
            const legacyVals = Array.from(legacyEls).map(x => x.value).filter(Boolean);
            if (legacyVals.length) return legacyVals;
            // 3. Fallback single select
            const single = shareWatchlistSelect ? (shareWatchlistSelect.value || null) : null;
            return single ? [single] : null;
        })(),
        portfolioShares: isNaN(portfolioSharesVal) ? null : Math.trunc(portfolioSharesVal),
        portfolioAvgPrice: isNaN(portfolioAvgPriceVal) ? null : portfolioAvgPriceVal
    };
}

/**
 * Compares two share data objects (original vs. current form data) to check for equality.
 * Handles null/NaN for numbers and deep comparison for comments array.
 * @param {object} data1
 * @param {object} data2
 * @returns {boolean} True if data is identical, false otherwise.
 */
function areShareDataEqual(data1, data2) {
    if (!data1 || !data2) return false;

    const fields = ['shareName', 'currentPrice', 'targetPrice', 'targetDirection', 'dividendAmount', 'frankingCredits', 'watchlistId', 'starRating', 'portfolioShares', 'portfolioAvgPrice']; // Include portfolio fields
    for (const field of fields) {
        let val1 = data1[field];
        let val2 = data2[field];

        if (typeof val1 === 'number' && isNaN(val1)) val1 = null;
        if (typeof val2 === 'number' && isNaN(val2)) val2 = null;

        if (val1 !== val2) {
            return false;
        }
    }
    // Compare watchlistIds arrays if present (order-insensitive)
    const a = Array.isArray(data1.watchlistIds) ? [...data1.watchlistIds].sort() : null;
    const b = Array.isArray(data2.watchlistIds) ? [...data2.watchlistIds].sort() : null;
    if ((a && !b) || (!a && b)) return false;
    if (a && b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) { if (a[i] !== b[i]) return false; }
    }

    if (data1.comments.length !== data2.comments.length) {
        return false;
    }
    for (let i = 0; i < data1.comments.length; i++) {
        const comment1 = data1.comments[i];
        const comment2 = data2.comments[i];
        if (comment1.title !== comment2.title || comment1.text !== comment2.text) {
            return false;
        }
    }

    return true;
}

/**
 * Checks the current state of the form against the original data (if editing)
 * and the share name validity, then enables/disables the save button accordingly.
 */
function checkFormDirtyState() {
    const currentData = getCurrentFormData();
    const isShareNameValid = currentData.shareName.trim() !== '';
    const isWatchlistSelected = (() => {
        // 1. New enhanced multi-select (shareWatchlistEnhanced) checkboxes
        try {
            if (typeof shareWatchlistEnhanced !== 'undefined' && shareWatchlistEnhanced) {
                const enhancedChecked = shareWatchlistEnhanced.querySelectorAll('input[type="checkbox"]:checked');
                if (enhancedChecked.length > 0) return true;
            }
        } catch(_) {}
        // 2. Legacy Phase 1 checkbox UI (if still present)
        const legacyChecked = document.querySelectorAll('#shareWatchlistCheckboxes input.watchlist-checkbox:checked');
        if (legacyChecked && legacyChecked.length > 0) return true;
        // 3. Native select fallback
        if (!shareWatchlistSelect) return false;
        if (shareWatchlistSelect.multiple) {
            const anySelected = Array.from(shareWatchlistSelect.options || []).some(o => o.selected && o.value && o.value !== '');
            if (anySelected) return true;
            return !!(shareWatchlistSelect.value && shareWatchlistSelect.value !== '');
        }
        return shareWatchlistSelect.value !== '';
    })();

    let canSave = isShareNameValid;

    // For NEW shares, always require a watchlist to be explicitly selected in the dropdown.
    // This applies whether in "All Shares" view or a specific watchlist view where the dropdown defaults to blank.
    if (!selectedShareDocId) { // Only for new shares
        canSave = canSave && isWatchlistSelected;
    }

    if (selectedShareDocId && originalShareData) {
        const isDirty = !areShareDataEqual(originalShareData, currentData);
        try {
            const origW = Array.isArray(originalShareData.watchlistIds)? originalShareData.watchlistIds.join(',') : 'null';
            const currW = Array.isArray(currentData.watchlistIds)? currentData.watchlistIds.join(',') : 'null';
            logDebug(`[DirtyTrace] orig watchlists: [${origW}] vs current [${currW}] -> isDirty=${isDirty}`);
        } catch(_) {}
        canSave = canSave && isDirty;
        if (!isDirty) {
            logDebug('Dirty State: Existing share: No changes detected, save disabled.');
        }
    } else if (!selectedShareDocId) {
        // For new shares, enable if name is valid and (if from All Shares) watchlist is selected
        // No additional 'isDirty' check needed for new shares beyond initial validity
        // Note: The previous logic for new shares here was redundant with the general 'if (!selectedShareDocId)' block above.
        // Keeping this else-if structure for clarity in differentiating new vs. existing shares in logs/logic.
    }

    setIconDisabled(saveShareBtn, !canSave);
    logDebug('Dirty State: Save button enabled: ' + canSave);
}

// Ensure watchlist checkbox changes always invoke dirty-state recalculation
try {
    if (typeof shareWatchlistEnhanced !== 'undefined' && shareWatchlistEnhanced) {
        shareWatchlistEnhanced.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            if (cb.getAttribute('data-dirty-bound')==='true') return;
            cb.addEventListener('change', ()=>{
                try { checkFormDirtyState(); } catch(e) { console.warn('DirtyState: checkbox change failed', e); }
            });
            cb.setAttribute('data-dirty-bound','true');
        });
    }
} catch(e) { /* silent */ }

/**
 * Saves share data to Firestore. Can be called silently for auto-save.
 * @param {boolean} isSilent If true, no alert messages are shown on success.
 */
async function saveShareData(isSilent = false) {
    logDebug('Share Form: saveShareData called.');
    // Check if the save button would normally be disabled (no valid name or no changes)
    // This prevents saving blank new shares or unchanged existing shares on auto-save.
    if (saveShareBtn.classList.contains('is-disabled-icon') && isSilent) {
        logDebug('Auto-Save: Save button is disabled (no changes or no valid name). Skipping silent save.');
        return;
    }

    const shareName = shareNameInput.value.trim().toUpperCase();
    if (!shareName) { 
        if (!isSilent) showCustomAlert('Code is required!'); 
        console.warn('Save Share: Code is required. Skipping save.');
        return; 
    }

    // Source of truth: checkbox UI; keep hidden select for legacy fallback
    const selectedWatchlistIdForSave = shareWatchlistSelect ? (shareWatchlistSelect.value || null) : null;
    const selectedWatchlistIdsForSave = (() => {
        // Prefer enhanced toggle list
        if (typeof shareWatchlistEnhanced !== 'undefined' && shareWatchlistEnhanced) {
            const toggled = Array.from(shareWatchlistEnhanced.querySelectorAll('input[type="checkbox"]:checked')).map(x => x.value).filter(Boolean);
            if (toggled.length > 0) return toggled;
        }
        // Fallback legacy checkbox container
        const cbs = document.querySelectorAll('#shareWatchlistCheckboxes input.watchlist-checkbox:checked');
        const vals = Array.from(cbs).map(cb => cb.value).filter(Boolean);
        if (vals.length > 0) return vals;
        return selectedWatchlistIdForSave ? [selectedWatchlistIdForSave] : null;
    })();
    // For new shares from 'All Shares' view, force watchlist selection
    if (!selectedShareDocId && getCurrentSelectedWatchlistIds().includes(ALL_SHARES_ID)) {
        if (!selectedWatchlistIdForSave || selectedWatchlistIdForSave === '') { // Check for empty string too
            if (!isSilent) showCustomAlert('Please select a watchlist to assign the new share to.');
            console.warn('Save Share: New share from All Shares: Watchlist not selected. Skipping save.');
            return;
        }
    } else if (!selectedShareDocId && !selectedWatchlistIdForSave) { // New share not from All Shares, but no watchlist selected (shouldn't happen if default exists)
         if (!isSilent) showCustomAlert('Please select a watchlist to assign the new share to.');
         console.warn('Save Share: New share: No watchlist selected. Skipping save.');
         return;
    }


    // Auto-capture live or fallback current price (no manual input)
    let currentPrice = NaN;
    try {
        const liveData = livePrices[shareName.toUpperCase()];
        if (liveData && typeof liveData.live === 'number' && !isNaN(liveData.live)) {
            currentPrice = liveData.live;
        } else if (liveData && typeof liveData.lastLivePrice === 'number' && !isNaN(liveData.lastLivePrice)) {
            currentPrice = liveData.lastLivePrice;
        }
    } catch(_) {}
    const targetPrice = parseFloat(targetPriceInput.value);
    const dividendAmount = parseFloat(dividendAmountInput.value);
    const frankingCredits = parseFloat(frankingCreditsInput.value);

    const comments = [];
    if (commentsFormContainer) { // This now refers to #dynamicCommentsArea
        commentsFormContainer.querySelectorAll('.comment-section').forEach(section => {
            const titleInput = section.querySelector('.comment-title-input');
            const textInput = section.querySelector('.comment-text-input');
            const title = titleInput ? titleInput.value.trim() : '';
            const text = textInput ? textInput.value.trim() : '';
            if (title || text) {
                comments.push({ title: title, text: text });
            }
        });
    }

    // Determine the entry price value based on the modal's displayed/reference price.
    // Prefer the currentPriceInput value (this is populated by updateAddFormLiveSnapshot),
    // fall back to the auto-captured live price. Only set entryPrice for new shares to
    // preserve original entryPrice on edits.
    const _rawEnteredPrice = (currentPriceInput && typeof currentPriceInput.value === 'string') ? currentPriceInput.value.trim() : '';
    const _parsedEnteredPrice = parseFloat(_rawEnteredPrice);
    const _entryPriceCandidate = (!isNaN(_parsedEnteredPrice)) ? _parsedEnteredPrice : (isNaN(currentPrice) ? null : currentPrice);

    const shareData = {
        shareName: shareName,
        currentPrice: isNaN(currentPrice) ? null : currentPrice, // auto derived above
        targetPrice: isNaN(targetPrice) ? null : targetPrice,
        // UPDATED: Save the selected target direction from the new checkboxes
        targetDirection: targetAboveCheckbox.checked ? 'above' : 'below',
        // Persist intent so Alert Target renderer can read directly without needing alert doc (B/S)
        intent: (function(){
            try {
                const dir = targetAboveCheckbox.checked ? 'above' : 'below';
                const buyActive = targetIntentBuyBtn && targetIntentBuyBtn.classList.contains('is-active');
                const sellActive = targetIntentSellBtn && targetIntentSellBtn.classList.contains('is-active');
                if (buyActive && !sellActive) return 'buy';
                if (sellActive && !buyActive) return 'sell';
                return dir === 'above' ? 'sell' : 'buy';
            } catch(_) { return targetAboveCheckbox.checked ? 'sell' : 'buy'; }
        })(),
        dividendAmount: isNaN(dividendAmount) ? null : dividendAmount,
        frankingCredits: isNaN(frankingCredits) ? null : frankingCredits,
        comments: comments,
        // Use the selected watchlist from the modal dropdown
    watchlistId: selectedWatchlistIdForSave,
    watchlistIds: selectedWatchlistIdsForSave,
    // Portfolio fields (optional)
    portfolioShares: (() => { const el = document.getElementById('portfolioShares'); const v = el ? parseFloat(el.value) : NaN; return isNaN(v) ? null : Math.trunc(v); })(),
    portfolioAvgPrice: (() => { const el = document.getElementById('portfolioAvgPrice'); const v = el ? parseFloat(el.value) : NaN; return isNaN(v) ? null : v; })(),
        lastPriceUpdateTime: new Date().toISOString(),
        starRating: shareRatingSelect ? parseInt(shareRatingSelect.value) : 0 // Ensure rating is saved as a number
    };

    // Only set entryPrice/enteredPriceRaw when creating a new share. For updates, preserve
    // the existing entryPrice unless an explicit UX path to change it is implemented.
    try {
        if (!selectedShareDocId) {
            shareData.entryPrice = (_entryPriceCandidate === null) ? null : Number(_entryPriceCandidate);
            shareData.enteredPriceRaw = _rawEnteredPrice || '';
        }
    } catch(_) {}

    if (selectedShareDocId) {
        const existingShare = allSharesData.find(s => s.id === selectedShareDocId);

        // For existing shares, merge watchlist associations
        if (existingShare) {
            // Get existing watchlist IDs
            const existingWatchlistIds = [];
            if (existingShare.watchlistId) {
                existingWatchlistIds.push(existingShare.watchlistId);
            }
            if (Array.isArray(existingShare.watchlistIds)) {
                existingWatchlistIds.push(...existingShare.watchlistIds);
            }

            // Get new watchlist associations
            const newWatchlistIds = selectedWatchlistIdsForSave || [selectedWatchlistIdForSave];

            // Replace watchlist associations with the new selection (not merge)
            const finalWatchlistIds = [...new Set(newWatchlistIds)]; // Remove duplicates from new selection

            // Update shareData with the new watchlist associations
            if (finalWatchlistIds.length > 1) {
                shareData.watchlistIds = finalWatchlistIds;
                shareData.watchlistId = finalWatchlistIds[0]; // Keep legacy field for backward compatibility
            } else if (finalWatchlistIds.length === 1) {
                shareData.watchlistId = finalWatchlistIds[0];
                shareData.watchlistIds = finalWatchlistIds;
            } else {
                // No watchlists selected - this shouldn't happen, but handle gracefully
                shareData.watchlistId = null;
                shareData.watchlistIds = [];
            }

            logDebug('Share Update: Replacing watchlist associations for existing share. Old: [' +
                     existingWatchlistIds.join(', ') + '], New: [' + finalWatchlistIds.join(', ') + ']');

            // Debug: Verify the data is being set correctly
            console.log('Share Update Debug:', {
                shareId: selectedShareDocId,
                oldWatchlists: existingWatchlistIds,
                newWatchlists: finalWatchlistIds
            });
        }

        if (shareData.currentPrice !== null && existingShare && existingShare.currentPrice !== shareData.currentPrice) {
            shareData.previousFetchedPrice = existingShare.lastFetchedPrice;
            shareData.lastFetchedPrice = shareData.currentPrice;
        } else if (!existingShare || existingShare.lastFetchedPrice === undefined) {
            shareData.previousFetchedPrice = shareData.currentPrice;
            shareData.lastFetchedPrice = shareData.currentPrice;
        } else {
            shareData.previousFetchedPrice = existingShare.previousFetchedPrice;
            shareData.lastFetchedPrice = existingShare.lastFetchedPrice;
        }

        try {
            // OPTIMISTIC MERGE: update in-memory cache immediately so UI reflects changes
            try {
                const idx = allSharesData.findIndex(s => s && s.id === selectedShareDocId);
                if (idx !== -1) {
                    const oldShareData = allSharesData[idx];
                    // Merge new values into cache immediately (non-destructive for missing fields)
                    allSharesData[idx] = Object.assign({}, allSharesData[idx], shareData);
                    try { console.log('Optimistic cache merge for share ID:', selectedShareDocId, { before: oldShareData, after: allSharesData[idx] }); } catch(_) {}
                } else {
                    // If not found, add a provisional entry so details render immediately
                    try { allSharesData.push(Object.assign({}, shareData, { id: selectedShareDocId })); } catch(_) {}
                }
                // Re-render watchlist and update banners/modal if open so user sees updates instantly
                try { if (typeof renderWatchlist === 'function') renderWatchlist(); } catch(_) {}
                try { updateTargetHitBanner(); } catch(_) {}
                try { if (typeof refreshNotificationsModalIfOpen === 'function') refreshNotificationsModalIfOpen('CUSTOM_TRIGGER_HITS'); } catch(_) {}
            } catch(e) { console.warn('Optimistic merge failed', e); }

            const shareDocRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/shares', selectedShareDocId);
            await firestore.updateDoc(shareDocRef, shareData);
            // Phase 2: Upsert alert document for this share (intent + direction)
            try {
                await upsertAlertForShare(selectedShareDocId, shareName, shareData, false);
            } catch (e) {
                console.error('Alerts: Failed to upsert alert for share update:', e);
            }
            if (!isSilent) showCustomAlert('Update successful', 1500);
            logDebug('Firestore: Share \'' + shareName + '\' (ID: ' + selectedShareDocId + ') updated.');
        originalShareData = getCurrentFormData(); // Update original data after successful save
        setIconDisabled(saveShareBtn, true); // Disable save button after saving
        // NEW: Explicitly hide the share form modal immediately and deselect the share
        if (!isSilent && shareFormSection) {
            shareFormSection.style.setProperty('display', 'none', 'important'); // Instant hide
            shareFormSection.classList.add('app-hidden'); // Ensure it stays hidden with !important class
        }
    // Prevent any stray observers from reopening the form immediately after save
    if (!isSilent) { window.suppressShareFormReopen = true; setTimeout(()=>{ window.suppressShareFormReopen = false; }, 8000); }
        deselectCurrentShare(); // Deselect share BEFORE fetching live prices to avoid re-opening details modal implicitly
            // NEW: Explicitly hide the share form modal immediately and deselect the share
            if (!isSilent && shareFormSection) {
                shareFormSection.style.setProperty('display', 'none', 'important'); // Instant hide
                shareFormSection.classList.add('app-hidden'); // Ensure it stays hidden with !important class
            }
            deselectCurrentShare(); // Deselect share BEFORE fetching live prices to avoid re-opening details modal implicitly
            // NEW: Trigger a fresh fetch of live prices and re-render to reflect new target hit status
            await fetchLivePrices(); // fetch and merge live price data
            // Explicitly re-render to ensure newly-added/updated rows receive movement/target-hit classes immediately
            try {
                if (typeof renderWatchlist === 'function') renderWatchlist();
                if (typeof enforceTargetHitStyling === 'function') enforceTargetHitStyling();
                // Small deferred second pass to cover async reapply logic elsewhere
                setTimeout(() => {
                    try { if (typeof renderWatchlist === 'function') renderWatchlist(); if (typeof enforceTargetHitStyling === 'function') enforceTargetHitStyling(); } catch(_) {}
                }, 120);
            } catch(_) {}
            // Removed secondary toast; single confirmation already shown earlier.
        } catch (error) {
            console.error('Firestore: Error updating share:', error);
            if (!isSilent) showCustomAlert('Error updating share: ' + error.message);
        }
    } else {
        shareData.entryDate = new Date().toISOString();
        // If currentPrice still null attempt a late grab (race with live fetch)
        if (shareData.currentPrice === null) {
            try {
                const liveDataLate = livePrices[shareName.toUpperCase()];
                if (liveDataLate && typeof liveDataLate.live === 'number' && !isNaN(liveDataLate.live)) {
                    shareData.currentPrice = liveDataLate.live;
                } else if (liveDataLate && typeof liveDataLate.lastLivePrice === 'number' && !isNaN(liveDataLate.lastLivePrice)) {
                    shareData.currentPrice = liveDataLate.lastLivePrice;
                }
            } catch(_) {}
        }
        shareData.lastFetchedPrice = shareData.currentPrice;
        shareData.previousFetchedPrice = shareData.currentPrice;

        // DEDUPLICATION: prevent creating a duplicate share if one already exists with same ASX code
        try {
            const existingByCode = Array.isArray(allSharesData) ? allSharesData.find(s => s && (s.shareName || '').toUpperCase() === shareName) : null;
            if (existingByCode && existingByCode.id) {
                // If the new share includes portfolio holdings or explicitly targets Portfolio, prefer creating a new share
                const hasPortfolioAdd = (shareData && ((shareData.portfolioShares && Number(shareData.portfolioShares) > 0) || (Array.isArray(shareData.watchlistIds) && shareData.watchlistIds.includes('portfolio')) || (shareData.watchlistId === 'portfolio')));
                if (!hasPortfolioAdd) {
                    console.warn('Save Share: Duplicate code detected. Switching to update for id:', existingByCode.id);
                    // Update existing share instead of creating a new one
                    try {
                        const shareDocRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/shares', existingByCode.id);
                        await firestore.updateDoc(shareDocRef, Object.assign({}, shareData, { lastModifiedFromDupSave: new Date().toISOString() }));
                        // Update local cache
                        const idx = allSharesData.findIndex(s => s && s.id === existingByCode.id);
                        if (idx !== -1) {
                            allSharesData[idx] = Object.assign({}, allSharesData[idx], shareData);
                        }
                        selectedShareDocId = existingByCode.id;
                        // Phase 2: upsert alert for this share
                        try { await upsertAlertForShare(selectedShareDocId, shareName, shareData, true); } catch(e) { console.error('Alerts: Failed to upsert after dedupe save:', e); }
                        if (!isSilent) showCustomAlert('Updated existing share instead of creating duplicate', 1500);
                        // Refresh prices and UI
                        await fetchLivePrices();
                        try { if (typeof renderWatchlist === 'function') renderWatchlist(); if (typeof enforceTargetHitStyling === 'function') enforceTargetHitStyling(); } catch(_) {}
                    } catch (e) {
                        console.error('Firestore: Error updating existing share during dedupe save:', e);
                        if (!isSilent) showCustomAlert('Error updating existing share: ' + (e && e.message ? e.message : e));
                    }
                    if (!isSilent) closeModals();
                    return;
                } else {
                    // Found an existing share but the new data includes portfolio/watchlist additions - create a new share instead
                    console.log('Save Share: Existing share found but new share includes portfolio/watchlist additions; creating a new share instead of updating existing.');
                }
            }
        } catch(e) { console.warn('Dedupe check failed', e); }

        try {
            const sharesColRef = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/shares');
            // DEBUG: capture save-time entry price sources to diagnose Adshare modal issue
            try {
                // Conditional debug log (only when DEBUG_MODE enabled)
                try { if (DEBUG_MODE) console.log('Preparing to add share. shareName=', shareName, 'formCurrentPrice=', (currentPriceInput ? currentPriceInput.value : undefined), 'livePriceObj=', livePrices && livePrices[shareName.toUpperCase()] ? livePrices[shareName.toUpperCase()] : undefined, 'shareData.entryPrice=', shareData.entryPrice, 'shareData.enteredPriceRaw=', shareData.enteredPriceRaw); } catch(_) {}
            } catch(_) {}

            // OPTIMISTIC UI: Insert a provisional share into in-memory list so user sees it immediately
            const provisionalId = '__pending:' + Date.now();
            try {
                const provisionalShare = Object.assign({}, shareData, { id: provisionalId, __provisional: true });
                if (!Array.isArray(allSharesData)) allSharesData = [];
                // Ensure we don't duplicate an existing provisional with same code
                const exists = allSharesData.some(s => s && s.id === provisionalId);
                if (!exists) {
                    allSharesData.push(provisionalShare);
                    // Immediately re-apply current sort so the provisional row lands in the correct position
                    try {
                        if (typeof sortShares === 'function') sortShares();
                        else if (typeof renderWatchlist === 'function') renderWatchlist();
                    } catch(_) {}
                }

                // Also merge a provisional livePrices entry so the watchlist shows the entry price while real prices arrive
                try {
                    const code = (shareName || '').toUpperCase();
                    if (code) {
                        // If no live price exists yet for this code, create a provisional one based on entryPrice
                        const existingLP = (typeof livePrices !== 'undefined' && livePrices && livePrices[code]) ? livePrices[code] : null;
                        if (!existingLP || !existingLP.live) {
                            const entry = (shareData.entryPrice !== null && shareData.entryPrice !== undefined) ? Number(shareData.entryPrice) : null;
                            const prev = (existingLP && (typeof existingLP.prevClose === 'number' && !isNaN(existingLP.prevClose))) ? existingLP.prevClose : entry;
                            const lastPrev = (existingLP && (typeof existingLP.lastPrevClose === 'number' && !isNaN(existingLP.lastPrevClose))) ? existingLP.lastPrevClose : prev;
                            const lastLive = (existingLP && (typeof existingLP.lastLivePrice === 'number' && !isNaN(existingLP.lastLivePrice))) ? existingLP.lastLivePrice : entry;
                            const provisionalLP = {
                                live: entry,
                                prevClose: prev,
                                lastLivePrice: lastLive,
                                lastPrevClose: lastPrev,
                                __provisional: true
                            };
                            try { window.livePrices = Object.assign({}, (window.livePrices || {}), { [code]: provisionalLP }); } catch(_) {}
                            try { livePrices = window.livePrices; } catch(_) {}
                        }
                    }
                } catch(_) {}
            } catch(e) { console.warn('Optimistic UI provisional insertion failed', e); }

            const newDocRef = await firestore.addDoc(sharesColRef, shareData);
            selectedShareDocId = newDocRef.id; // Set selectedShareDocId for the newly added share
            // Ensure the in-memory allSharesData is updated: replace provisional entry if present
            try {
                const created = Object.assign({}, shareData, { id: newDocRef.id });
                if (!Array.isArray(allSharesData)) allSharesData = [];

                // Replace provisional entry if it exists (match by the exact provisional id)
                let replaced = false;
                for (let i = 0; i < allSharesData.length; i++) {
                    const s = allSharesData[i];
                    // Use the provisionalId generated at save-time so we only replace the exact optimistic entry
                    if (s && s.__provisional && s.id === provisionalId) {
                        allSharesData[i] = created;
                        replaced = true;
                        break;
                    }
                }

                // If no provisional found, append the created share (listener might not add it)
                if (!replaced) {
                    const exists = allSharesData.some(s => s && s.id === newDocRef.id);
                    if (!exists) allSharesData.push(created);
                }

                // Cleanup provisional markers from livePrices for this code
                try {
                    const code = (created.shareName || '').toUpperCase();
                    if (code && window.livePrices && window.livePrices[code] && window.livePrices[code].__provisional) {
                        // Remove the provisional flag but keep the value (apps will update when real prices arrive)
                        try { delete window.livePrices[code].__provisional; } catch(_) {}
                        try { livePrices = window.livePrices; } catch(_) {}
                    }
                } catch(_) {}

                logDebug('In-memory: inserted/updated newly created share to allSharesData (id=' + newDocRef.id + ')');
            } catch(e) { console.warn('In-memory append/replace of new share failed', e); }
            // Phase 2: Create alert document for this new share (intent + direction)
            try {
                await upsertAlertForShare(selectedShareDocId, shareName, shareData, true);
            } catch (e) {
                console.error('Alerts: Failed to create alert for new share:', e);
            }
            if (!isSilent) showCustomAlert('Added successfully', 1500);
            logDebug('Firestore: Share \'' + shareName + '\' added with ID: ' + newDocRef.id);
        originalShareData = getCurrentFormData(); // Update original data after successful save
        setIconDisabled(saveShareBtn, true); // Disable save button after saving
        // NEW: Explicitly hide the share form modal immediately and deselect the share
        if (!isSilent && shareFormSection) {
            shareFormSection.style.setProperty('display', 'none', 'important'); // Instant hide
            shareFormSection.classList.add('app-hidden'); // Ensure it stays hidden with !important class
        }
    // Prevent any stray observers from reopening the form immediately after save
    if (!isSilent) { window.suppressShareFormReopen = true; setTimeout(()=>{ window.suppressShareFormReopen = false; }, 8000); }
        deselectCurrentShare(); // Deselect newly added share BEFORE fetching live prices
            // NEW: Explicitly hide the share form modal immediately and deselect the share
            if (!isSilent && shareFormSection) {
                shareFormSection.style.setProperty('display', 'none', 'important'); // Instant hide
                shareFormSection.classList.add('app-hidden'); // Ensure it stays hidden with !important class
            }
            deselectCurrentShare(); // Deselect share BEFORE fetching live prices to avoid re-opening details modal implicitly
            // NEW: Trigger a fresh fetch of live prices and re-render to reflect new target hit status
            await fetchLivePrices(); // fetch and merge live price data
            // Explicitly re-render to ensure newly-added/updated rows receive movement/target-hit classes immediately
            try {
                if (typeof renderWatchlist === 'function') renderWatchlist();
                if (typeof enforceTargetHitStyling === 'function') enforceTargetHitStyling();
                // Small deferred second pass to cover async reapply logic elsewhere
                setTimeout(() => {
                    try { if (typeof renderWatchlist === 'function') renderWatchlist(); if (typeof enforceTargetHitStyling === 'function') enforceTargetHitStyling(); } catch(_) {}
                }, 120);
            } catch(_) {}
            // Removed secondary toast; single confirmation already shown earlier.
        } catch (error) {
            console.error('Firestore: Error adding share:', error);
            if (!isSilent) showCustomAlert('Error adding share: ' + error.message);
        }
    }
    // Clear any sticky id on details modal so nothing reopens unexpectedly
    try {
        if (shareDetailModal && shareDetailModal.dataset) delete shareDetailModal.dataset.shareId;
    } catch(_) {}
    if (!isSilent) closeModals(); // Only close if not a silent save
}


function showShareDetails() {
    if (!selectedShareDocId) {
        showCustomAlert('Please select a share to view details.');
        return;
    }
    const share = allSharesData.find(s => s.id === selectedShareDocId);
    if (!share) {
        showCustomAlert('Selected share not found.');
        return;
    }
    // Determine price change class for modalShareName
    let modalShareNamePriceChangeClass = 'neutral';
    const livePriceDataForName = livePrices[share.shareName.toUpperCase()];
    if (livePriceDataForName && livePriceDataForName.live !== null && livePriceDataForName.prevClose !== null && !isNaN(livePriceDataForName.live) && !isNaN(livePriceDataForName.prevClose)) {
        const change = livePriceDataForName.live - livePriceDataForName.prevClose;
        if (change > 0) {
            modalShareNamePriceChangeClass = 'positive';
        } else if (change < 0) {
            modalShareNamePriceChangeClass = 'negative';
        } else {
            modalShareNamePriceChangeClass = 'neutral';
        }
    }
    // Set ASX code in modal title
    modalShareName.textContent = share.shareName || 'N/A';

    // --- AGGRESSIVE FIX: Forcefully find and inject the company name into the modal title ---
    if (modalCompanyName) {
        const companyInfo = allAsxCodes.find(c => c.code === share.shareName.toUpperCase());
        if (companyInfo) {
            modalCompanyName.textContent = companyInfo.name;
            logDebug(`Company Name: Found and set name for ${share.shareName}: ${companyInfo.name}`);
        } else {
            modalCompanyName.textContent = ''; // Clear if not found
            logDebug(`Company Name: Could not find company name for ${share.shareName}`);
        }
        // Force visibility
        modalCompanyName.style.setProperty('display', 'block', 'important');
    }

    // Persist the selected share id on the modal so Edit can recover it if selection is cleared
    if (shareDetailModal) {
        try { shareDetailModal.dataset.shareId = selectedShareDocId; } catch(_) {}
    }

    // Get live price data for this share to check target hit status
    const livePriceDataForModalTitle = livePrices[share.shareName.toUpperCase()];
    const isTargetHitForModalTitle = livePriceDataForModalTitle ? livePriceDataForModalTitle.targetHit : false;

    // Apply modal-share-name, price change class.
    let modalTitleClasses = 'modal-share-name ' + modalShareNamePriceChangeClass;
    // Apply target-hit-alert class if target is hit AND not dismissed
    if (isTargetHitForModalTitle && !targetHitIconDismissed) {
        modalTitleClasses += ' target-hit-alert';
    }
    modalShareName.className = modalTitleClasses; // Apply all classes

    const enteredPriceNum = Number(share.entryPrice || share.currentPrice);

    // Get live price data from the global livePrices object
    const livePriceData = livePrices[share.shareName.toUpperCase()];
    const livePrice = livePriceData ? livePriceData.live : undefined;
    const prevClosePrice = livePriceData ? livePriceData.prevClose : undefined;
    // Get PE, High52, Low52
    const peRatio = livePriceData ? livePriceData.PE : undefined;
    const high52Week = livePriceData ? livePriceData.High52 : undefined;
    const low52Week = livePriceData ? livePriceData.Low52 : undefined;


    // Display large live price and change in the dedicated section
    // The modalLivePriceDisplaySection is already referenced globally
    if (modalLivePriceDisplaySection) {
        modalLivePriceDisplaySection.classList.remove('positive-change-section', 'negative-change-section');

        // Determine price change class for modal live price section
        let priceChangeClass = 'neutral'; // Default to neutral
        if (livePrice !== undefined && livePrice !== null && !isNaN(livePrice) && 
            prevClosePrice !== undefined && prevClosePrice !== null && !isNaN(prevClosePrice)) {
            const change = livePrice - prevClosePrice;
            if (change > 0) {
                priceChangeClass = 'positive';
            } else if (change < 0) {
                priceChangeClass = 'negative';
            } else {
                priceChangeClass = 'neutral';
            }
        }

    // Clear previous dynamic content
    modalLivePriceDisplaySection.innerHTML = '';

    // 52-Week Low / High
    const fiftyTwoWeekRow = document.createElement('div');
    fiftyTwoWeekRow.classList.add('fifty-two-week-row');

        const lowSpan = document.createElement('span');
        lowSpan.classList.add('fifty-two-week-value', 'low');
        lowSpan.textContent = 'Low: ' + (low52Week !== undefined && low52Week !== null && !isNaN(low52Week) ? formatMoney(low52Week) : 'N/A');
        fiftyTwoWeekRow.appendChild(lowSpan);

        const highSpan = document.createElement('span');
        highSpan.classList.add('fifty-two-week-value', 'high');
        highSpan.textContent = 'High: ' + (high52Week !== undefined && high52Week !== null && !isNaN(high52Week) ? formatMoney(high52Week) : 'N/A');
        fiftyTwoWeekRow.appendChild(highSpan);

        modalLivePriceDisplaySection.appendChild(fiftyTwoWeekRow);

    const currentModalLivePriceLarge = document.createElement('span');
    // Force neutral color for primary live price (colour only on change element) to match Add Share snapshot styling
    currentModalLivePriceLarge.classList.add('modal-share-name','live-price-large','neutral');
    const currentModalPriceChangeLarge = document.createElement('span');
    currentModalPriceChangeLarge.classList.add('price-change-large', priceChangeClass);
    modalLivePriceDisplaySection.appendChild(currentModalLivePriceLarge);
    modalLivePriceDisplaySection.appendChild(currentModalPriceChangeLarge);

        if (livePrice !== undefined && livePrice !== null && !isNaN(livePrice)) {
            currentModalLivePriceLarge.textContent = '$' + formatAdaptivePrice(livePrice);
            currentModalLivePriceLarge.style.display = 'inline';
        } else {
            currentModalLivePriceLarge.textContent = 'N/A';
            currentModalLivePriceLarge.style.display = 'inline';
        }

        if (livePrice !== undefined && livePrice !== null && !isNaN(livePrice) &&
            prevClosePrice !== undefined && prevClosePrice !== null && !isNaN(prevClosePrice)) {
            const change = livePrice - prevClosePrice;
            const percentageChange = (prevClosePrice !== 0 && !isNaN(prevClosePrice)) ? (change / prevClosePrice) * 100 : 0;
            // Use centralized formatter to produce: "<dollar> (<percent>%)" (no $ on dollar delta, no leading +)
            currentModalPriceChangeLarge.textContent = formatDailyChange(change, percentageChange);
            currentModalPriceChangeLarge.style.display = 'inline';
        } else {
            currentModalPriceChangeLarge.textContent = '';
            currentModalPriceChangeLarge.style.display = 'none';
        }

    // P/E Ratio
        const peRow = document.createElement('div');
    peRow.classList.add('pe-ratio-row');
    const peSpan = document.createElement('span');
    peSpan.classList.add('pe-ratio-value');
    peSpan.textContent = 'P/E: ' + (peRatio !== undefined && peRatio !== null && !isNaN(peRatio) ? formatAdaptivePrice(peRatio) : 'N/A');
    peRow.appendChild(peSpan);
    modalLivePriceDisplaySection.appendChild(peRow);
    setTimeout(()=>{ try { logTypographyRatios('detail-modal'); } catch(_) {} },0);
    }

    // Entry (formerly reference) price: show 2 decimals by default; preserve up to 3 only if user originally entered >2
    const rawEnteredStr = (share.enteredPriceRaw || '').toString();
    let enteredDecimals = 2;
    const matchEntered = rawEnteredStr.match(/\.(\d{3,})$/); // user typed 3+ decimals
    if (matchEntered) enteredDecimals = Math.min(3, matchEntered[1].length);
    modalEnteredPrice.textContent = (val => (val !== null && !isNaN(val) && val !== 0) ? '$' + Number(val).toFixed(enteredDecimals) : '')(enteredPriceNum);

    // Target price: same logic (preserve up to 3 only if user supplied more than 2 originally)
    const rawTargetStr = (share.targetPriceRaw || '').toString();
    let targetDecimals = 2;
    const matchTarget = rawTargetStr.match(/\.(\d{3,})$/);
    if (matchTarget) targetDecimals = Math.min(3, matchTarget[1].length);
    const targetNum = Number(share.targetPrice);
    const displayTargetPrice = (targetNum !== null && !isNaN(targetNum) && targetNum !== 0) ? '$' + targetNum.toFixed(targetDecimals) : '';

    // Remove legacy alert trigger message per new requirement
    let targetNotificationMessage = '';

    /* Hide empty sections for a cleaner view */
    try {
        // Hide alerts section if no target
        const alertsCard = document.querySelector('.detail-card[data-section="alerts"]');
        if (alertsCard) {
            const hasTarget = share.targetPrice && !isNaN(Number(share.targetPrice)) && Number(share.targetPrice) !== 0;
            alertsCard.style.display = hasTarget ? '' : 'none';
        }

        // Hide comments section if no comments
        const commentsCard = document.querySelector('.detail-card[data-section="comments"]');
        if (commentsCard) {
            const hasComments = Array.isArray(share.comments) && share.comments.some(c => c && (c.text || c.comment));
            commentsCard.style.display = hasComments ? '' : 'none';
        }

        // Hide holdings & dividends section if no holdings
        const dividendsCard = document.querySelector('.detail-card[data-section="dividends"]');
        if (dividendsCard) {
            const hasHoldings = (share.portfolioShares && !isNaN(Number(share.portfolioShares)) && Number(share.portfolioShares) !== 0) ||
                                (share.portfolioAvgPrice && !isNaN(Number(share.portfolioAvgPrice)) && Number(share.portfolioAvgPrice) !== 0);
            dividendsCard.style.display = hasHoldings ? '' : 'none';

            // Within, hide dividend rows if no dividend info
            if (hasHoldings) {
                const hasDividend = share.dividendAmount && !isNaN(Number(share.dividendAmount)) && Number(share.dividendAmount) !== 0;
                const hasFranking = share.frankingCredits && !isNaN(Number(share.frankingCredits)) && Number(share.frankingCredits) !== 0;
                const dividendRows = dividendsCard.querySelectorAll('.detail-row');
                dividendRows.forEach(row => {
                    const label = row.querySelector('.detail-label');
                    if (label && (label.textContent.includes('Dividend') || label.textContent.includes('Franking') || label.textContent.includes('Yield'))) {
                        row.style.display = (hasDividend || hasFranking) ? '' : 'none';
                    }
                });
            }
        }

        // Hide star rating row if rating 0
        const starRatingRow = document.querySelector('#modalStarRating').closest('.detail-row');
        if (starRatingRow) {
            starRatingRow.style.display = (share.starRating > 0) ? '' : 'none';
        }
    } catch(e) { console.warn('Hide Empty Sections: issue applying visibility', e); }

    // If many sections are hidden (or on narrow screens), make Investment section span full width for clarity
    try {
        const investmentSection = shareDetailModal.querySelector('.detail-card[data-section="investment"]');
        if (investmentSection) {
            // Use computed style & layout checks to reliably detect visibility (handles CSS rules, inline styles, and ancestor hiding)
            const adjustInvestmentSpan = () => {
                try {
                    const siblingSections = Array.from(shareDetailModal.querySelectorAll('.detail-card')).filter(el => el !== investmentSection);
                    // Count only visible siblings that are NOT already full-span (these share the same row)
                    const visibleNonFullSpanSiblings = siblingSections.filter(s => {
                        try {
                            if (s.classList && s.classList.contains('full-span')) return false; // ignore full-span siblings
                            const cs = window.getComputedStyle(s);
                            return !!(cs && cs.display !== 'none' && cs.visibility !== 'hidden' && s.offsetParent !== null);
                        } catch(_) { return false; }
                    }).length;

                    // Diagnostic: log visible sibling count to help debug cases where the investment card remains a small square
                    try { logDebug && typeof logDebug === 'function' && logDebug('Detail modal: visibleNonFullSpanSiblings=' + visibleNonFullSpanSiblings + ', viewport=' + window.innerWidth); } catch(_) {}
                    // If there are one or fewer visible non-full-span siblings OR on narrow viewport, promote investment to full-span
                    if (visibleNonFullSpanSiblings <= 1 || window.innerWidth < 680) {
                        investmentSection.classList.add('full-span');
                    } else {
                        investmentSection.classList.remove('full-span');
                    }
                } catch(e) { console.warn('Detail modal: adjustInvestmentSpan failed', e); }
            };

            // Run adjustment immediately
            adjustInvestmentSpan();

            // Install a single resize handler per modal instance (avoid duplicates)
            try { if (shareDetailModal.__investmentResizeHandler) window.removeEventListener('resize', shareDetailModal.__investmentResizeHandler); } catch(_) {}
            const resizeHandler = () => adjustInvestmentSpan();
            shareDetailModal.__investmentResizeHandler = resizeHandler;
            window.addEventListener('resize', resizeHandler);

            // Also observe mutations inside the modal so when sections are shown/hidden we recompute
            try { if (shareDetailModal.__investmentObserver) shareDetailModal.__investmentObserver.disconnect(); } catch(_) {}
            let __invTimer = null;
            const debouncedAdjust = () => { if (__invTimer) clearTimeout(__invTimer); __invTimer = setTimeout(() => { try { adjustInvestmentSpan(); } catch(_){}; __invTimer = null; }, 80); };
            const mo = new MutationObserver((mutations) => { debouncedAdjust(); });
            mo.observe(shareDetailModal, { attributes: true, childList: true, subtree: true, attributeFilter: ['style', 'class'] });
            shareDetailModal.__investmentObserver = mo;
        }
    } catch(e) { console.warn('Detail modal: failed to adjust investment section span', e); }

    modalTargetPrice.innerHTML = renderAlertTargetInline(share, { emptyReturn: '' });

    // Ensure dividendAmount and frankingCredits are numbers before formatting
    const displayDividendAmount = Number(share.dividendAmount);
    const displayFrankingCredits = Math.trunc(Number(share.frankingCredits));

    modalDividendAmount.textContent = (val => (val !== null && !isNaN(val) && val !== 0) ? '$' + formatAdaptivePrice(val, {force2:true}) : '')(displayDividendAmount);
    modalFrankingCredits.textContent = (val => (val !== null && !isNaN(val) && val !== 0) ? Math.trunc(val) + '%' : '')(displayFrankingCredits);

    // Populate Holdings fields
    modalPortfolioShares.textContent = (share.portfolioShares ? share.portfolioShares : '');
    modalPortfolioAvgPrice.textContent = (share.portfolioAvgPrice ? '$' + formatAdaptivePrice(share.portfolioAvgPrice) : '');

    // Compute and populate Purchase Cost, Current Value, Capital Gain
    try {
        const sharesNum = (share.portfolioShares !== null && share.portfolioShares !== undefined && !isNaN(Number(share.portfolioShares))) ? Number(share.portfolioShares) : null;
        const avgPriceNum = (share.portfolioAvgPrice !== null && share.portfolioAvgPrice !== undefined && !isNaN(Number(share.portfolioAvgPrice))) ? Number(share.portfolioAvgPrice) : null;

        // Determine live price with existing fallback logic
        const lpForCode = livePrices[share.shareName?.toUpperCase()];
        let livePriceForCalc = (lpForCode && lpForCode.live !== null && !isNaN(lpForCode.live)) ? lpForCode.live : undefined;
        if (livePriceForCalc === undefined || livePriceForCalc === null || isNaN(livePriceForCalc)) {
            livePriceForCalc = (lpForCode && lpForCode.lastLivePrice !== null && !isNaN(lpForCode.lastLivePrice)) ? lpForCode.lastLivePrice : undefined;
        }
        if (livePriceForCalc === undefined || livePriceForCalc === null || isNaN(livePriceForCalc)) {
            livePriceForCalc = (share.currentPrice !== null && share.currentPrice !== undefined && !isNaN(Number(share.currentPrice))) ? Number(share.currentPrice) : undefined;
        }
        if (livePriceForCalc === undefined || livePriceForCalc === null || isNaN(livePriceForCalc)) {
            livePriceForCalc = enteredPriceNum; // fallback to entry/current logic used elsewhere
        }

        // Helper to clear classes
        const clearPosNeg = (el) => { if (!el) return; el.classList.remove('positive'); el.classList.remove('negative'); };

        if (sharesNum !== null && avgPriceNum !== null) {
            const purchaseCostNum = sharesNum * avgPriceNum;
            modalPurchaseCost.textContent = formatMoney(purchaseCostNum, { decimals: 2 });
        } else {
            if (modalPurchaseCost) modalPurchaseCost.textContent = '';
        }

        if (sharesNum !== null && livePriceForCalc !== undefined && livePriceForCalc !== null && !isNaN(livePriceForCalc)) {
            const currentValueNum = sharesNum * Number(livePriceForCalc);
            modalCurrentValue.textContent = formatMoney(currentValueNum, { decimals: 2 });
            // Color by comparison with purchase cost when available
            if (sharesNum !== null && avgPriceNum !== null) {
                const purchaseCostNum = sharesNum * avgPriceNum;
                clearPosNeg(modalCurrentValue);
                if (currentValueNum > purchaseCostNum) modalCurrentValue.classList.add('positive');
                else if (currentValueNum < purchaseCostNum) modalCurrentValue.classList.add('negative');
            } else {
                clearPosNeg(modalCurrentValue);
            }
        } else {
            if (modalCurrentValue) { modalCurrentValue.textContent = ''; clearPosNeg(modalCurrentValue); }
        }

        if (sharesNum !== null && avgPriceNum !== null && livePriceForCalc !== undefined && livePriceForCalc !== null && !isNaN(livePriceForCalc)) {
            const purchaseCostNum = sharesNum * avgPriceNum;
            const currentValueNum = sharesNum * Number(livePriceForCalc);
            const capitalGainNum = currentValueNum - purchaseCostNum;
            modalCapitalGain.textContent = (capitalGainNum !== null && !isNaN(capitalGainNum)) ? formatMoney(capitalGainNum, { decimals: 2 }) : '';
            clearPosNeg(modalCapitalGain);
            if (capitalGainNum > 0) modalCapitalGain.classList.add('positive');
            else if (capitalGainNum < 0) modalCapitalGain.classList.add('negative');
        } else {
            if (modalCapitalGain) { modalCapitalGain.textContent = ''; clearPosNeg(modalCapitalGain); }
        }
    } catch (e) { console.warn('Modal computed fields: error computing purchase/current/gain', e); }

    const priceForYield = (livePrice !== undefined && livePrice !== null && !isNaN(livePrice)) ? livePrice : enteredPriceNum;
    const unfrankedYield = calculateUnfrankedYield(displayDividendAmount, priceForYield); 
    // Display unfranked yield only if it's not null/NaN AND not 0
    modalUnfrankedYieldSpan.textContent = unfrankedYield !== null && !isNaN(unfrankedYield) && unfrankedYield !== 0 ? formatAdaptivePercent(unfrankedYield) + '%' : '';

    const frankedYield = calculateFrankedYield(displayDividendAmount, priceForYield, displayFrankingCredits);
    // Display franked yield only if it's not null/NaN AND not 0
    modalFrankedYieldSpan.textContent = frankedYield !== null && !isNaN(frankedYield) && frankedYield !== 0 ? formatAdaptivePercent(frankedYield) + '%' : '';

    // Populate Entry Date after Franked Yield
    modalEntryDate.textContent = formatDate(share.entryDate) || 'N/A';
    modalStarRating.textContent = share.starRating > 0 ? '⭐'.repeat(share.starRating) : '';

    if (modalCommentsContainer) {
        modalCommentsContainer.innerHTML = '';
        if (share.comments && Array.isArray(share.comments) && share.comments.length > 0) {
            share.comments.forEach(comment => {
                if (comment.title || comment.text) {
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'modal-comment-item';

                    // Conditional Title Bar
                    if (comment.title && comment.title.trim() !== '') {
                        const titleBar = document.createElement('div');
                        titleBar.classList.add('comment-title-bar'); // New class for styling
                        titleBar.textContent = comment.title;
                        commentDiv.appendChild(titleBar);
                    }

                    const commentTextP = document.createElement('p');
                    commentTextP.textContent = comment.text || '';
                    commentDiv.appendChild(commentTextP);

                    modalCommentsContainer.appendChild(commentDiv);
                }
            });
        } else {
            modalCommentsContainer.innerHTML = '<p style="text-align: center; color: var(--label-color);">No comments for this share.</p>';
        }
    }
    // External Links

    if (modalNewsLink && share.shareName) {
        const code = String(share.shareName).toUpperCase();
        const newsUrl = 'https://news.google.com/search?q=' + encodeURIComponent(share.shareName) + '%20ASX&hl=en-AU&gl=AU&ceid=AU%3Aen';
        modalNewsLink.href = newsUrl;
        modalNewsLink.innerHTML = code + ' News <i class="fas fa-external-link-alt"></i>';
        modalNewsLink.style.display = 'inline-flex';
        setIconDisabled(modalNewsLink, false);
    } else if (modalNewsLink) {
        modalNewsLink.style.display = 'none';
        setIconDisabled(modalNewsLink, true);
    }

    if (modalMarketIndexLink && share.shareName) {
        const marketIndexUrl = 'https://www.marketindex.com.au/asx/' + share.shareName.toLowerCase();
        modalMarketIndexLink.href = marketIndexUrl;
        modalMarketIndexLink.innerHTML = 'Market Index <i class="fas fa-external-link-alt"></i>';
        modalMarketIndexLink.style.display = 'inline-flex';
        setIconDisabled(modalMarketIndexLink, false);
    } else if (modalMarketIndexLink) {
        modalMarketIndexLink.style.display = 'none';
        setIconDisabled(modalMarketIndexLink, true);
    }

    // Fool.com.au Link
    if (modalFoolLink && share.shareName) {
        const foolCode = String(share.shareName).trim().toLowerCase();
        modalFoolLink.href = `https://www.fool.com.au/tickers/asx-${foolCode}/`;
        modalFoolLink.innerHTML = 'Motley Fool <i class="fas fa-external-link-alt"></i>';
        modalFoolLink.style.display = 'inline-flex';
        setIconDisabled(modalFoolLink, false);
    } else if (modalFoolLink) {
        modalFoolLink.style.display = 'none';
        setIconDisabled(modalFoolLink, true);
    }

    // Listcorp.com Link (NEW)
    if (modalListcorpLink && share.shareName) {
        const listcorpUrl = `https://www.listcorp.com/asx/${share.shareName.toLowerCase()}`;
        modalListcorpLink.href = listcorpUrl;
        modalListcorpLink.innerHTML = `Listcorp <i class=\"fas fa-external-link-alt\"></i>`;
        modalListcorpLink.style.display = 'inline-flex';
        setIconDisabled(modalListcorpLink, false);
    } else if (modalListcorpLink) {
        modalListcorpLink.style.display = 'none';
        setIconDisabled(modalListcorpLink, true);
    }

    // HotCopper.com.au Link (NEW)
    const modalHotCopperLink = document.getElementById('modalHotCopperLink');
    if (modalHotCopperLink && share.shareName) {
        const hotCopperUrl = `https://hotcopper.com.au/asx/${share.shareName.toLowerCase()}`;
        modalHotCopperLink.href = hotCopperUrl;
        modalHotCopperLink.innerHTML = `HotCopper <i class=\"fas fa-external-link-alt\"></i>`;
        modalHotCopperLink.style.display = 'inline-flex';
        setIconDisabled(modalHotCopperLink, false);
    } else if (modalHotCopperLink) {
        modalHotCopperLink.style.display = 'none';
        setIconDisabled(modalHotCopperLink, true);
    }

    // CommSec.com.au Link (DYNAMIC) + Google Finance
    if (modalCommSecLink && share.shareName) {
        const commsecUrl = `https://www2.commsec.com.au/quotes/summary?stockCode=${encodeURIComponent(share.shareName)}&exchangeCode=ASX`;
        modalCommSecLink.href = commsecUrl;
        modalCommSecLink.innerHTML = 'CommSec <i class="fas fa-external-link-alt"></i>';
        modalCommSecLink.style.display = 'inline-flex';
        setIconDisabled(modalCommSecLink, false);
    } else if (modalCommSecLink) {
        modalCommSecLink.style.display = 'none';
        setIconDisabled(modalCommSecLink, true);
    }

    if (typeof modalGoogleFinanceLink !== 'undefined') {
        try {
            if (modalGoogleFinanceLink && share.shareName) {
                modalGoogleFinanceLink.href = `https://www.google.com/finance/quote/${share.shareName.toUpperCase()}:ASX?hl=en`;
                modalGoogleFinanceLink.style.display = 'inline-flex';
            } else if (modalGoogleFinanceLink) {
                modalGoogleFinanceLink.style.display = 'none';
            }
        } catch(_) {}
    }

    if (modalCommSecLink && commSecLoginMessage) {
        // Move the login message directly after the CommSec link in the DOM, inside the same parent
        if (modalCommSecLink.parentNode && modalCommSecLink.nextSibling !== commSecLoginMessage) {
            modalCommSecLink.parentNode.insertBefore(commSecLoginMessage, modalCommSecLink.nextSibling);
        }
        // Style the login message for subtle, flush display
        commSecLoginMessage.style.display = 'block';
        commSecLoginMessage.style.fontSize = '75%';
        commSecLoginMessage.style.fontWeight = 'normal';
        commSecLoginMessage.style.color = 'var(--label-color, #888)';
        commSecLoginMessage.style.marginTop = '2px';
        commSecLoginMessage.style.marginBottom = '0';
        commSecLoginMessage.style.padding = '0';
    }

    showModal(shareDetailModal);
    try { scrollMainToTop(); } catch(_) {}
    logDebug('Details: Displayed details for share: ' + share.shareName + ' (ID: ' + selectedShareDocId + ')');

    // Inject Watchlists membership footer inside Investment section (centered, subtle)
    try {
        const investmentSection = shareDetailModal.querySelector('.detail-card[data-section="investment"]');
        if (investmentSection) {
            // Remove any previous footer to avoid duplicates on re-open
            const old = investmentSection.querySelector('.watchlists-membership-footer');
            if (old) old.remove();
            // Derive watchlist names (excluding special virtual ids except portfolio)
            const wlIds = Array.isArray(share.watchlistIds) ? share.watchlistIds : (share.watchlistId ? [share.watchlistId] : []);
            console.log('[DEBUG] Watchlist membership for share', share.shareName, '- wlIds:', wlIds);
            const names = [];
            wlIds.forEach(id => {
                if (!id || id === '__movers' || id === 'portfolio') return;
                const wl = userWatchlists.find(w => w.id === id);
                if (wl && wl.name) names.push(wl.name.trim());
            });
            // Check if share is in portfolio (by id)
            const inPortfolio = wlIds.includes('portfolio');
            if (inPortfolio) names.push('Portfolio');
            console.log('[DEBUG] Watchlist names for footer:', names);
            if (names.length) {
                const footer = document.createElement('div');
                footer.className = 'watchlists-membership-footer';
                footer.textContent = names.join(' / ');
                investmentSection.appendChild(footer);
            }
        }
    } catch(e) { console.warn('Watchlists footer inject failed', e); }
}

function sortShares() {
    // Read the authoritative sort order from the centralized state module when available.
    // Fallback to window.currentSortOrder for legacy callers.
    const sortValue = (typeof getCurrentSortOrder === 'function') ? getCurrentSortOrder() : (window.currentSortOrder || '');
    // Always work off a fresh snapshot of live prices to avoid stale local copies
    const prices = (typeof getLivePrices === 'function') ? getLivePrices() : ((typeof livePrices === 'object' && livePrices) ? livePrices : (window.livePrices || {}));
    logDebug('AGGRESSIVE DEBUG: sortShares called with currentSortOrder: ' + sortValue);
    // Lightweight runtime tracing to help QA: show active sort and a small before/after sample only when DEBUG_MODE
    try {
        if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
            console.log('[SORT DEBUG] sortShares invoked. sortValue=', sortValue, 'allSharesData.length=', Array.isArray(allSharesData)? allSharesData.length : 0);
            try { console.log('[SORT DEBUG] sample BEFORE sort:', Array.isArray(allSharesData) ? allSharesData.slice(0,6).map(s => (s && (s.shareName || s.id)) || s) : []); } catch(_) {}
        }
    } catch(_) {}
    if (!sortValue || sortValue === '') {
        logDebug('Sort: Sort placeholder selected, no explicit sorting applied.');
        renderWatchlist(); 
        return;
    }
    const [field, order] = sortValue.split('-');
    logDebug('AGGRESSIVE DEBUG: Sorting by field: ' + field + ', order: ' + order);
    allSharesData.sort((a, b) => {
        // If either item has been hidden-from-totals (eye icon), push hidden items to the end
        // EXCEPT when sorting by name (shareName asc/desc) where the A-Z behaviour should remain intact.
        try {
            const __sortField = field;
            const aHidden = (typeof hiddenFromTotalsShareIds !== 'undefined' && hiddenFromTotalsShareIds && a && a.id) ? hiddenFromTotalsShareIds.has(a.id) : false;
            const bHidden = (typeof hiddenFromTotalsShareIds !== 'undefined' && hiddenFromTotalsShareIds && b && b.id) ? hiddenFromTotalsShareIds.has(b.id) : false;
            if (__sortField !== 'shareName' && aHidden !== bHidden) {
                // Hidden items always go to the bottom regardless of asc/desc
                return aHidden ? 1 : -1;
            }
        } catch (_) { /* defensive: if hidden set not available, continue normally */ }

        // Handle sorting by percentage change
        if (field === 'percentageChange') {
            logDebug('AGGRESSIVE DEBUG: Percentage change sorting detected');
            const livePriceDataA = prices[a.shareName.toUpperCase()];
            const livePriceA = livePriceDataA ? livePriceDataA.live : undefined;
            const prevCloseA = livePriceDataA ? (livePriceDataA.prevClose ?? livePriceDataA.lastPrevClose) : undefined;

            const livePriceDataB = prices[b.shareName.toUpperCase()];
            const livePriceB = livePriceDataB ? livePriceDataB.live : undefined;
            const prevCloseB = livePriceDataB ? (livePriceDataB.prevClose ?? livePriceDataB.lastPrevClose) : undefined; // Corrected variable name

            let percentageChangeA = null;
            // Only calculate if both livePriceA and prevCloseA are valid numbers and prevCloseA is not zero
            if (livePriceA !== undefined && livePriceA !== null && !isNaN(livePriceA) &&
                prevCloseA !== undefined && prevCloseA !== null && !isNaN(prevCloseA) && prevCloseA !== 0) {
                percentageChangeA = ((livePriceA - prevCloseA) / prevCloseA) * 100;
            } else {
                // Fallback for provisional/new shares without live data: use lastFetchedPrice/previousFetchedPrice/currentPrice
                try {
                    const priceNow = (typeof a.lastFetchedPrice === 'number' && !isNaN(a.lastFetchedPrice)) ? a.lastFetchedPrice
                                  : (typeof a.currentPrice === 'number' && !isNaN(a.currentPrice)) ? a.currentPrice : null;
                    const prev = (typeof a.previousFetchedPrice === 'number' && !isNaN(a.previousFetchedPrice)) ? a.previousFetchedPrice : null;
                    if (priceNow !== null && prev !== null && prev !== 0) {
                        percentageChangeA = ((priceNow - prev) / prev) * 100;
                    } else if (priceNow !== null && (prev === null || prev === 0)) {
                        // If we have a current/entry price but no valid previous, treat as 0% to position reasonably
                        percentageChangeA = 0;
                    }
                } catch(_) {}
            }

            let percentageChangeB = null;
            // Only calculate if both livePriceB and prevCloseB are valid numbers and prevCloseB is not zero
            if (livePriceB !== undefined && livePriceB !== null && !isNaN(livePriceB) &&
                prevCloseB !== undefined && prevCloseB !== null && !isNaN(prevCloseB) && prevCloseB !== 0) { // Corrected variable name here
                percentageChangeB = ((livePriceB - prevCloseB) / prevCloseB) * 100;
            } else {
                try {
                    const priceNow = (typeof b.lastFetchedPrice === 'number' && !isNaN(b.lastFetchedPrice)) ? b.lastFetchedPrice
                                  : (typeof b.currentPrice === 'number' && !isNaN(b.currentPrice)) ? b.currentPrice : null;
                    const prev = (typeof b.previousFetchedPrice === 'number' && !isNaN(b.previousFetchedPrice)) ? b.previousFetchedPrice : null;
                    if (priceNow !== null && prev !== null && prev !== 0) {
                        percentageChangeB = ((priceNow - prev) / prev) * 100;
                    } else if (priceNow !== null && (prev === null || prev === 0)) {
                        percentageChangeB = 0;
                    }
                } catch(_) {}
            }

            // Debugging log for percentage sort
            logDebug('Sort Debug - Percentage: Comparing ' + a.shareName + ' (Change: ' + percentageChangeA + ') vs ' + b.shareName + ' (Change: ' + percentageChangeB + ')');


            // Handle null/NaN percentage changes to push them to the bottom
            // If both are null, their relative order doesn't matter (return 0)
            if (percentageChangeA === null && percentageChangeB === null) return 0;
            // If A is null but B is a number, A goes to the bottom
            if (percentageChangeA === null) return 1; 
            // If B is null but A is a number, B goes to the bottom
            if (percentageChangeB === null) return -1; 

            // Now perform numerical comparison for non-null values
            // Use a small epsilon to treat near-equal floating values as equal, then fall back
            // to a stable secondary sort (shareName) so ordering is deterministic.
            const diff = (order === 'asc') ? (percentageChangeA - percentageChangeB) : (percentageChangeB - percentageChangeA);
            if (Math.abs(diff) > Number.EPSILON) return diff;
            // Tie-breaker: deterministic by shareName (A-Z). This keeps behavior stable when
            // percentage changes are effectively equal (including both 0).
            const nameA = (a.shareName || '').toUpperCase().trim();
            const nameB = (b.shareName || '').toUpperCase().trim();
            if (nameA === '' && nameB === '') return 0;
            if (nameA === '') return 1;
            if (nameB === '') return -1;
            return nameA.localeCompare(nameB);
        } else if (field === 'dayDollar' || field === 'totalDollar' || field === 'capitalGain') {
            const safeNum = (v) => {
                const n = Number(v);
                return (typeof n === 'number' && !isNaN(n)) ? n : null;
            };
            const getPortfolioMetric = (share) => {
                try {
                    const lp = prices[(share.shareName || '').toUpperCase()];
                    // Determine priceNow with fallbacks
                    const priceNowRaw = (lp && (safeNum(lp.live) !== null)) ? lp.live : (lp && (safeNum(lp.lastLivePrice) !== null) ? lp.lastLivePrice : share.currentPrice);
                    const priceNow = safeNum(priceNowRaw);
                    if (priceNow === null) return null;

                    const sharesRaw = share.portfolioShares;
                    const shares = safeNum(sharesRaw);
                    if (shares === null || shares === 0) return null;

                    if (field === 'dayDollar') {
                        const prevCloseRaw = lp ? (lp.prevClose ?? lp.lastPrevClose) : null;
                        const prevClose = safeNum(prevCloseRaw);
                        if (prevClose === null) return null;
                        return (priceNow - prevClose) * shares;
                    }

                    if (field === 'capitalGain') {
                        const avgPrice = safeNum(share.portfolioAvgPrice);
                        if (avgPrice === null) return null;
                        return (priceNow - avgPrice) * shares;
                    }

                    if (field === 'totalDollar') {
                        return priceNow * shares;
                    }
                    return null;
                } catch (e) { return null; }
            };

            const valAraw = getPortfolioMetric(a);
            const valBraw = getPortfolioMetric(b);
            const valA = safeNum(valAraw);
            const valB = safeNum(valBraw);

            // deterministic null handling: push nulls to the end for both asc/desc
            if (valA === null && valB === null) return 0;
            if (valA === null) return 1;
            if (valB === null) return -1;

            return order === 'asc' ? (valA - valB) : (valB - valA);
        }

        let valA = a[field];
        let valB = b[field];

        if (field === 'currentPrice' || field === 'targetPrice' || field === 'frankingCredits') {
            valA = (typeof valA === 'string' && valA.trim() !== '') ? parseFloat(valA) : valA;
            valB = (typeof valB === 'string' && valB.trim() !== '') ? parseFloat(valB) : valB;
            valA = (valA === null || valA === undefined || isNaN(valA)) ? (order === 'asc' ? Infinity : -Infinity) : valA;
            valB = (valB === null || valB === undefined || isNaN(valB)) ? (order === 'asc' ? Infinity : -Infinity) : valB;
            return order === 'asc' ? valA - valB : valB - valA;
        } else if (field === 'dividendAmount') { // Dedicated logic for dividendAmount (yield)
            // Get live price data for share A
            const livePriceDataA = prices[a.shareName.toUpperCase()];
            const livePriceA = livePriceDataA ? livePriceDataA.live : undefined;
            // Price for yield calculation: prefer live price, fall back to entered price
            // Default to 0 if price is invalid or zero to avoid division issues in yield functions
            const priceForYieldA = (livePriceA !== undefined && livePriceA !== null && !isNaN(livePriceA) && livePriceA > 0) ? livePriceA : (Number(a.currentPrice) > 0 ? Number(a.currentPrice) : 0);

            // Get live price data for share B
            const livePriceDataB = prices[b.shareName.toUpperCase()];
            const livePriceB = livePriceDataB ? livePriceDataB.live : undefined;
            // Price for yield calculation: prefer live price, fall back to entered price
            // Default to 0 if price is invalid or zero to avoid division issues in yield functions
            const priceForYieldB = (livePriceB !== undefined && livePriceB !== null && !isNaN(livePriceB) && livePriceB > 0) ? livePriceB : (Number(b.currentPrice) > 0 ? Number(b.currentPrice) : 0);

            const dividendAmountA = Number(a.dividendAmount) || 0; // Default to 0 if not a number
            const frankingCreditsA = Number(a.frankingCredits) || 0; // Default to 0 if not a number

            const dividendAmountB = Number(b.dividendAmount) || 0; // Default to 0 if not a number
            const frankingCreditsB = Number(b.frankingCredits) || 0; // Default to 0 if not a number

            // Calculate yields for share A using the determined priceForYieldA
            const frankedYieldA = calculateFrankedYield(dividendAmountA, priceForYieldA, frankingCreditsA);
            const unfrankedYieldA = calculateUnfrankedYield(dividendAmountA, priceForYieldA);

            // Calculate yields for share B using the determined priceForYieldB
            const frankedYieldB = calculateFrankedYield(dividendAmountB, priceForYieldB, frankingCreditsB);
            const unfrankedYieldB = calculateUnfrankedYield(dividendAmountB, priceForYieldB);

            // Determine the effective yield for sorting for A (prioritize franked if > 0, then unfranked)
            let effectiveYieldA = 0; // Default to 0, not null
            if (frankingCreditsA > 0 && frankedYieldA > 0) { // Only use franked if franking > 0 AND yield > 0
                effectiveYieldA = frankedYieldA;
            } else if (unfrankedYieldA > 0) { // Only use unfranked if yield > 0
                effectiveYieldA = unfrankedYieldA;
            }
            // If both are 0 or less, effectiveYieldA remains 0

            // Determine the effective yield for sorting for B (prioritize franked if > 0, then unfranked)
            let effectiveYieldB = 0; // Default to 0, not null
            if (frankingCreditsB > 0 && frankedYieldB > 0) { // Only use franked if franking > 0 AND yield > 0
                effectiveYieldB = frankedYieldB;
            } else if (unfrankedYieldB > 0) { // Only use unfranked if yield > 0
                effectiveYieldB = unfrankedYieldB;
            }
            // If both are 0 or less, effectiveYieldB remains 0

            logDebug(`Sort Debug - Dividend: Comparing ${a.shareName} (Effective Yield A: ${effectiveYieldA}) vs ${b.shareName} (Effective Yield B: ${effectiveYieldB})`);

            // Perform numerical comparison. Since effectiveYieldA/B are now always numbers (0 or positive),
            // we don't need the Infinity/1e10 logic here.
            return order === 'asc' ? effectiveYieldA - effectiveYieldB : effectiveYieldB - effectiveYieldA;
        } else if (field === 'shareName') {
            const nameA = (a.shareName || '').toUpperCase().trim();
            const nameB = (b.shareName || '').toUpperCase().trim();
            if (nameA === '' && nameB === '') return 0;
            // If A is empty, it comes after B (push to bottom)
            if (nameA === '') return 1; 
            // If B is empty, it comes after A (push to bottom)
            if (nameB === '') return -1; 

            return order === 'asc' ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
        } else if (field === 'starRating') {
            const ratingA = a.starRating !== undefined && a.starRating !== null && !isNaN(parseInt(a.starRating)) ? parseInt(a.starRating) : 0;
            const ratingB = b.starRating !== undefined && b.starRating !== null && !isNaN(parseInt(b.starRating)) ? parseInt(b.starRating) : 0;
            // When sorting ascending (Low to High), treat rating 0 as "no rating" and push to the bottom.
            if (order === 'asc') {
                const aIsZero = ratingA === 0;
                const bIsZero = ratingB === 0;
                if (aIsZero && bIsZero) return 0;
                if (aIsZero) return 1; // A goes to bottom
                if (bIsZero) return -1; // B goes to bottom
                return ratingA - ratingB;
            }
            return ratingB - ratingA;
        } else if (field === 'entryDate') {
            // UPDATED: Robust date parsing for sorting
            const dateA = new Date(valA);
            const dateB = new Date(valB);
            
            // Handle invalid dates by pushing them to the end of the list (Infinity for asc, -Infinity for desc)
            const timeA = isNaN(dateA.getTime()) ? (order === 'asc' ? Infinity : -Infinity) : dateA.getTime();
            const timeB = isNaN(dateB.getTime()) ? (order === 'asc' ? Infinity : -Infinity) : dateB.getTime();

            return order === 'asc' ? timeA - timeB : timeB - timeA;
        } else {
            if (order === 'asc') {
                if (valA < valB) return -1;
                if (valA > valB) return 1;
                return 0;
            } else {
                if (valA > valB) return -1;
                if (valA < valB) return 1;
                return 0;
            }
        }
    });
    logDebug('Sort: Shares sorted. Rendering watchlist.');
    try { if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) console.log('[SORT DEBUG] sample AFTER sort:', Array.isArray(allSharesData) ? allSharesData.slice(0,6).map(s => (s && (s.shareName || s.id)) || s) : []); } catch(_) {}
    renderWatchlist();
    // Completion trace for diagnostics: indicate which sortValue was applied when sorting finished.
    try { console.log('[SORT COMPLETE] Applied sort:', sortValue); } catch(_) {}
}

// Expose sortShares to window for use by other modules
window.sortShares = sortShares;

/**
 * Sorts the cash categories based on the currentSortOrder.
 * @returns {Array} The sorted array of cash categories.
 */
function sortCashCategories(categoriesParam) {
    const categories = Array.isArray(categoriesParam) ? categoriesParam : getUserCashCategories();
    const sortValue = getCurrentSortOrder();
    if (!sortValue || sortValue === '') {
        logDebug('Sort: Cash sort placeholder selected, no explicit sorting applied.');
        return [...categories];
    }

    const [field, order] = sortValue.split('-');

    // Map logical sort fields to actual object properties.
    // 'totalDollar' from the UI maps to the cash asset's 'balance' property.
    const sortField = (field === 'totalDollar') ? 'balance' : field;

    if (sortField !== 'name' && sortField !== 'balance') {
        logDebug('Sort: Invalid sort field for cash assets: ' + field + '. Defaulting to name-asc.');
        return [...categories].sort((a, b) => a.name.localeCompare(b.name));
    }

    const sortedCategories = [...categories].sort((a, b) => {
        // Push hidden cash categories to the end for all sorts except name-based sorts
        try {
            const aHidden = Boolean(a && a.isHidden);
            const bHidden = Boolean(b && b.isHidden);
            if (field !== 'name' && aHidden !== bHidden) {
                return aHidden ? 1 : -1;
            }
        } catch(_) {}

        let valA = a[sortField];
        let valB = b[sortField];

        if (sortField === 'balance') {
            // Robust numeric parsing: accept numbers, numeric strings, or formatted currency (commas, $)
            const parseNum = (v) => {
                if (v === null || typeof v === 'undefined') return 0;
                if (typeof v === 'number' && !isNaN(v)) return v;
                try {
                    // Remove any non-numeric chars except dot/minus
                    const cleaned = String(v).replace(/[^0-9.\-]/g, '');
                    const n = parseFloat(cleaned);
                    return isNaN(n) ? 0 : n;
                } catch (_) { return 0; }
            };
            const numA = parseNum(valA);
            const numB = parseNum(valB);
            return order === 'asc' ? numA - numB : numB - numA;
        } else if (field === 'name') {
            const nameA = (a.name || '').toUpperCase().trim();
            const nameB = (b.name || '').toUpperCase().trim();
            return order === 'asc' ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
        }
        return 0; // Should not reach here
    });

    logDebug('Sort: Cash categories sorted by ' + field + ' ' + order + '.');
    return sortedCategories;
}
function renderWatchlistSelect() {
    if (!watchlistSelect) { console.error('renderWatchlistSelect: watchlistSelect element not found.'); return; }
    // Store the currently selected value before clearing
    const currentSelectedValue = watchlistSelect.value;
    
    // Set the initial placeholder text to "Watch List"
    watchlistSelect.innerHTML = '<option value="" disabled selected>Watch List</option>';

    const allSharesOption = document.createElement('option');
    allSharesOption.value = ALL_SHARES_ID;
    allSharesOption.textContent = 'All Shares';
    watchlistSelect.appendChild(allSharesOption);

    // Add All Shares
    // (already added above)

    // Add Portfolio
    if (!watchlistSelect.querySelector('option[value="portfolio"]')) {
        const portfolioOption = document.createElement('option');
        portfolioOption.value = 'portfolio';
        portfolioOption.textContent = 'Portfolio';
        watchlistSelect.appendChild(portfolioOption);
    }

    // Add Cash & Assets
    if (!watchlistSelect.querySelector(`option[value="${CASH_BANK_WATCHLIST_ID}"]`)) {
        const cashBankOption = document.createElement('option');
        cashBankOption.value = CASH_BANK_WATCHLIST_ID;
        cashBankOption.textContent = 'Cash & Assets';
        watchlistSelect.appendChild(cashBankOption);
    }

    // Always insert Movers as 4th option (after All Shares, Portfolio, Cash & Assets), never from userWatchlists
    let moversOpt = document.createElement('option');
    moversOpt.value = '__movers';
    moversOpt.textContent = 'Movers';
    // Remove any existing Movers option
    Array.from(watchlistSelect.options).forEach(opt => {
        if (opt.value === '__movers') watchlistSelect.removeChild(opt);
    });
    if (watchlistSelect.children.length >= 3) {
        watchlistSelect.insertBefore(moversOpt, watchlistSelect.children[3]);
    } else {
        watchlistSelect.appendChild(moversOpt);
    }

    // Add all other user watchlists alphabetically after Movers (exclude Movers and other special IDs from this list)
    const __uw = getUserWatchlists();
    const filtered = Array.isArray(__uw) ? __uw.filter(wl => wl.id !== CASH_BANK_WATCHLIST_ID && wl.id !== 'portfolio' && wl.id !== '__movers' && wl.id !== ALL_SHARES_ID) : [];
    filtered.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
    filtered.forEach(watchlist => {
        // Defensive: avoid appending duplicate <option> elements with the same value
        try {
            if (watchlistSelect.querySelector(`option[value="${watchlist.id}"]`)) return;
        } catch (_) {}
        const option = document.createElement('option');
        option.value = watchlist.id;
        option.textContent = watchlist.name;
        watchlistSelect.appendChild(option);
    });

    // Attempt to select the watchlist specified in currentSelectedWatchlistIds.
    // This array should already contain the correct ID (e.g., the newly created watchlist's ID)
    // from loadUserWatchlistsAndSettings.
    const __selIds_renderSelect = getCurrentSelectedWatchlistIds();
    let desiredWatchlistId = (Array.isArray(__selIds_renderSelect) && __selIds_renderSelect.length === 1) ? __selIds_renderSelect[0] : '';
    // Highest precedence: persisted Movers intent when __forcedInitialMovers flag set
    try {
        if (__forcedInitialMovers) {
            desiredWatchlistId='__movers';
        } else {
            const persisted = localStorage.getItem('lastSelectedView');
            if (persisted === '__movers') desiredWatchlistId='__movers';
        }
    } catch(_) {}
    
    if (desiredWatchlistId && Array.from(watchlistSelect.options).some(opt => opt.value === desiredWatchlistId)) {
        watchlistSelect.value = desiredWatchlistId;
    } else {
        // Fallback: Prefer the last selected view from localStorage if valid, especially for 'portfolio'
        try {
            const lsView = localStorage.getItem('lastSelectedView');
            const hasLs = lsView && Array.from(watchlistSelect.options).some(opt => opt.value === lsView);
            if (hasLs) {
                // If persisted is movers, keep it even if data not yet loaded
                watchlistSelect.value = lsView;
                setCurrentSelectedWatchlistIds([lsView]);
                // Defer to ensure DOM elements are ready after renderSortSelect
                setTimeout(() => updateSortPickerButtonText(), 100);
                logDebug('UI Update: Watchlist select applied lastSelectedView from localStorage: ' + lsView);
            } else {
                watchlistSelect.value = ALL_SHARES_ID;
                setCurrentSelectedWatchlistIds([ALL_SHARES_ID]);
                // Defer to ensure DOM elements are ready after renderSortSelect
                setTimeout(() => updateSortPickerButtonText(), 100);
                try { localStorage.setItem('lastWatchlistSelection', JSON.stringify(getCurrentSelectedWatchlistIds())); } catch(_) {}
                logDebug('UI Update: Watchlist select defaulted to All Shares (no valid preference).');
            }
        } catch(e) {
            watchlistSelect.value = ALL_SHARES_ID;
            setCurrentSelectedWatchlistIds([ALL_SHARES_ID]);
            // Defer to ensure DOM elements are ready after renderSortSelect
            setTimeout(() => updateSortPickerButtonText(), 100);
            logDebug('UI Update: Watchlist select defaulted to All Shares due to error reading localStorage.');
        }
    }
    logDebug('UI Update: Watchlist select dropdown rendered. Selected value: ' + watchlistSelect.value);
    updateMainTitle(); // Update main title based on newly selected watchlist
    updateAddHeaderButton(); // Update the plus button context (and sidebar button context)
}

function renderSortSelect() {
    if (!sortSelect) { console.error('renderSortSelect: sortSelect element not found.'); return; }
    // Store the currently selected value before clearing (used as a fallback)
    const currentSelectedSortValue = sortSelect.value;

    // Set the initial placeholder text to "Sort List"
    sortSelect.innerHTML = '<option value="" disabled selected>Sort List</option>';

    // Only inject the ASX toggle option for stock and portfolio views, not for Cash
    try {
        const isCashView = getCurrentSelectedWatchlistIds().includes(CASH_BANK_WATCHLIST_ID);
        if (!isCashView) {
        const asxToggleOption = document.createElement('option');
        asxToggleOption.value = '__asx_toggle';
            asxToggleOption.textContent = (getAsxButtonsExpanded() ? 'ASX Codes — Hide' : 'ASX Codes — Show');
        asxToggleOption.dataset.toggle = 'asx';
        sortSelect.appendChild(asxToggleOption);
        }
    } catch (e) { /* ignore */ }

    // Main Watchlist - simplified labels and specific order (ASX Code first)
    const stockOptions = [
        // ASX Code
        { value: 'shareName-asc', text: 'ASX Code' },
        { value: 'shareName-desc', text: 'ASX Code' },
        // Daily Change (percentage)
        { value: 'percentageChange-desc', text: 'Daily Change' },
        { value: 'percentageChange-asc', text: 'Daily Change' },
    // Daily Change (dollar)
    { value: 'dayDollar-desc', text: 'Daily Change' },
    { value: 'dayDollar-asc', text: 'Daily Change' },
        // Star Rating
        { value: 'starRating-desc', text: 'Star Rating' },
        { value: 'starRating-asc', text: 'Star Rating' },
        // Dividends
        { value: 'dividendAmount-desc', text: 'Dividends' },
        { value: 'dividendAmount-asc', text: 'Dividends' },
        // Date Added
        { value: 'entryDate-desc', text: 'Date Added' },
        { value: 'entryDate-asc', text: 'Date Added' }
    ];

    // Portfolio view - simplified labels and specific order
    const portfolioOptions = [
        // ASX Code
        { value: 'shareName-asc', text: 'ASX Code' },
        { value: 'shareName-desc', text: 'ASX Code' },
        // Daily Change (percentage)
        { value: 'percentageChange-desc', text: 'Daily Change' },
        { value: 'percentageChange-asc', text: 'Daily Change' },
        // Daily P/L (dollar)
        { value: 'dayDollar-desc', text: 'Daily P/L' },
        { value: 'dayDollar-asc', text: 'Daily P/L' },
        // Current Value
        { value: 'totalDollar-desc', text: 'Current Value' },
        { value: 'totalDollar-asc', text: 'Current Value' },
        // Capital Gain
        { value: 'capitalGain-desc', text: 'Capital Gain' },
        { value: 'capitalGain-asc', text: 'Capital Gain' }
    ];


    // Cash & Assets view - simplified labels
    const cashOptions = [
        { value: 'name-asc', text: 'Asset Name' },
        { value: 'name-desc', text: 'Asset Name' },
        { value: 'totalDollar-desc', text: 'Current Value' },
        { value: 'totalDollar-asc', text: 'Current Value' }
    ];

    // Publish the authoritative option arrays so other modules (e.g., the Sort Picker)
    // can read the live source instead of parsing DOM options. This object is
    // refreshed each time renderSortSelect() runs so it always reflects current
    // view-specific ordering and any dynamic changes.
    try { window.SORT_SOURCE = { stockOptions: stockOptions.slice(), portfolioOptions: portfolioOptions.slice(), cashOptions: cashOptions.slice() }; } catch(_) {}

    let optionsToShow;
    let logMessage;
    let defaultSortValue;

    if (getCurrentSelectedWatchlistIds().includes('portfolio')) {
        optionsToShow = portfolioOptions;
        logMessage = 'Portfolio options';
        defaultSortValue = 'totalDollar-desc';
    } else if (getCurrentSelectedWatchlistIds().includes(CASH_BANK_WATCHLIST_ID)) {
        optionsToShow = cashOptions;
        logMessage = 'Cash Asset options';
        defaultSortValue = 'name-asc';
    } else {
        // Use Daily Change (percentage) as the default for general stock/watchlist views
        optionsToShow = stockOptions;
        logMessage = 'Stock options';
        defaultSortValue = 'percentageChange-desc';
    }

    optionsToShow.forEach(opt => {
        const optionElement = document.createElement('option');
        optionElement.value = opt.value;
        optionElement.textContent = opt.text;
        sortSelect.appendChild(optionElement);
    });
    logDebug(`Sort Select: Populated with ${logMessage}.`);

    // Prefer an explicitly set current sort from the centralized state if available.
    // Use the state getter to avoid stale globals. Only update the centralized
    // state when there is no authoritative value already present. This prevents
    // UI rebuilds from overwriting a saved sort and avoids render->sort->render recursion.
    const optionValues = Array.from(sortSelect.options).map(o => o.value);
    const activeSort = (typeof getCurrentSortOrder === 'function') ? getCurrentSortOrder() : (window.currentSortOrder || '');
    if (activeSort && optionValues.includes(activeSort)) {
        sortSelect.value = activeSort;
        logDebug('Sort: Applied currentSortOrder from state: ' + activeSort);
    } else if (currentSelectedSortValue && optionValues.includes(currentSelectedSortValue)) {
        sortSelect.value = currentSelectedSortValue;
        // Only set centralized state if none exists yet (avoid stomping a saved value)
        if (!activeSort) try { setCurrentSortOrder(currentSelectedSortValue); } catch(_) {}
        logDebug('Sort: Applied previously selected sort order to UI: ' + currentSelectedSortValue);
    } else {
        // If not valid or no previous, apply the default for the current view type
        sortSelect.value = defaultSortValue;
        if (!activeSort) try { setCurrentSortOrder(defaultSortValue); } catch(_) {}
        logDebug('Sort: No valid saved sort order or not applicable, defaulting to: ' + defaultSortValue);
    }

    logDebug('UI Update: Sort select rendered. Sort select disabled: ' + sortSelect.disabled);
    updateSortIcon();
}


function openWatchlistPicker() {
    if (!watchlistPickerModal || !watchlistPickerList) {
        console.warn('Watchlist Picker: Modal elements not found. modal?', !!watchlistPickerModal, ' list?', !!watchlistPickerList);
        return;
    }
    // Strong de-dup guard: if already visible or already on stack, just ensure it's visible without pushing
    try {
        const isVisible = watchlistPickerModal.style.display === 'flex' || watchlistPickerModal.classList.contains('show');
        const alreadyOnStack = (typeof stackHasModal === 'function') ? stackHasModal(watchlistPickerModal) : false;
        if (isVisible || alreadyOnStack) {
            try { if (window.UI && window.UI.showModalNoHistory) window.UI.showModalNoHistory(watchlistPickerModal); else showModalNoHistory(watchlistPickerModal); } catch(_) { watchlistPickerModal.style.display = 'flex'; }
            console.debug('[WatchlistPicker] Already open/on stack; showing without new push.');
            return;
        }
    } catch(_) {}
    console.log('[WatchlistPicker] Opening picker...');
    watchlistPickerList.innerHTML = '';

    const specialWatchlistOrder = [
        { id: ALL_SHARES_ID, name: 'All Shares', icon: 'fa-globe' },
        { id: 'portfolio', name: 'Portfolio', icon: 'fa-briefcase' },
        { id: CASH_BANK_WATCHLIST_ID, name: 'Cash & Assets', icon: 'fa-dollar-sign' },
        { id: '__movers', name: 'Movers', icon: 'fa-chart-line' }
    ];

    const specialIds = specialWatchlistOrder.map(sw => sw.id);

    const __uw2 = getUserWatchlists();
    // Icon pool for user watchlists — will be assigned deterministically per id so icons stay stable
    const watchlistIconPool = ['fa-list-alt','fa-folder-open','fa-bookmark','fa-star','fa-user','fa-users','fa-layer-group','fa-tags','fa-gem','fa-briefcase'];
    const pickIconForId = (id) => {
        try {
            const s = String(id || '');
            let h = 0;
            for (let i = 0; i < s.length; i++) {
                h = ((h << 5) - h) + s.charCodeAt(i);
                h |= 0;
            }
            return watchlistIconPool[Math.abs(h) % watchlistIconPool.length];
        } catch (_) { return 'fa-list-alt'; }
    };

    const userCreatedWatchlists = (__uw2||[])
        .filter(wl => !specialIds.includes(wl.id))
        .sort((a, b) => a.name.localeCompare(b.name))
        .map(wl => ({ ...wl, icon: pickIconForId(wl.id) }));

    let finalWatchlistItems = [...specialWatchlistOrder, ...userCreatedWatchlists];

    // Conditionally remove Movers if no data
    const hasMoversData = (globalAlertSummary && globalAlertSummary.totalCount > 0) ||
                          (window.__lastMoversSnapshot && window.__lastMoversSnapshot.entries && window.__lastMoversSnapshot.entries.length > 0);
    if (!hasMoversData) {
        finalWatchlistItems = finalWatchlistItems.filter(it => it.id !== '__movers');
    }

    finalWatchlistItems.forEach(it => {
        const div = document.createElement('div');
        const __selIds_picker = getCurrentSelectedWatchlistIds();
        // Normalize IDs to strings, trim whitespace and lowercase to avoid mismatches
        const activeId = Array.isArray(__selIds_picker) && __selIds_picker[0] ? String(__selIds_picker[0]).trim().toLowerCase() : '';
        const itemId = it.id ? String(it.id).trim().toLowerCase() : '';
        const isActive = activeId && itemId && activeId === itemId;
        div.className = 'picker-item' + (isActive ? ' active' : '');
        div.innerHTML = `
            <div class="picker-item-content">
                <i class="fas ${it.icon || 'fa-list-alt'}"></i>
                <span>${it.name}</span>
            </div>
        `;
        div.tabIndex = 0;
        div.setAttribute('role', 'button');
        div.setAttribute('aria-label', it.name);

        div.onclick = () => {
            console.log('[WatchlistPicker] Selecting watchlist', it.id);
            // Push previous selection for shallow back
            try { const prev = Array.isArray(getCurrentSelectedWatchlistIds()) ? getCurrentSelectedWatchlistIds().slice(0) : []; pushAppStateEntry('watchlist', prev); } catch(_) {}
            // Normalize stored id to the canonical form used elsewhere
            const canonicalId = it.id ? String(it.id).trim() : it.id;
            setCurrentSelectedWatchlistIds([canonicalId]);
            // Create a browser history entry so hardware/back triggers our popstate handler
            try { if (typeof pushAppState === 'function') pushAppState({ watchlist: it.id }, '', '#watchlist'); } catch(_) {}
            try { localStorage.setItem('lastWatchlistSelection', JSON.stringify(getCurrentSelectedWatchlistIds())); } catch (_) { }
            if (watchlistSelect) try { watchlistSelect.value = canonicalId; } catch(_) { watchlistSelect.value = it.id; }
            // If the watchlist picker modal is open, update the active class on items immediately
            try {
                const listEl = document.getElementById('watchlistPickerList');
                if (listEl && listEl.children && listEl.children.length > 0) {
                    Array.from(listEl.children).forEach(child => {
                        try {
                            const span = child.querySelector('.picker-item-content span');
                            const txt = span ? String(span.textContent || '').trim().toLowerCase() : '';
                            const candidate = String(it.name || '').trim().toLowerCase();
                            if (txt && candidate && txt === candidate) {
                                child.classList.add('active');
                            } else {
                                child.classList.remove('active');
                            }
                        } catch(_) {}
                    });
                }
            } catch(_) {}
            try { setLastSelectedView(it.id); } catch (e) { }
            try { if (typeof saveLastSelectedWatchlistIds === 'function') { saveLastSelectedWatchlistIds(getCurrentSelectedWatchlistIds()); } } catch (e) { console.warn('Watchlist Picker: Failed to save selection to Firestore', e); }

            if (it.id === '__movers') {
                updateMainTitle('Movers');
            } else {
                updateMainTitle();
            }
            try {
                // Rebuild sort options for the newly selected watchlist and apply a validated sort
                try { renderSortSelect(); } catch(_) {}
                try { 
                    // Defer to ensure DOM elements are ready after renderSortSelect
                    setTimeout(() => updateSortPickerButtonText(), 100); 
                } catch(_) {}
                const availableOptionValues = Array.from(sortSelect ? sortSelect.options : []).map(o => o.value);
                const watchlistSortOrder = getSortOrderForWatchlist(canonicalId);
                if (watchlistSortOrder && availableOptionValues.includes(watchlistSortOrder)) {
                    try { setCurrentSortOrder(watchlistSortOrder); if (sortSelect) sortSelect.value = watchlistSortOrder; updateSortIcon(); } catch(_) {}
                    logDebug('[WatchlistPicker] Applied saved per-watchlist sort for ' + canonicalId + ': ' + watchlistSortOrder);
                } else {
                    const def = (canonicalId === CASH_BANK_WATCHLIST_ID) ? 'name-asc' : (canonicalId === 'portfolio' ? 'totalDollar-desc' : 'percentageChange-desc');
                    const chosen = availableOptionValues.includes(def) ? def : (availableOptionValues[0] || def);
                    try { setCurrentSortOrder(chosen); if (sortSelect) sortSelect.value = chosen; updateSortIcon(); } catch(_) {}
                    logDebug('[WatchlistPicker] Applied fallback/default sort for ' + canonicalId + ': ' + chosen);
                    // Persist fallback so this watchlist remembers the chosen default
                    try {
                        setWatchlistSortOrder(canonicalId, chosen);
                        try { robustSaveSortOrder(chosen); } catch(_) {}
                        logDebug('[WatchlistPicker] Persisted fallback sort for ' + canonicalId + ': ' + chosen);
                    } catch (persistErr) {
                        console.warn('[WatchlistPicker] Failed to persist fallback sort for ' + canonicalId, persistErr);
                    }
                }
            } catch (e) { console.warn('WatchlistPicker: Sort restoration failed', e); }

            try { sortShares(); } catch (e) { console.warn('WatchlistPicker: sortShares failed', e); }
            // Ensure the main view scrolls to top after programmatic watchlist selection
            try { if (window.scrollMainToTop) window.scrollMainToTop(); else scrollMainToTop(); } catch(_) {}
            try { enforceMoversVirtualView(); } catch (e) { console.warn('WatchlistPicker: enforceMoversVirtualView failed', e); }
            if (it.id === '__movers' && typeof debugMoversConsistency === 'function') {
                try { debugMoversConsistency({ includeLists: true }); } catch (_) { }
            }

            try { updateAddHeaderButton(); updateSidebarAddButtonContext(); } catch (e) { }
            toggleCodeButtonsArrow();
            try { hideModal(watchlistPickerModal); } catch (_) { watchlistPickerModal.classList.add('app-hidden'); watchlistPickerModal.style.display = 'none'; }
            if (dynamicWatchlistTitle) dynamicWatchlistTitle.setAttribute('aria-expanded', 'false');
            if (dynamicWatchlistTitleText) dynamicWatchlistTitleText.focus();
        };
        div.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); div.click(); } };
        watchlistPickerList.appendChild(div);
    });

    try {
        // Only push if not already on stack
        if (!(typeof stackHasModal === 'function' && stackHasModal(watchlistPickerModal))) {
            showModal(watchlistPickerModal);
        } else {
            if (window.UI && window.UI.showModalNoHistory) window.UI.showModalNoHistory(watchlistPickerModal); else showModalNoHistory(watchlistPickerModal);
        }
    } catch (e) {
        watchlistPickerModal.classList.remove('app-hidden');
        watchlistPickerModal.style.display = 'flex';
    }
    console.log('[WatchlistPicker] Modal shown. Item count:', watchlistPickerList.children.length);
}
// moved to uiService.toggleCodeButtonsArrow()
if (dynamicWatchlistTitleText || dynamicWatchlistTitle) {
    const openPicker = () => {
        // If the sidebar (hamburger menu) is open, close it and do not open the picker on this click
        if (appSidebar && appSidebar.classList.contains('open')) {
            if (typeof toggleAppSidebar === 'function') toggleAppSidebar(false);
            return;
        }
        openWatchlistPicker();
        if (dynamicWatchlistTitle) dynamicWatchlistTitle.setAttribute('aria-expanded','true');
        setTimeout(()=>{
            const listEl = document.getElementById('watchlistPickerList');
            const first = listEl && listEl.querySelector('.picker-item');
            if (first) first.focus();
        },30);
    };
    // Bind to the narrow span to keep the click target tight
    const clickable = dynamicWatchlistTitleText || dynamicWatchlistTitle;
    if (clickable && clickable.getAttribute('data-picker-bound') !== 'true') {
        clickable.addEventListener('click', openPicker);
        clickable.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); openPicker(); } });
        clickable.setAttribute('role','button');
        clickable.setAttribute('data-picker-bound','true');
    }
}
if (closeWatchlistPickerBtn && !closeWatchlistPickerBtn.getAttribute('data-picker-close-bound')) {
    closeWatchlistPickerBtn.addEventListener('click', ()=>{
        const modalEl=document.getElementById('watchlistPickerModal');
        if (modalEl) { try { hideModal(modalEl); } catch(_) { modalEl.classList.add('app-hidden'); } }
        if (dynamicWatchlistTitle) dynamicWatchlistTitle.setAttribute('aria-expanded','false');
        if (dynamicWatchlistTitleText) dynamicWatchlistTitleText.focus();
    });
    closeWatchlistPickerBtn.setAttribute('data-picker-close-bound','true');
}
if (!window.__watchlistPickerGlobalBound) {
    window.__watchlistPickerGlobalBound = true;
    window.addEventListener('click', e=>{ if(e.target===watchlistPickerModal){ try { hideModal(watchlistPickerModal); } catch(_) { watchlistPickerModal.classList.add('app-hidden'); } if (dynamicWatchlistTitle) dynamicWatchlistTitle.setAttribute('aria-expanded','false'); if (dynamicWatchlistTitleText) dynamicWatchlistTitleText.focus(); } });
    window.addEventListener('keydown', e=>{ if(e.key==='Escape' && watchlistPickerModal && watchlistPickerModal.style.display!=='none' && !watchlistPickerModal.classList.contains('app-hidden')){ try { hideModal(watchlistPickerModal); } catch(_) { watchlistPickerModal.classList.add('app-hidden'); } if (dynamicWatchlistTitle) dynamicWatchlistTitle.setAttribute('aria-expanded','false'); if (dynamicWatchlistTitleText) dynamicWatchlistTitleText.focus(); } });
}

// Wrap loadUserWatchlistsAndSettings to refresh new UI parts after data load
const __origLoadUserWatchlistsAndSettings = loadUserWatchlistsAndSettings;
loadUserWatchlistsAndSettings = async function() {
    await __origLoadUserWatchlistsAndSettings();
    updateMainTitle();
    renderSortSelect();
    toggleCodeButtonsArrow();
    // Post-load Movers enforcement: if persisted as lastSelectedView but not active (race conditions), activate now
    try {
        const wantMovers = localStorage.getItem('lastSelectedView') === '__movers';
        const haveMovers = getCurrentSelectedWatchlistIds() && getCurrentSelectedWatchlistIds()[0] === '__movers';
        if (wantMovers && !haveMovers) {
            try { const prev = Array.isArray(getCurrentSelectedWatchlistIds()) ? getCurrentSelectedWatchlistIds().slice(0) : []; if (prev[0] !== '__movers') pushAppStateEntry('watchlist', prev); } catch(_) {}
            setCurrentSelectedWatchlistIds(['__movers']);
            const sel = typeof watchlistSelect !== 'undefined' ? watchlistSelect : document.getElementById('watchlistSelect');
            if (sel) sel.value = '__movers';
            if (typeof sortShares === 'function') sortShares();
            // FIX: Update ASX button state after programmatic watchlist change
            try { toggleCodeButtonsArrow(); } catch (e) { console.warn('Movers restore: toggleCodeButtonsArrow failed', e); }
            try { scrollMainToTop(); } catch(_) {}
            enforceMoversVirtualView(true);
            console.log('[Movers restore][post-user-data] enforced after loadUserWatchlistsAndSettings');
        }
    } catch(e) { console.warn('[Movers restore][post-user-data] failed', e); }
};
// Late-binding helper to ensure header interactions are wired when DOM is ready
function bindHeaderInteractiveElements() {
    const titleEl = document.getElementById('dynamicWatchlistTitle');
    const textEl = document.getElementById('dynamicWatchlistTitleText');
    // Bind only to the inner span for a narrower click target
    const clickable = textEl || titleEl;
    if (clickable && clickable.getAttribute('data-picker-bound') !== 'true') {
        const openPicker = () => {
            openWatchlistPicker();
            if (titleEl) titleEl.setAttribute('aria-expanded','true');
            setTimeout(()=>{
                const listEl = document.getElementById('watchlistPickerList');
                const first = listEl && listEl.querySelector('.picker-item');
                if (first) first.focus();
            },30);
        };
        clickable.addEventListener('click', openPicker);
        clickable.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); openPicker(); } });
        clickable.setAttribute('role','button');
        clickable.setAttribute('data-picker-bound','true');
    }
    const closeBtn = document.getElementById('closeWatchlistPickerBtn');
    const pickerModal = document.getElementById('watchlistPickerModal');
    if (closeBtn && closeBtn.getAttribute('data-close-bound') !== 'true') {
        closeBtn.addEventListener('click', ()=>{ if (pickerModal) pickerModal.classList.add('app-hidden'); if (titleEl) { titleEl.setAttribute('aria-expanded','false'); } if (textEl) textEl.focus(); });
        closeBtn.setAttribute('data-close-bound','true');
    }
}

/**
 * Renders the watchlist based on the currentSelectedWatchlistIds. (1)
 * Optimized to update existing elements rather than recreating them, reducing flickering.
 */
function renderWatchlist() {
    logDebug('DEBUG: renderWatchlist called. Current selected watchlist ID: ' + currentSelectedWatchlistIds[0]);

    // Allow rendering immediately if we restored stale snapshot data (SWR flow).
    // Otherwise, prevent partial renders until the first successful live-price fetch
    // has been applied. This avoids showing partially-populated rows/cards.
    if (!window.__firstLivePricesApplied && !window.__usedStaleData) {
        logDebug('Render: Skipping renderWatchlist until first live prices are applied (no stale snapshot).');
        return;
    }

    // Ensure view mode is correct before rendering - use centralized manager
    try {
        // If view mode is not initialized or seems wrong, try recovery
        if (!viewModeInitialized || !currentMobileViewMode) {
            recoverViewMode('render_watchlist').then(recovered => {
                if (!recovered) {
                    // Last resort: ensure we have a valid mode
                    setMobileViewMode('default', 'render_watchlist_fallback');
                }
            }).catch(error => {
                console.warn('View Mode: Recovery failed in renderWatchlist:', error);
                setMobileViewMode('default', 'render_watchlist_fallback');
            });
        } else {
            // Re-apply current mode to ensure DOM is correct
            const container = getMobileShareCardsContainer();
            if (container) {
                container.classList.remove('compact-view');
                if (currentMobileViewMode === 'compact') {
                    container.classList.add('compact-view');
                    logDebug('Render: Re-applied COMPACT view mode to container');
                } else {
                    logDebug('Render: Re-applied DEFAULT view mode to container');
                }
            }
        }
    } catch (error) {
        console.warn('Render: Failed to ensure view mode before rendering:', error);
        // Emergency recovery
        recoverViewMode('render_watchlist_error').catch(error => {
            console.warn('View Mode: Emergency recovery failed:', error);
        });
    }

    // If first load and user restored to movers, enforce immediately after minimal delay
    try {
        if (!window.__moversInitialEnforced && getCurrentSelectedWatchlistIds() && getCurrentSelectedWatchlistIds()[0] === '__movers') {
            window.__moversInitialEnforced = true;
            setTimeout(()=>{ try { enforceMoversVirtualView(); } catch(e){ console.warn('Initial movers enforce failed', e); } }, 150);
        }
    } catch(_) {}

    // --- Compact View Display Logic ---
    const isCompactView = currentMobileViewMode === 'compact';
    const isMobileView = window.innerWidth <= 768;
    const mobileContainer = getMobileShareCardsContainer();


    if (isCompactView) {
        // Compact view: show card container as grid, hide table
        if (mobileContainer) {
            mobileContainer.style.display = 'grid';
        }
        if (tableContainer) {
            tableContainer.style.display = 'none';
        }
    } else if (isMobileView) {
        // Mobile, not compact: show card container as flex, hide table
        if (mobileContainer) {
            mobileContainer.style.display = 'flex';
        }
        if (tableContainer) {
            tableContainer.style.display = 'none';
        }
    } else {
        // Desktop: show table, hide card container
        if (mobileContainer) {
            mobileContainer.style.display = 'none';
        }
        if (tableContainer) {
            tableContainer.style.display = '';
        }
    }

    const selectedWatchlistId = getCurrentSelectedWatchlistIds()[0];

    // Hide both sections initially
    stockWatchlistSection.classList.add('app-hidden');
    cashAssetsSection.classList.add('app-hidden');

    // Clear previous content (only for elements that will be conditionally displayed)
    // We will now manage individual row/card updates, so don't clear the whole tbody/container yet.
    // However, for switching between stock/cash, we might still need to clear.
    if (selectedWatchlistId === 'portfolio') {
        // Portfolio View: hide stock and cash sections, show/create portfolio section and render
        if (stockWatchlistSection) stockWatchlistSection.classList.add('app-hidden');
        if (cashAssetsSection) cashAssetsSection.classList.add('app-hidden');
        let portfolioSection = document.getElementById('portfolioSection');
        if (!portfolioSection) {
            portfolioSection = document.createElement('div');
            portfolioSection.id = 'portfolioSection';
            portfolioSection.className = 'portfolio-section';
            // Intentionally do not insert a static title here; main title is controlled globally elsewhere.
            portfolioSection.innerHTML = '<div id="portfolioListContainer">Loading portfolio...</div>';
            if (mainContainer) mainContainer.appendChild(portfolioSection);
        }
        portfolioSection.style.display = 'block';
        // Hide stock-specific containers
        if (tableContainer) tableContainer.style.display = 'none';
        const mobileContainer = getMobileShareCardsContainer();
        if (mobileContainer) mobileContainer.style.display = 'none';
        // Update title
    // Title handled by updateMainTitle
    // Show sort dropdown in portfolio too
    sortSelect.classList.remove('app-hidden');
        refreshLivePricesBtn.classList.add('app-hidden');
        const toggleBtn = getToggleCompactViewBtn();
        if (toggleBtn) toggleBtn.classList.add('app-hidden');
        exportWatchlistBtn.classList.remove('app-hidden'); // Allow export if desired
        // Render the portfolio list
        if (typeof renderPortfolioList === 'function') {
            renderPortfolioList();
        }
    // Update sort options and alerts for portfolio view as well
    try { renderSortSelect(); } catch(e) {}
    try { updateTargetHitBanner(); } catch(e) {}
        // Also render ASX code buttons for portfolio shares
        if (typeof renderAsxCodeButtons === 'function') {
            renderAsxCodeButtons();
        }
        adjustMainContentPadding();
        return;
    } else if (selectedWatchlistId !== CASH_BANK_WATCHLIST_ID) {
    // Hide portfolio section if it exists from previous view
    const existingPortfolio = document.getElementById('portfolioSection');
    if (existingPortfolio) existingPortfolio.style.display='none';
        // Stock Watchlist Logic
        stockWatchlistSection.classList.remove('app-hidden');
        // IMPORTANT: Also clear any inline display:none applied by showPortfolioView
        if (typeof stockWatchlistSection.style !== 'undefined') {
            stockWatchlistSection.style.display = '';
        }
        const selectedWatchlist = userWatchlists.find(wl => wl.id === selectedWatchlistId);
        if (selectedWatchlistId === ALL_SHARES_ID) {
            // Title handled by updateMainTitle
        } else if (selectedWatchlist) {
            // Title handled by updateMainTitle
        } else if (selectedWatchlistId === 'portfolio') {
            // Title handled by updateMainTitle
        } else {
            // Title handled by updateMainTitle
        }

        // Show stock-specific UI elements
        sortSelect.classList.remove('app-hidden');
        refreshLivePricesBtn.classList.remove('app-hidden');
        const toggleBtn = getToggleCompactViewBtn();
        if (toggleBtn) toggleBtn.classList.remove('app-hidden');
        exportWatchlistBtn.classList.remove('app-hidden');
        // startLivePriceUpdates(); // Removed this line to prevent multiple intervals
        updateAddHeaderButton();

        const isMobileView = window.innerWidth <= 768;
        let sharesToRender = [];

        if (selectedWatchlistId === '__movers') {
            // Fresh compute of movers (preferred) with fallback to last snapshot, then all shares if still empty
            let moversEntries = [];
            try { if (typeof applyGlobalSummaryFilter === 'function') moversEntries = applyGlobalSummaryFilter({ silent: true, computeOnly: true }) || []; } catch(e){ console.warn('Render movers: compute failed', e); }
            if ((!moversEntries || moversEntries.length === 0) && window.__lastMoversSnapshot && Array.isArray(window.__lastMoversSnapshot.entries)) {
                moversEntries = window.__lastMoversSnapshot.entries;
            }

            const base = dedupeSharesById(allSharesData);

            if (moversEntries && moversEntries.length > 0) {
                // Use computed/filtered movers
                const codeSet = new Set(moversEntries.map(e=>e.code));
                console.log('[MOVERS DEBUG] Movers entries:', moversEntries.length, 'codes:', Array.from(codeSet));
                console.log('[MOVERS DEBUG] Available share codes:', base.map(s => s.shareName).filter(Boolean));

                sharesToRender = base.filter(s => {
                    if (!s.shareName) return false;
                    const shareCode = s.shareName.toUpperCase();
                    const hasMatch = codeSet.has(shareCode);
                    if (!hasMatch) {
                        console.log('[MOVERS DEBUG] Share', shareCode, 'not in movers list');
                    }
                    return hasMatch;
                });

                console.log('[MOVERS DEBUG] Filtered movers shares:', sharesToRender.length, 'from', moversEntries.length, 'entries');
                logDebug('Render: Displaying Movers computed ('+sharesToRender.length+' items, codes='+codeSet.size+').');
            } else {
                // No movers data available, show top 10 shares by market cap or alphabetically
                sharesToRender = base.slice(0, 10); // Show first 10 shares as fallback
                logDebug('Render: Displaying fallback movers (top 10 shares, '+sharesToRender.length+' items) - no live data available.');
            }

            // If still empty but we have shares, schedule a one-time re-render retry
            if (sharesToRender.length === 0 && base.length > 0 && !window.__moversRenderRetry) {
                window.__moversRenderRetry = setTimeout(()=>{
                    window.__moversRenderRetry = null;
                    if (currentSelectedWatchlistIds && currentSelectedWatchlistIds[0] === '__movers') {
                        try { sortShares(); } catch(e){ console.warn('Movers re-render retry failed', e); }
                    }
                }, 900);
            }
        } else if (selectedWatchlistId === ALL_SHARES_ID) {
            sharesToRender = dedupeSharesById(allSharesData);
            logDebug('Render: Displaying all shares (from ALL_SHARES_ID in currentSelectedWatchlistIds).');
        } else if (getCurrentSelectedWatchlistIds().length === 1) {
            sharesToRender = dedupeSharesById(allSharesData).filter(share => getCurrentSelectedWatchlistIds().some(id => shareBelongsTo(share, id)));
            logDebug('Render: Displaying shares from watchlist: ' + selectedWatchlistId);
        } else {
            logDebug('Render: No specific stock watchlists selected or multiple selected, showing empty state.');
        }

        // --- Optimized DOM Update for Shares ---
        const existingTableRows = shareTableBody ? Array.from(shareTableBody.children) : [];
        const container = getMobileShareCardsContainer();
        const existingMobileCards = container ? Array.from(container.children) : [];
        const existingAsxButtons = asxCodeButtonsContainer ? Array.from(asxCodeButtonsContainer.children) : [];

        const newShareIds = new Set(sharesToRender.map(s => s.id));
        const newAsxCodes = new Set(sharesToRender.map(s => s.shareName.trim().toUpperCase()));

        // Remove old rows/cards/buttons that are no longer in the filtered list
        existingTableRows.forEach(row => {
            if (!newShareIds.has(row.dataset.docId)) {
                row.remove();
            }
        });
        existingMobileCards.forEach(card => {
            if (!newShareIds.has(card.dataset.docId)) {
                card.remove();
            }
        });
        // Clear existing rows and cards before re-rendering in sorted order
        // This ensures the order is always correct based on the sorted `sharesToRender` array
        if (shareTableBody) {
            shareTableBody.innerHTML = '';
        }
        const mobileContainer = getMobileShareCardsContainer();
        if (mobileContainer) {
            mobileContainer.innerHTML = '';
        }

        // Re-add shares to the UI in their sorted order

        if (sharesToRender.length > 0) {
            sharesToRender.forEach(share => {
                if (tableContainer && tableContainer.style.display !== 'none') {
                    addShareToTable(share);
                }
                if (mobileContainer && mobileContainer.style.display !== 'none') {
                    addShareToMobileCards(share);
                }
            });
        } else {
            // Handle empty message if no shares to render in current view
            const emptyWatchlistMessage = document.createElement('p');
            emptyWatchlistMessage.textContent = 'No shares found for the selected watchlists. Add a new share to get started!';
            emptyWatchlistMessage.style.textAlign = 'center';
            emptyWatchlistMessage.style.padding = '20px';
            emptyWatchlistMessage.style.color = 'var(--ghosted-text)';
            
            if (tableContainer && tableContainer.style.display !== 'none') {
                const td = document.createElement('td');
                td.colSpan = 5; // Adjusted after removing Entry Price column
                td.appendChild(emptyWatchlistMessage);
                const tr = document.createElement('tr');
                tr.classList.add('empty-message-row'); // Add class to easily target for removal later
                tr.appendChild(td);
                shareTableBody.appendChild(tr);
            }
            if (mobileContainer && mobileContainer.style.display !== 'none') {
                mobileContainer.appendChild(emptyWatchlistMessage.cloneNode(true));
            }
        }
        
    // Re-render ASX Code Buttons separately
    renderAsxCodeButtons();

    // Update ASX button toggle visibility based on whether buttons are available
    // Delay slightly to ensure buttons are actually rendered to DOM before checking
    setTimeout(() => {
        try { applyAsxButtonsState(); } catch(e) { console.warn('ASX Button State: applyAsxButtonsState failed', e); }
    }, 10);

    // UX: Ensure main content is scrolled to top after rendering to keep focus on the updated content
    try { scrollMainToTop(); } catch(_) {}

        // AFTER primary render: enforce target-hit highlight on any rows/cards that might have missed initial application
        try {
            enforceTargetHitStyling();
        } catch(e) { console.warn('Target Alert: enforceTargetHitStyling failed post render', e); }

    } else {
        // Cash & Assets section Logic
        cashAssetsSection.classList.remove('app-hidden');
    const existingPortfolio2 = document.getElementById('portfolioSection');
    if (existingPortfolio2) existingPortfolio2.style.display='none';
    // Title handled by updateMainTitle
        renderCashCategories();
        sortSelect.classList.remove('app-hidden');
        refreshLivePricesBtn.classList.add('app-hidden');
        const toggleBtn = getToggleCompactViewBtn();
        if (toggleBtn) toggleBtn.classList.add('app-hidden');
        asxCodeButtonsContainer.classList.add('app-hidden'); // Ensure hidden in cash view
    // Hide in cash view via inline style to avoid class conflicts
    if (targetHitIconBtn) targetHitIconBtn.style.display = 'none';
        exportWatchlistBtn.classList.add('app-hidden');
        stopLivePriceUpdates();
        updateAddHeaderButton();
        // Ensure stock-specific containers are hidden when showing cash assets
        if (tableContainer) tableContainer.style.display = 'none';
        const mobileContainer = getMobileShareCardsContainer();
        if (mobileContainer) mobileContainer.style.display = 'none';
    }
    // Update sort dropdown options based on selected watchlist type
    renderSortSelect(); // Moved here to ensure it updates for both stock and cash views
    try { 
        // Defer to ensure DOM elements are ready after renderSortSelect
        setTimeout(() => updateSortPickerButtonText(), 100); 
    } catch(e) {}
    updateMainButtonsState(!!currentUserId); // Ensure button states (like Edit Watchlist) are correct for the current view
    adjustMainContentPadding();
    try { updateMainTitle(); } catch(e) {}
    try { ensureTitleStructure(); } catch(e) {}
    try { updateTargetHitBanner(); } catch(e) {}
}

// Expose renderWatchlist to window for use by other modules
window.renderWatchlist = renderWatchlist;

// Safety net function definition is provided later in the file; duplicate removed to resolve syntax error.
function renderAsxCodeButtons() {
    if (!asxCodeButtonsContainer) { console.error('renderAsxCodeButtons: asxCodeButtonsContainer element not found.'); return; }
    asxCodeButtonsContainer.innerHTML = '';
    const uniqueAsxCodes = new Set();

    let sharesForButtons = [];
    const __selIds_asx = getCurrentSelectedWatchlistIds();
    const __shares_asx = getAllSharesData();
    console.log('[ASX Debug] renderAsxCodeButtons - selected IDs:', __selIds_asx);
    console.log('[ASX Debug] renderAsxCodeButtons - ALL_SHARES_ID:', ALL_SHARES_ID);
    console.log('[ASX Debug] renderAsxCodeButtons - includes ALL_SHARES_ID:', __selIds_asx.includes(ALL_SHARES_ID));
    console.log('[ASX Debug] renderAsxCodeButtons - all shares count:', __shares_asx.length);

    if (__selIds_asx.includes(ALL_SHARES_ID)) {
        sharesForButtons = dedupeSharesById(__shares_asx);
        console.log('[ASX Debug] renderAsxCodeButtons - using ALL_SHARES_ID path, shares count:', sharesForButtons.length);
    } else if (__selIds_asx.includes('__movers')) {
        // Special handling for movers watchlist - compute movers dynamically
        let moversEntries = [];
        try {
            if (typeof applyGlobalSummaryFilter === 'function') {
                moversEntries = applyGlobalSummaryFilter({ silent: true, computeOnly: true }) || [];
            }
            if ((!moversEntries || moversEntries.length === 0) && window.__lastMoversSnapshot && Array.isArray(window.__lastMoversSnapshot.entries)) {
                moversEntries = window.__lastMoversSnapshot.entries;
            }
        } catch(e) {
            console.warn('renderAsxCodeButtons: Movers computation failed', e);
        }

        if (moversEntries && moversEntries.length > 0) {
            // Use computed/filtered movers
            const codeSet = new Set(moversEntries.map(e=>e.code));
            sharesForButtons = dedupeSharesById(__shares_asx).filter(s => s.shareName && codeSet.has(s.shareName.toUpperCase()));
            console.log('[ASX Debug] renderAsxCodeButtons - using __movers path, movers count:', moversEntries.length, 'shares count:', sharesForButtons.length);
        } else {
            // No movers data available, show top 10 shares as fallback
            sharesForButtons = dedupeSharesById(__shares_asx).slice(0, 10);
            console.log('[ASX Debug] renderAsxCodeButtons - using __movers fallback, shares count:', sharesForButtons.length);
        }
    } else {
        sharesForButtons = dedupeSharesById(__shares_asx).filter(share => {
            const belongsToAny = __selIds_asx.some(id => shareBelongsTo(share, id));
            if (!belongsToAny && DEBUG_MODE) {
                console.log('[ASX Debug] Share', share.shareName, 'does not belong to any selected watchlist:', __selIds_asx);
                console.log('  Share watchlistIds:', share.watchlistIds, 'share.watchlistId:', share.watchlistId);
            }
            return belongsToAny;
        });
        console.log('[ASX Debug] renderAsxCodeButtons - using filtered path, shares count:', sharesForButtons.length);
    }

    sharesForButtons.forEach(share => {
        console.log('[ASX Debug] renderAsxCodeButtons - checking share:', share.id, 'shareName:', share.shareName, 'has shareName:', !!share.shareName, 'shareName type:', typeof share.shareName, 'trimmed:', share.shareName ? share.shareName.trim() : 'N/A');
        if (share.shareName && typeof share.shareName === 'string' && share.shareName.trim() !== '') {
                uniqueAsxCodes.add(share.shareName.trim().toUpperCase());
        }
    });

    console.log('[ASX Debug] renderAsxCodeButtons - unique ASX codes found:', uniqueAsxCodes.size, Array.from(uniqueAsxCodes));

    if (uniqueAsxCodes.size === 0) {
        // Let centralized state handler control visibility; just clear contents
        logDebug('UI: No unique ASX codes found for current view.');
        applyAsxButtonsState();
        return;
    }
    const sortedAsxCodes = Array.from(uniqueAsxCodes).sort();
    sortedAsxCodes.forEach(asxCode => {
        const button = document.createElement('button');
        button.className = 'asx-code-btn';
        button.textContent = asxCode;
        button.dataset.asxCode = asxCode;

        // Determine price change class for the button
        let buttonPriceChangeClass = '';
        const livePriceData = livePrices[asxCode.toUpperCase()];
        if (livePriceData) {
            // Fallback logic: use current values else last fetched values
            const latestLive = (livePriceData.live !== null && !isNaN(livePriceData.live)) ? livePriceData.live : (livePriceData.lastLivePrice ?? null);
            const latestPrev = (livePriceData.prevClose !== null && !isNaN(livePriceData.prevClose)) ? livePriceData.prevClose : (livePriceData.lastPrevClose ?? null);
            if (latestLive !== null && latestPrev !== null && !isNaN(latestLive) && !isNaN(latestPrev)) {
                const change = latestLive - latestPrev;
                if (change > 0) buttonPriceChangeClass = 'positive'; else if (change < 0) buttonPriceChangeClass = 'negative'; else buttonPriceChangeClass = 'neutral';
            }
        }
        // Apply color class based on price change
        if (buttonPriceChangeClass) {
            button.classList.add(buttonPriceChangeClass);
        }
        // Additional context class when in portfolio for stronger theme coloring
        const __selIds_renderButtons = getCurrentSelectedWatchlistIds();
        if (Array.isArray(__selIds_renderButtons) && __selIds_renderButtons.length === 1 && __selIds_renderButtons[0] === 'portfolio') {
            button.classList.add('portfolio-context');
        }

        // Add target-hit-border class if this ASX code has a target hit AND not dismissed
        const __live_renderButtons = getLivePrices();
        const livePriceDataForButton = __live_renderButtons ? __live_renderButtons[asxCode.toUpperCase()] : undefined;
        if (livePriceDataForButton && livePriceDataForButton.targetHit && !targetHitIconDismissed) {
            button.classList.add('target-hit-alert'); // Use 'target-hit-alert' for consistency with modal/cards
        } else {
            button.classList.remove('target-hit-alert'); // Ensure class is removed
        }

        asxCodeButtonsContainer.appendChild(button);
    });
    // Remove any lingering active state on rebuild
    asxCodeButtonsContainer.querySelectorAll('button.asx-code-btn').forEach(b=>b.classList.remove('active'));
    // Delegated click handler (single)
    if (!asxCodeButtonsContainer.__delegated) {
        let touchStartY = 0, touchMoved = false, touchStartX = 0;
        const MOVE_THRESHOLD = 8; // px before we treat as scroll not tap
        asxCodeButtonsContainer.addEventListener('touchstart', e => {
            const t = e.touches[0];
            touchStartY = t.clientY; touchStartX = t.clientX; touchMoved = false;
        }, { passive: true });
        asxCodeButtonsContainer.addEventListener('touchmove', e => {
            const t = e.touches[0];
            if (Math.abs(t.clientY - touchStartY) > MOVE_THRESHOLD || Math.abs(t.clientX - touchStartX) > MOVE_THRESHOLD) {
                touchMoved = true; // user scrolling
            }
        }, { passive: true });
        const activateButton = (btn) => {
            const code = btn.dataset.asxCode;
            logDebug('ASX Code Select: ' + code);
            asxCodeButtonsContainer.querySelectorAll('button.asx-code-btn').forEach(b=>b.classList.remove('active'));
            btn.classList.add('active');
            scrollToShare(code);
            try {
                const formVisible = shareFormSection && shareFormSection.style.display !== 'none' && !shareFormSection.classList.contains('app-hidden');
                if (formVisible && shareNameInput) {
                    const __codes = getAllAsxCodes();
                    const company = Array.isArray(__codes) ? (__codes.find(c => c.code === code)?.name || '') : '';
                    shareNameInput.value = code;
                    if (formCompanyName) formCompanyName.textContent = company;
                    checkFormDirtyState();
                    updateAddFormLiveSnapshot(code);
                }
            } catch(_) {}
        };
        asxCodeButtonsContainer.addEventListener('touchend', e => {
            if (touchMoved) return; // treat as scroll end
            const btn = e.target.closest('button.asx-code-btn');
            if (btn) activateButton(btn);
        });
        // Mouse / desktop clicks unchanged
        asxCodeButtonsContainer.addEventListener('click', e => {
            const btn = e.target.closest('button.asx-code-btn');
            if (btn) activateButton(btn);
        });
        asxCodeButtonsContainer.__delegated = true;
    }
    logDebug('UI: Rendered ' + sortedAsxCodes.length + ' code buttons.');
    // FIX: Ensure ASX button state is properly restored from localStorage before applying visibility
    // This fixes the timing issue where applyAsxButtonsState() runs with stale state
    try {
        const savedState = localStorage.getItem('asxButtonsExpanded') === 'true';
        if (typeof window !== 'undefined') {
            window.asxButtonsExpanded = savedState;
        }
    } catch(e) {
        console.warn('renderAsxCodeButtons: State restoration failed:', e);
    }
    // Re-apply visibility state centrally and adjust padding via applyAsxButtonsState()
    applyAsxButtonsState();
}

// Expose renderAsxCodeButtons to window for use by other modules
window.renderAsxCodeButtons = renderAsxCodeButtons;

function scrollToShare(asxCode) {
    logDebug('UI: Attempting to scroll to/highlight share with Code: ' + asxCode);
    const __shares_scroll = getAllSharesData();
    const targetShare = Array.isArray(__shares_scroll) ? __shares_scroll.find(s => s.shareName && s.shareName.toUpperCase() === asxCode.toUpperCase()) : null;
    if (targetShare) {
        selectShare(targetShare.id);
        let elementToScrollTo = document.querySelector('#shareTable tbody tr[data-doc-id="' + targetShare.id + '"]');
        if (!elementToScrollTo || window.matchMedia('(max-width: 768px)').matches) {
            elementToScrollTo = document.querySelector('.mobile-card[data-doc-id="' + targetShare.id + '"]');
        }
        if (elementToScrollTo) {
            // Get the height of the fixed header only, as banner is now at bottom
            const fixedHeaderHeight = appHeader ? appHeader.offsetHeight : 0;
            const elementRect = elementToScrollTo.getBoundingClientRect();
            // Calculate scroll position, accounting for the fixed header
            const scrollY = elementRect.top + window.scrollY - fixedHeaderHeight - 10; // 10px buffer for a little space
            window.scrollTo({ top: scrollY, behavior: 'smooth' });
            logDebug('UI: Scrolled to element for share ID: ' + targetShare.id);
        } else {
            console.warn('UI: Element for share ID: ' + targetShare.id + ' not found for scrolling.');
        }
        showShareDetails(); 
    } else {
        showCustomAlert('Share \'' + asxCode + '\' not found.');
        console.warn('UI: Share \'' + asxCode + '\' not found in allSharesData.');
    }
}

const COMPANY_TAX_RATE = 0.30;

/**
 * Displays detailed stock information in the search modal,
 * and renders action buttons (Add to Watchlist / Edit Existing Share).
 * @param {string} asxCode The ASX code to display.
 */
async function displayStockDetailsInSearchModal(asxCode) {
    if (!searchResultDisplay) {
        console.error('displayStockDetailsInSearchModal: searchResultDisplay element not found.');
        return;
    }

    searchResultDisplay.innerHTML = '<div class="loader"></div><p>Fetching stock data...</p>'; // Show loading spinner
    searchModalActionButtons.innerHTML = ''; // Clear existing buttons
    currentSearchShareData = null; // Reset previous data

    try {
    const encoded = encodeURIComponent(asxCode.trim().toUpperCase());
    if (DEBUG_MODE) logDebug('Search Modal: Fetching', `${GOOGLE_APPS_SCRIPT_URL}?stockCode=${encoded}`);
    const response = await fetch(`${GOOGLE_APPS_SCRIPT_URL}?stockCode=${encoded}&_ts=${Date.now()}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
    let data; let rawText;
    try {
        rawText = await response.text();
        if (DEBUG_MODE) logDebug('Search Modal: Raw response text length', rawText.length);
        try {
            data = JSON.parse(rawText);
        } catch(parseErr) {
            if (DEBUG_MODE) console.warn('Search Modal: JSON parse failed, raw snippet:', rawText.slice(0,400));
            throw new Error('Invalid JSON from data source');
        }
    } catch(streamErr) {
        throw streamErr;
    }
        logDebug(`Search: Fetched details for ${asxCode}:`, data);

        // Validate response contains at least one recognizable code key across any row
        const CODE_KEYS = ['ASXCode','ASX_Code','ASX Code','Code','code'];
        const hasAnyRowWithCode = Array.isArray(data) && data.some(r => CODE_KEYS.some(k => r && r[k]));
        if (!Array.isArray(data) || data.length === 0 || !hasAnyRowWithCode) {
            const isValidAsxCode = (allAsxCodes||[]).some(s => s.code === asxCode.toUpperCase());
            if (!isValidAsxCode) {
                searchResultDisplay.innerHTML = `<p class="initial-message">ASX code "${asxCode}" not found in code list. Check spelling.</p>`;
            } else {
                if (DEBUG_MODE && data && data[0]) {
                    console.warn('Search Modal: Unrecognized data shape, sample keys:', Object.keys(data[0]||{}));
                }
                searchResultDisplay.innerHTML = `<p class="initial-message">No live data available for ${asxCode} (source returned unrecognized structure).</p>`;
            }
            return;
        }

        // Prefer exact match row (some endpoints may return array with additional rows)
        const upperReq = asxCode.toUpperCase();
        let stockData = data.find(r => {
            const c = r.ASXCode || r.ASX_Code || r['ASX Code'] || r.Code || r.code;
            return c && String(c).toUpperCase().trim() === upperReq;
        });
        if (!stockData) {
            stockData = data[0];
            logDebug('Search Modal: No exact code match; using first row as fallback.', { requested: upperReq, firstKeys: Object.keys(data[0]||{}) });
        }
        // Resolve company name robustly: treat blank / placeholder API values as missing then fall back to
        // 1) existing share's stored name, 2) allAsxCodes mapping, else empty string.
        (function resolveCompanyName(){
            try {
                let rawName = stockData.CompanyName;
                if (typeof rawName === 'string') rawName = rawName.trim();
                const codeForLookup = (
                    stockData.ASXCode || stockData.ASX_Code || stockData['ASX Code'] ||
                    stockData.Code || stockData.code || asxCode || ''
                ).toUpperCase();
                const looksLikePlaceholder = !rawName || /^(-|N\/?A|N\\A)$/i.test(rawName);
                if (looksLikePlaceholder) {
                    // Existing share (already in watchlist) may have canonical companyName stored
                    const existingShareEntry = allSharesData.find(s => s.shareName.toUpperCase() === codeForLookup);
                    const mappedFromCodes = Array.isArray(allAsxCodes) ? (allAsxCodes.find(c => c.code === codeForLookup)?.name || '') : '';
                    rawName = (existingShareEntry && existingShareEntry.companyName) || mappedFromCodes || '';
                    if (DEBUG_MODE && rawName) logDebug('Search Modal: Applied fallback company name', { code: codeForLookup, resolved: rawName });
                }
                stockData.CompanyName = rawName || '';
            } catch (e) {
                stockData.CompanyName = stockData.CompanyName || '';
                if (DEBUG_MODE) console.warn('Search Modal: Company name resolution failed', e);
            }
        })();

        // Check if the stock is already in the user's watchlist
        const existingShare = allSharesData.find(s => s.shareName.toUpperCase() === asxCode.toUpperCase());

        // Prepare the data to be displayed in the modal (robust multi-key fallbacks matching snapshot logic)
        function pickNumber(obj, keys) {
            for (const k of keys) {
                if (obj && obj[k] !== undefined && obj[k] !== null && obj[k] !== '') {
                    const v = parseFloat(obj[k]);
                    if (!isNaN(v)) return v;
                }
            }
            return NaN;
        }
        const currentLivePrice = pickNumber(stockData, ['LivePrice','Live Price','live','price','Last','LastPrice','Last Price','LastTrade','Last Trade']);
        const previousClosePrice = pickNumber(stockData, ['PrevClose','Prev Close','prevClose','prev','Previous Close','Close','Last Close']);
        const peRatio = pickNumber(stockData, ['PE','PE Ratio','pe']);
        const high52Week = pickNumber(stockData, ['High52','High52','High 52','52WeekHigh','52 High']);
        const low52Week = pickNumber(stockData, ['Low52','Low52','Low 52','52WeekLow','52 Low']);
    const dayHigh = pickNumber(stockData, ['DayHigh','High','Day High','High Price']);
    const dayLow = pickNumber(stockData, ['DayLow','Low','Day Low','Low Price']);
    const volume = pickNumber(stockData, ['Volume','Vol','Turnover']);
    const marketCap = pickNumber(stockData, ['MarketCap','Market Cap','MktCap']);
    const dividend = pickNumber(stockData, ['Dividend','Div','DividendAmount']);
        if (DEBUG_MODE) logDebug('Search Modal: Normalized numeric fields', { currentLivePrice, previousClosePrice, peRatio, high52Week, low52Week, rawKeys: Object.keys(stockData||{}) });

        // Determine price change class
        let priceClass = '';
        let priceChangeText = 'N/A';
        let displayPrice = 'N/A';

        if (!isNaN(currentLivePrice) && currentLivePrice !== null) {
            displayPrice = `$${formatAdaptivePrice(currentLivePrice)}`;
            if (!isNaN(previousClosePrice) && previousClosePrice !== null) {
                const change = currentLivePrice - previousClosePrice;
                const percentageChange = (previousClosePrice !== 0 ? (change / previousClosePrice) * 100 : 0);
                const arrow = change > 0 ? '▲' : (change < 0 ? '▼' : '');
                priceChangeText = `${arrow} ${formatAdaptivePrice(change)} / ${formatAdaptivePercent(percentageChange)}%`;
                priceClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
            }
        }

        // Check if the currently displayed stock from search has hit its target (if it's in our allSharesData)
        const correspondingShareInWatchlist = allSharesData.find(s => s.shareName.toUpperCase() === asxCode.toUpperCase());
        const livePriceDataForSearchModal = livePrices[asxCode.toUpperCase()];
        const isTargetHitForSearchModal = correspondingShareInWatchlist && livePriceDataForSearchModal ? livePriceDataForSearchModal.targetHit : false;

        let searchModalTitleClasses = priceClass;
        // Apply target-hit-alert class if target is hit AND not dismissed
        if (isTargetHitForSearchModal && !targetHitIconDismissed) {
            searchModalTitleClasses += ' target-hit-alert';
        }

        // Construct the display HTML
        const resolvedDisplayCode = (stockData.ASXCode || stockData.ASX_Code || stockData['ASX Code'] || stockData.Code || stockData.code || asxCode || '').toUpperCase();
    // Legacy formatting retained; movement combo removed (user requested revert)

        searchResultDisplay.innerHTML = `
            <div class="text-center mb-4">
                <h3 class="${searchModalTitleClasses} search-modal-code-header" data-code="${resolvedDisplayCode}" data-name="${stockData.CompanyName || ''}" data-company="${stockData.CompanyName || ''}" title="Click to populate Add Share form">${resolvedDisplayCode || 'N/A'} ${stockData.CompanyName ? '- ' + stockData.CompanyName : ''}</h3>
                <span class="text-sm text-gray-500">${stockData.CompanyName ? '' : '(Company Name N/A)'}</span>
                ${DEBUG_MODE ? `<div class="debug-keys">Keys: ${(Object.keys(stockData||{})).slice(0,25).join(', ')}</div>` : ''}
            </div>
            <div class="live-price-display-section">
                <div class="fifty-two-week-row">
                    <span class="fifty-two-week-value low">Low: ${!isNaN(low52Week) ? formatMoney(low52Week) : 'N/A'}</span>
                    <span class="fifty-two-week-value high">High: ${!isNaN(high52Week) ? formatMoney(high52Week) : 'N/A'}</span>
                </div>
                <div class="live-price-main-row">
                    <h2 class="modal-share-name neutral-code-text">${displayPrice}</h2>
                </div>
                <div class="day-change-row">
                    <span class="price-change-large ${priceClass}">${priceChangeText}</span>
                </div>
                <div class="pe-ratio-row">
                    <span class="pe-ratio-value">P/E: ${!isNaN(peRatio) ? formatAdaptivePrice(peRatio) : 'N/A'}</span>
                </div>
            </div>
            <div class="external-links-section">
                <h3>External Links</h3>
                <div class="external-link-item">
                    <a id="searchModalNewsLink" href="#" target="_blank" class="external-link">View News <i class="fas fa-external-link-alt"></i></a>
                </div>
                <div class="external-link-item">
                    <a id="searchModalMarketIndexLink" href="#" target="_blank" class="external-link">View on MarketIndex.com.au <i class="fas fa-external-link-alt"></i></a>
                </div>
                <div class="external-link-item">
                    <a id="searchModalFoolLink" href="#" target="_blank" class="external-link">View on Fool.com.au <i class="fas fa-external-link-alt"></i></a>
                </div>
                <div class="external-link-item">
                    <a id="searchModalListcorpLink" href="#" target="_blank" class="external-link">View on Listcorp.com <i class="fas fa-external-link-alt"></i></a>
                </div>
                <div class="external-link-item">
                    <a id="searchModalHotCopperLink" href="#" target="_blank" class="external-link">View on HotCopper.com.au <i class="fas fa-external-link-alt"></i></a>
                </div>
                <div class="external-link-item">
                    <a id="searchModalCommSecLink" href="#" target="_blank" class="external-link">View on CommSec.com.au <i class="fas fa-external-link-alt"></i></a>
                </div>
                <div class="external-link-item">
                    <a id="searchModalGoogleFinanceLink" href="#" target="_blank" class="external-link">View on Google Finance <i class="fas fa-external-link-alt"></i></a>
                </div>
                <p class="ghosted-text external-links-note">Login may be required for some data sources.</p>
            </div>
        `;

        // Populate external links
        const encodedAsxCode = encodeURIComponent(asxCode);
        const searchModalNewsLink = document.getElementById('searchModalNewsLink');
        const searchModalMarketIndexLink = document.getElementById('searchModalMarketIndexLink');
        const searchModalFoolLink = document.getElementById('searchModalFoolLink');
        const searchModalListcorpLink = document.getElementById('searchModalListcorpLink');
        const searchModalCommSecLink = document.getElementById('searchModalCommSecLink');
        const searchModalGoogleFinanceLink = document.getElementById('searchModalGoogleFinanceLink');
        const searchModalHotCopperLink = document.getElementById('searchModalHotCopperLink');

        if (searchModalNewsLink) {
            const code = String(asxCode).toUpperCase();
            searchModalNewsLink.href = `https://news.google.com/search?q=${encodedAsxCode}%20ASX&hl=en-AU&gl=AU&ceid=AU%3Aen`;
            searchModalNewsLink.innerHTML = code + ' News <i class="fas fa-external-link-alt"></i>';
        }
        if (searchModalMarketIndexLink) {
            searchModalMarketIndexLink.href = `https://www.marketindex.com.au/asx/${asxCode.toLowerCase()}`;
            searchModalMarketIndexLink.innerHTML = 'Market Index <i class="fas fa-external-link-alt"></i>';
        }
        if (searchModalFoolLink) {
            const foolSearchCode = String(asxCode).trim().toLowerCase();
            searchModalFoolLink.href = `https://www.fool.com.au/tickers/asx-${foolSearchCode}/`;
            searchModalFoolLink.innerHTML = 'Motley Fool <i class="fas fa-external-link-alt"></i>';
        }
        if (searchModalListcorpLink) {
            searchModalListcorpLink.href = `https://www.listcorp.com/asx/${asxCode.toLowerCase()}`;
            searchModalListcorpLink.innerHTML = 'Listcorp <i class="fas fa-external-link-alt"></i>';
        }
        if (searchModalHotCopperLink) {
            searchModalHotCopperLink.href = `https://hotcopper.com.au/asx/${asxCode.toLowerCase()}`;
            searchModalHotCopperLink.innerHTML = 'HotCopper <i class="fas fa-external-link-alt"></i>';
        }
        if (searchModalCommSecLink) {
            searchModalCommSecLink.href = `https://www.commsec.com.au/markets/company-details.html?code=${asxCode}`;
            searchModalCommSecLink.innerHTML = 'CommSec <i class="fas fa-external-link-alt"></i>';
        }
        if (searchModalGoogleFinanceLink) {
            searchModalGoogleFinanceLink.href = `https://www.google.com/finance/quote/${asxCode.toUpperCase()}:ASX`;
            searchModalGoogleFinanceLink.innerHTML = 'Google Finance <i class="fas fa-external-link-alt"></i>';
        }
    // Typography diagnostics for search modal
    setTimeout(() => { try { logSearchModalTypographyRatios(); } catch(_) {} }, 0);

        // Store the fetched data for potential adding/editing (normalize code property fallbacks)
        const resolvedCode = stockData.ASXCode || stockData.ASX_Code || stockData['ASX Code'] || stockData.Code || stockData.code || asxCode;
        currentSearchShareData = {
            shareName: String(resolvedCode || '').toUpperCase(), // legacy consumers
            shareCode: String(resolvedCode || '').toUpperCase(),  // explicit code key for clarity
            companyName: stockData.CompanyName,
            currentPrice: currentLivePrice,
            targetPrice: null,
            dividendAmount: null,
            frankingCredits: null,
            starRating: 0,
            comments: [],
            watchlistId: null
        };

        // Two-step workflow: DO NOT auto-open add/edit form here.
        // User must click the action button rendered below.

        // Render action button (explicit user intent only)
        const actionButton = document.createElement('button');
        actionButton.id = 'searchModalActionButton';
        actionButton.classList.add('button', 'primary-button'); // Apply base button styles

        if (existingShare) {
            // Keep consistent copy: show 'Add to Share Tracker' but open edit flow for existing shares
            actionButton.textContent = 'Add to Share Tracker';
            actionButton.addEventListener('click', () => {
                hideModal(stockSearchModal); // Close search modal
                // If the user clicks "Edit Share in Tracker" for an existing share,
                // open the edit form for that existing share.
                showEditFormForSelectedShare(existingShare.id);
            });
        } else {
            actionButton.textContent = 'Add to Share Tracker'; // UX copy requested
            actionButton.addEventListener('click', () => {
                hideModal(stockSearchModal); // Close search modal
                clearForm(); // Start clean add flow
                userManuallyOverrodeDirection = false;
                formTitle.textContent = 'Add New Share'; // Set title for new share
                if (currentSearchShareData) {
                    if (shareNameInput) shareNameInput.value = currentSearchShareData.shareCode || currentSearchShareData.shareName || '';
                    if (formCompanyName) formCompanyName.textContent = currentSearchShareData.companyName || '';
                }
                populateShareWatchlistSelect(null, true); // Populate and enable watchlist select for new share
                // Default toggles to Buy+Below
                try {
                    if (targetIntentBuyBtn && targetIntentSellBtn) {
                        targetIntentBuyBtn.classList.add('is-active');
                        targetIntentBuyBtn.setAttribute('aria-pressed', 'true');
                        targetIntentSellBtn.classList.remove('is-active');
                        targetIntentSellBtn.setAttribute('aria-pressed', 'false');
                    }
                    if (targetAboveCheckbox && targetBelowCheckbox) {
                        targetAboveCheckbox.checked = false;
                        targetBelowCheckbox.checked = true;
                    }
                    if (targetDirAboveBtn && targetDirBelowBtn) {
                        targetDirAboveBtn.classList.remove('is-active');
                        targetDirAboveBtn.setAttribute('aria-pressed', 'false');
                        targetDirBelowBtn.classList.add('is-active');
                        targetDirBelowBtn.setAttribute('aria-pressed', 'true');
                    }
                } catch(_) {}
                if (commentsFormContainer && commentsFormContainer.querySelectorAll('.comment-section').length === 0) {
                    addCommentSection(commentsFormContainer); // Add initial empty comment section
                }
                // Fetch snapshot to prefill reference price & live view
                try { updateAddFormLiveSnapshot(currentSearchShareData.shareCode); } catch(_) {}
                showModal(shareFormSection); // Show add/edit modal
                // Ensure accordion is properly initialized after modal is shown
                setTimeout(() => initShareFormAccordion(true), 10);
                if (targetPriceInput) targetPriceInput.focus();
                checkFormDirtyState(); // Recompute dirty state
            });
        }

        // Ensure the action button is only appended once and into the intended modal footer.
        try {
            // Remove any stray duplicate buttons previously inserted elsewhere just in case
            document.querySelectorAll('#searchModalActionButton').forEach((el) => { if (el && el.parentNode) el.parentNode.removeChild(el); });
        } catch (_) {}

        if (searchModalActionButtons && searchModalActionButtons.appendChild) {
            // Clear prior children then append the new button
            searchModalActionButtons.innerHTML = '';
            searchModalActionButtons.appendChild(actionButton);
        } else if (stockSearchModal) {
            // Fallback: try to find/create a footer inside the modal to host the button
            let footer = stockSearchModal.querySelector('.modal-action-buttons-footer');
            if (!footer) {
                footer = document.createElement('div');
                footer.className = 'modal-action-buttons-footer';
                stockSearchModal.querySelector('.modal-content')?.appendChild(footer);
            }
            footer.innerHTML = '';
            footer.appendChild(actionButton);
        } else {
            // As a last resort, avoid attaching visible UI to <body> which caused
            // duplicated buttons to appear at the bottom of the page in some
            // malformed DOM states. Instead keep the action button in a hidden
            // container so it does not escape the intended modal layout.
            console.warn('Search Modal: Action footer not found; placing add button into a hidden fallback container to avoid visible duplicates.');
            let hiddenContainer = document.getElementById('hiddenModalActionButtonsContainer');
            if (!hiddenContainer) {
                hiddenContainer = document.createElement('div');
                hiddenContainer.id = 'hiddenModalActionButtonsContainer';
                hiddenContainer.setAttribute('aria-hidden', 'true');
                hiddenContainer.style.display = 'none';
                document.body.appendChild(hiddenContainer);
            }
            hiddenContainer.appendChild(actionButton);
        }

        logDebug(`Search: Displayed details and action button for ${asxCode}.`);

    } catch (error) {
        console.error('Search: Error fetching stock details:', error);
        const friendly = (
            /NetworkError|Failed to fetch/i.test(error.message) ? 'Network issue fetching data. Check connection.' :
            /HTTP 4\d\d/.test(error.message) ? 'Request issue (client error). Try again or verify code.' :
            /HTTP 5\d\d/.test(error.message) ? 'Data source temporarily unavailable (server error).' :
            'Unexpected error while fetching data.'
        );
        searchResultDisplay.innerHTML = `<p class="initial-message">${friendly} (${asxCode}).</p>`;
        if (DEBUG_MODE) {
            const pre = document.createElement('pre');
            pre.className = 'debug-block';
            pre.textContent = 'Debug: ' + (error && error.stack ? error.stack : error.message);
            searchResultDisplay.appendChild(pre);
        }
        searchModalActionButtons.innerHTML = '';
    }
}

/**
 * Loads ASX company codes and names from a local CSV file.
 * Assumes CSV has headers 'ASX Code' and 'Company Name'.
 * @returns {Promise<Array<object>>} A promise that resolves to an array of stock objects.
 */
async function loadAsxCodesFromCSV() {
    try {
        const response = await fetch('./asx_codes.csv'); // Assuming the CSV is named asx_codes.csv and is in the root
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const csvText = await response.text();
        logDebug('CSV: ASX codes CSV loaded successfully. Parsing...');

        const lines = csvText.split('\n').filter(line => line.trim() !== '');
        if (lines.length === 0) {
            console.warn('CSV: ASX codes CSV is empty.');
            return [];
        }

        // Clean the header line to handle potential BOM or encoding issues
        const headerLine = lines[0].replace(/^\uFEFF/, '').replace(/^\u00EF\u00BB\u00BF/, '');
        const headers = headerLine.split(',').map(header => header.trim().replace(/"/g, ''));
        console.log('CSV: Parsed headers:', headers);

        const asxCodeIndex = headers.findIndex(h => h.toLowerCase().includes('asx code') || h.toLowerCase() === 'asx code');
        const companyNameIndex = headers.findIndex(h => h.toLowerCase().includes('company name') || h.toLowerCase() === 'company name');

        console.log('CSV: ASX Code index:', asxCodeIndex, 'Company Name index:', companyNameIndex);

        if (asxCodeIndex === -1 || companyNameIndex === -1) {
            console.error('CSV: Available headers:', headers);
            throw new Error(`CSV: Required headers "ASX Code" (found at index ${asxCodeIndex}) or "Company Name" (found at index ${companyNameIndex}) not found in CSV.`);
        }

        const parsedCodes = lines.slice(1).map(line => {
            const values = line.split(',');
            // Handle cases where lines might not have enough columns or contain extra commas within quoted fields
            // For simple CSV, splitting by comma is usually sufficient. More robust parsing might use a library.
            const code = values[asxCodeIndex] ? values[asxCodeIndex].trim().toUpperCase() : '';
            const name = values[companyNameIndex] ? values[companyNameIndex].trim() : '';
            return { code: code, name: name };
        }).filter(item => item.code !== ''); // Filter out any entries without a code

        logDebug(`CSV: Successfully parsed ${parsedCodes.length} ASX codes from CSV.`);
        return parsedCodes;

    } catch (error) {
        console.error('CSV: Error loading or parsing ASX codes CSV:', error);
        showCustomAlert('Error loading stock search data: ' + error.message, 3000);
        return [];
    }
}
/**
 * Checks if the Australian Securities Exchange (ASX) is currently open.
 * The market is considered "closed" only from Monday 12:01 AM to Thursday 12:01 AM (Sydney time).
 * @returns {boolean} True if the ASX is open, false otherwise.
 */

function estimateDividendIncome(investmentValue, dividendAmountPerShare, currentPricePerShare) {
    if (typeof investmentValue !== 'number' || isNaN(investmentValue) || investmentValue <= 0) { return null; }
    if (typeof dividendAmountPerShare !== 'number' || isNaN(dividendAmountPerShare) || dividendAmountPerShare <= 0) { return null; }
    if (typeof currentPricePerShare !== 'number' || isNaN(currentPricePerShare) || currentPricePerShare <= 0) { return null; }
    const numberOfShares = investmentValue / currentPricePerShare;
    return numberOfShares * dividendAmountPerShare;
}

function updateCalculatorDisplay() {
    calculatorInput.textContent = previousCalculatorInput + (operator ? ' ' + getOperatorSymbol(operator) + ' ' : '') + currentCalculatorInput;
    if (resultDisplayed) { /* nothing */ }
    else { calculatorResult.textContent = currentCalculatorInput === '' ? '0' : currentCalculatorInput; }
}

function calculateResult() {
    let prev = parseFloat(previousCalculatorInput);
    let current = parseFloat(currentCalculatorInput);
    if (isNaN(prev) || isNaN(current)) return;
    let res;
    switch (operator) {
        case 'add': res = prev + current; break;
        case 'subtract': res = prev - current; break;
        case 'multiply': res = prev * current; break;
        case 'divide':
            if (current === 0) { showCustomAlert('Cannot divide by zero!'); res = 'Error'; }
            else { res = prev / current; }
            break;
        default: return;
    }
    if (typeof res === 'number' && !isNaN(res)) { res = parseFloat(res.toFixed(10)); }
    calculatorResult.textContent = res;
    previousCalculatorInput = res.toString();
    currentCalculatorInput = '';
}

function getOperatorSymbol(op) {
    switch (op) {
        case 'add': return '+'; case 'subtract': return '-';
        case 'multiply': return '×'; case 'divide': return '÷';
        default: return '';
    }
}

function resetCalculator() {
    currentCalculatorInput = ''; operator = null; previousCalculatorInput = '';
    resultDisplayed = false; calculatorInput.textContent = ''; calculatorResult.textContent = '0';
    logDebug('Calculator: Calculator state reset.');
}

async function applyTheme(themeName) {
    // Delegate theme application to the centralized theme module to ensure a single source of truth.
    try {
        return await moduleApplyTheme(themeName);
    } catch (e) {
        console.warn('applyTheme delegation to moduleApplyTheme failed, falling back to no-op. Error:', e);
        return;
    }
}

function updateThemeToggleAndSelector() {
    try {
        moduleUpdateThemeToggle();
    } catch (e) {
        console.warn('updateThemeToggleAndSelector: moduleUpdateThemeToggle failed, error:', e);
        // Fallback: perform minimal local update
        if (colorThemeSelect) {
            if (CUSTOM_THEMES.includes(currentActiveTheme)) colorThemeSelect.value = currentActiveTheme;
            else colorThemeSelect.value = 'none';
        }
    }
}

// expose for other scripts that use a global accessor
window.applyTheme = applyTheme;

function getDefaultWatchlistId(userId) {
    return userId + '_' + DEFAULT_WATCHLIST_ID_SUFFIX;
}

async function saveLastSelectedWatchlistIds(watchlistIds) {
    if (!db || !currentUserId || !firestore) {
        console.warn('Watchlist: Cannot save last selected watchlists: DB, User ID, or Firestore functions not available.');
        return;
    }
    const userProfileDocRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/profile/settings');
    try {
        await firestore.setDoc(userProfileDocRef, { lastSelectedWatchlistIds: watchlistIds }, { merge: true });
        logDebug('Watchlist: Saved last selected watchlist IDs: ' + watchlistIds.join(', '));
    }
    catch (error) {
        console.error('Watchlist: Error saving last selected watchlist IDs:', error);
    }
}
async function saveSortOrderPreference(sortOrder) {
    logDebug('Sort Debug: Attempting to save sort order: ' + sortOrder);
    logDebug('Sort Debug: db: ' + (db ? 'Available' : 'Not Available'));
    logDebug('Sort Debug: currentUserId: ' + currentUserId);
    logDebug('Sort Debug: firestore: ' + (firestore ? 'Available' : 'Not Available'));

    // Always persist to localStorage as an offline-friendly backup
    try {
        if (sortOrder) {
            localStorage.setItem('lastSortOrder', sortOrder);
        } else {
            localStorage.removeItem('lastSortOrder');
        }
        logDebug('Sort: Saved sort order to localStorage: ' + sortOrder);
    } catch (e) {
        console.warn('Sort: Failed to write sort order to localStorage:', e);
    }

    if (!db || !currentUserId || !firestore) {
        console.warn('Sort: Cannot save sort order preference: DB, User ID, or Firestore functions not available. Skipping cloud save.');
        return;
    }
    const userProfileDocRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/profile/settings');
    try {
            // Ensure the sortOrder is not an empty string or null before saving
            const dataToSave = sortOrder ? { lastSortOrder: sortOrder } : { lastSortOrder: firestore.deleteField() };
            await firestore.setDoc(userProfileDocRef, dataToSave, { merge: true });
            logDebug('Sort: Saved sort order preference to Firestore: ' + sortOrder);
        } catch (error) {
            console.error('Sort: Error saving sort order preference to Firestore:', error);
        }
}

async function loadUserWatchlistsAndSettings() {
    // Expose a promise that other modules (e.g., dataService) can await to ensure
    // the user's saved sort preference is applied before initial data fetch/render.
    // This promise is resolved after we determine and set the authoritative sort.
    try {
        if (!window.__userSortReady) {
            let _resolve;
            window.__userSortReady = new Promise((res) => { _resolve = res; });
            window.__userSortReadyResolve = _resolve;
            // Public flag to indicate whether the handshake has been fully resolved.
            // Other modules can use this to decide whether to attach follow-up updates
            // instead of relying on a bounded timeout.
            window.__userSortReadyResolved = false;
            // Enable detailed startup tracing of sort-set calls so we can capture
            // any late overwrites during initial boot (can be removed after debug).
            try {
                if (typeof window.__LOG_SORT_SET_CALLS === 'undefined') {
                    window.__LOG_SORT_SET_CALLS = true;
                    debugLog('[Diag] __LOG_SORT_SET_CALLS enabled for startup tracing');
                }
            } catch(_) {}
        }
    } catch (_) {}
    logDebug('loadUserWatchlistsAndSettings called.'); // Added log for function entry

    if (!db || !currentUserId) {
        console.warn('User Settings: Firestore DB or User ID not available for loading settings. Skipping.');
        window._appDataLoaded = false;
        hideSplashScreenIfReady();
        return;
    }
    setUserWatchlists([]);
    const watchlistsColRef = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/watchlists');
    const userProfileDocRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/profile/settings');

    try {
        logDebug('User Settings: Fetching user watchlists and profile settings...');
        const querySnapshot = await firestore.getDocs(firestore.query(watchlistsColRef));
        querySnapshot.forEach(doc => { userWatchlists.push({ id: doc.id, name: doc.data().name }); });
        // Defensive dedupe: ensure unique watchlist ids in memory after fetch
        try {
            const _m = new Map();
            for (const w of userWatchlists) {
                if (w && w.id && !_m.has(w.id)) _m.set(w.id, w);
            }
            setUserWatchlists(Array.from(_m.values()));
            logDebug('User Settings: Deduped userWatchlists post-fetch. Count=' + userWatchlists.length);
        } catch (e) {
            console.warn('User Settings: Dedupe after fetch failed', e);
        }
        logDebug('User Settings: Found ' + userWatchlists.length + ' existing watchlists (before default check).');

        // Ensure "Cash & Assets" is always an option in `userWatchlists` for internal logic
        if (!userWatchlists.some(wl => wl.id === CASH_BANK_WATCHLIST_ID)) {
            userWatchlists.push({ id: CASH_BANK_WATCHLIST_ID, name: 'Cash & Assets' });
            logDebug('User Settings: Added "Cash & Assets" to internal watchlists array.');
        }

        // If no user-defined watchlists (excluding Cash & Assets), create a default one
        const userDefinedStockWatchlists = userWatchlists.filter(wl => wl.id !== CASH_BANK_WATCHLIST_ID && wl.id !== ALL_SHARES_ID);
        if (userDefinedStockWatchlists.length === 0) {
            const defaultWatchlistId = getDefaultWatchlistId(currentUserId);
            const defaultWatchlistRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/watchlists/' + defaultWatchlistId);
            await firestore.setDoc(defaultWatchlistRef, { name: DEFAULT_WATCHLIST_NAME, createdAt: new Date().toISOString() });
            userWatchlists.push({ id: defaultWatchlistId, name: DEFAULT_WATCHLIST_NAME });
            // Ensure currentSelectedWatchlistIds points to the newly created default watchlist
            setCurrentSelectedWatchlistIds([defaultWatchlistId]); 
            logDebug('User Settings: Created default watchlist and set it as current selection.');
        }

        // Sort watchlists (excluding Cash & Assets for sorting, then re-add it if needed)
        userWatchlists.sort((a, b) => {
            if (a.id === CASH_BANK_WATCHLIST_ID) return 1;
            if (b.id === CASH_BANK_WATCHLIST_ID) return -1;
            return a.name.localeCompare(b.name);
        });
        logDebug('User Settings: Watchlists after sorting: ' + userWatchlists.map(wl => wl.name).join(', '));

        const userProfileSnap = await firestore.getDoc(userProfileDocRef);
    savedSortOrder = null;
    savedTheme = null;

        if (userProfileSnap.exists()) {
            const settingsData = userProfileSnap.data();
            savedSortOrder = settingsData.lastSortOrder;
            savedTheme = settingsData.lastTheme;
            applyLoadedGlobalAlertSettings(settingsData);
            const loadedSelectedWatchlistIds = settingsData.lastSelectedWatchlistIds;
            // Manual EOD preference removed; behavior is now automatic

            if (loadedSelectedWatchlistIds && Array.isArray(loadedSelectedWatchlistIds) && loadedSelectedWatchlistIds.length > 0) {
                // Filter out invalid or non-existent watchlists from loaded preferences
                // Treat 'portfolio', '__movers' as valid special views alongside All Shares and Cash & Assets
                setCurrentSelectedWatchlistIds(loadedSelectedWatchlistIds.filter(id =>
                    id === ALL_SHARES_ID || id === CASH_BANK_WATCHLIST_ID || id === 'portfolio' || id === '__movers' || userWatchlists.some(wl => wl.id === id)
                ));
                logDebug('User Settings: Loaded last selected watchlists from profile: ' + currentSelectedWatchlistIds.join(', '));
            } else {
                logDebug('User Settings: No valid last selected watchlists in profile. Will determine default.');
            }
        } else {
            logDebug('User Settings: User profile settings not found. Will determine default watchlist selection.');
        }

        // If a pending theme save exists locally (from earlier when Firestore/Auth wasn't available), flush it now.
        try {
            const pending = (() => { try { return localStorage.getItem('pendingThemeSave'); } catch(_) { return null; } })();
            if (pending && currentUserId && firestore && db) {
                try {
                    const profRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/profile/settings');
                    firestore.setDoc(profRef, { lastTheme: pending }, { merge: true }).then(() => {
                        try { localStorage.removeItem('pendingThemeSave'); } catch(_) {}
                        console.log('[Theme Flush] Flushed pendingThemeSave to Firestore:', pending);
                    }).catch(err => console.warn('[Theme Flush] Failed to flush pending theme to Firestore:', err));
                } catch (err) { console.warn('[Theme Flush] Error constructing Firestore doc ref:', err); }
            }
        } catch(_) {}

        // Prefer local device's last selected view if available and valid
        try {
            const lsView = localStorage.getItem('lastSelectedView');
            if (lsView) {
                const isValid = (lsView === ALL_SHARES_ID) || (lsView === CASH_BANK_WATCHLIST_ID) || (lsView === 'portfolio') || (lsView === '__movers') || userWatchlists.some(wl => wl.id === lsView);
                if (isValid) {
                    setCurrentSelectedWatchlistIds([lsView]);
                    logDebug('User Settings: Overriding selection with localStorage lastSelectedView: ' + lsView);
                }
            }
        } catch(e) { /* ignore */ }

        // Determine final currentSelectedWatchlistIds if not set or invalid after loading/filtering
        if (!currentSelectedWatchlistIds || currentSelectedWatchlistIds.length === 0) {
            // Default to All Shares as primary fallback (similar to Percentage High to Low for sorting)
            setCurrentSelectedWatchlistIds([ALL_SHARES_ID]);
            logDebug('User Settings: Defaulting currentSelectedWatchlistIds to All Shares (robust fallback).');
        }
        logDebug('User Settings: Final currentSelectedWatchlistIds before renderWatchlistSelect: ' + currentSelectedWatchlistIds.join(', '));

        renderWatchlistSelect(); // Populate and select in the header dropdown

        // Also re-populate the share modal dropdown if present
        if (typeof populateShareWatchlistSelect === 'function') {
            populateShareWatchlistSelect();
        }

        // Load watchlist-specific sort orders
        try {
            await loadWatchlistSortOrders(null, null, currentUserId, null);
            logDebug('Sort: Loaded watchlist-specific sort orders');
        } catch (error) {
            console.warn('Sort: Failed to load watchlist sort orders:', error);
        }

        // Apply saved sort preference to currentSortOrder; let renderSortSelect enforce it after options are built
        let candidateSort = savedSortOrder;
        if (!candidateSort) {
            try { candidateSort = localStorage.getItem('lastSortOrder') || null; } catch (e) { candidateSort = null; }
            if (candidateSort) logDebug('Sort: Loaded sort order from localStorage fallback: ' + candidateSort);
        }

        // Check if there's a watchlist-specific sort order for the current watchlist
        if (currentSelectedWatchlistIds.length > 0) {
            const currentWatchlistId = currentSelectedWatchlistIds[0];
            const watchlistSortOrder = getSortOrderForWatchlist(currentWatchlistId);
            if (watchlistSortOrder) {
                candidateSort = watchlistSortOrder;
                logDebug('Sort: Using watchlist-specific sort order: ' + candidateSort);
            }
        }

        if (candidateSort) {
            setCurrentSortOrder(candidateSort);
            // Diagnostic trace: record when we apply the candidate sort during startup
            try { console.log('[SORT HANDSHAKE] setCurrentSortOrder ->', candidateSort); } catch(_) {}
            logDebug('Sort: Using saved sort order: ' + currentSortOrder);
        } else {
            // Set to new default sort order: 'percentageChange-desc' for share watchlists, 'name-asc' for cash
            const defaultSort = currentSelectedWatchlistIds.includes(CASH_BANK_WATCHLIST_ID) ? 'name-asc' : 'percentageChange-desc';
            setCurrentSortOrder(defaultSort);
            logDebug('Sort: No saved sort order found, defaulting to: ' + currentSortOrder);
        }
        renderSortSelect(); // Build options, then apply currentSortOrder
    // Diagnostic: report authoritative sort just before resolving the handshake
        try {
        try { console.log('[SORT HANDSHAKE] resolving __userSortReady (currentSortOrder):', (typeof getCurrentSortOrder === 'function') ? getCurrentSortOrder() : window.currentSortOrder); } catch(_) {}
        // Mark resolved so other modules know the authoritative sort has been applied
        try { 
            window.__userSortReadyResolved = true;
            // Set an initial authoritative lock so other non-user callers won't overwrite
            try {
                window.__initialSortLocked = true;
                window.__initialAuthoritativeSort = (typeof getCurrentSortOrder === 'function') ? getCurrentSortOrder() : window.currentSortOrder;
                // Auto-clear the lock after a short grace period to allow normal updates
                setTimeout(() => { try { window.__initialSortLocked = false; delete window.__initialAuthoritativeSort; } catch(_) {} }, 500);
            } catch(_) {}
        } catch(_) {}
        if (window.__userSortReadyResolve) { window.__userSortReadyResolve(); delete window.__userSortReadyResolve; }
    } catch(_) {}
        try { 
            // Defer the initial update to ensure DOM elements are ready
            setTimeout(() => updateSortPickerButtonText(), 100); 
        } catch(e) {}

        // Apply saved theme or default. Backfill user profile if missing.
        if (savedTheme) {
            applyTheme(savedTheme);
        } else {
            const localStorageSelectedTheme = (()=>{ try { return localStorage.getItem('selectedTheme'); } catch(_) { return null; } })();
            const localStorageTheme = (()=>{ try { return localStorage.getItem('theme'); } catch(_) { return null; } })();
            const candidateLocal = localStorageSelectedTheme || localStorageTheme;
            if (candidateLocal) {
                // Apply local theme and backfill Firestore async (do not block UI)
                applyTheme(candidateLocal);
                try {
                    if (!savedTheme && currentUserId && firestore && db) {
                        const profRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/profile/settings');
                        firestore.setDoc(profRef, { lastTheme: candidateLocal }, { merge: true }).catch(()=>{});
                    }
                } catch(_) {}
            } else {
                applyTheme('system-default');
            }
        }
        updateThemeToggleAndSelector();

    // Removed: manual EOD preference handling

        const migratedSomething = await migrateOldSharesToWatchlist();
        if (!migratedSomething) {
            logDebug('Migration: No old shares to migrate/update, directly setting up shares listener for current watchlist.');
        }

        // Load shares listener and cash categories listener once here
        await loadShares(db, firestore, currentUserId, currentAppId); // Sets up the listener for shares
        await loadCashCategories(db, firestore, currentUserId, currentAppId); // Sets up the listener for cash categories

        // Initial render based on selected watchlist (stock or cash)
        renderWatchlist(); // This will now correctly display based on the initial currentSelectedWatchlistIds

        // Strong enforcement: if the last view was Portfolio, ensure Portfolio is shown now
        try {
            const lsViewFinal = localStorage.getItem('lastSelectedView');
            if (lsViewFinal === 'portfolio' && typeof showPortfolioView === 'function') {
                showPortfolioView();
                logDebug('User Settings: Enforced Portfolio view after initial render.');
            }
        } catch(e) { /* ignore */ }

        window._appDataLoaded = true;
        hideSplashScreenIfReady();

    } catch (error) {
        console.error('User Settings: Error loading user watchlists and settings:', error);
        showCustomAlert('Error loading user settings: ' + error.message);
        hideSplashScreen();
    } finally {
        if (loadingIndicator) loadingIndicator.style.display = 'none';
    }
}

// Attach loadUserWatchlistsAndSettings to window for use in other modules
window.loadUserWatchlistsAndSettings = loadUserWatchlistsAndSettings;

/**
 * Starts the periodic fetching of live prices.
 */
function startLivePriceUpdates() {
    if (livePriceFetchInterval) {
        clearInterval(livePriceFetchInterval);
        logDebug('Live Price: Cleared existing live price interval.');
    }
    // Always start periodic fetching to keep global live prices fresh regardless of current view
    livePriceFetchInterval = setInterval(() => fetchLivePrices({ cacheBust: true }), LIVE_PRICE_FETCH_INTERVAL_MS);
    logDebug('Live Price: Started live price updates every ' + (LIVE_PRICE_FETCH_INTERVAL_MS / 1000 / 60) + ' minutes.');
}

/**
 * Stops the periodic fetching of live prices.
 */
function stopLivePriceUpdates() {
    if (livePriceFetchInterval) {
        clearInterval(livePriceFetchInterval);
        livePriceFetchInterval = null;
        logDebug('Live Price: Stopped live price updates.');
    }
}

// Helper: select CUSTOM_TRIGGER_HITS that belong to the current user.
// Strategy:
//  1) If we find any hits with exact userId match, return those.
//  2) Else, include hits whose code exists in this user's portfolio (duplicates from movers/52w with null userId).
//  3) Else, return all hits as a conservative fallback (prevents empty UI if metadata is incomplete temporarily).
function selectCustomTriggerHitsForUser(allHits, uid) {
    try {
        const list = Array.isArray(allHits) ? allHits : [];
        if (list.length === 0) return [];
        const portfolioCodes = new Set((window.allSharesData || []).map(s => s && s.shareName ? String(s.shareName).toUpperCase() : null).filter(Boolean));
        // Exact userId match takes precedence
        if (uid) {
            const mine = list.filter(h => h && h.userId === uid);
            if (mine.length > 0) return mine;
        }
        // If no explicit userId matches, include portfolio-duplicates (movers/52w with null/missing userId)
        const mineByPortfolio = list.filter(h => {
            try { return h && portfolioCodes.has(String(h.code || '').toUpperCase()); } catch(_) { return false; }
        });
        if (mineByPortfolio.length > 0) return mineByPortfolio;
        // Fallback: return all (better to show than silently hide)
        return list;
    } catch(_) { return []; }
}

// NEW: Function to update the target hit notification icon
function updateTargetHitBanner() {
    if (!targetHitIconBtn || !targetHitIconCount || !watchlistSelect || !sortSelect) {
        console.warn('Target Alert: UI elements missing. Cannot update banner/highlights.');
        return;
    }
    // Lightweight change-detection snapshot to suppress redundant DOM/log churn
    if (!window.__lastTargetBannerSnapshot) {
        window.__lastTargetBannerSnapshot = { enabledCount: null, displayCount: null, dismissed: null };
    }
    // Only enabled alerts are surfaced; muted are excluded from count & styling.
    // Prefer CUSTOM_TRIGGER_HITS for "Custom" notifications; select using userId with a portfolio-based fallback
    const __uid = (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) ? window.firebase.auth().currentUser.uid : currentUserId;
    // Get central hits safely
    const centralHitsRaw = (window.customTriggerHits && Array.isArray(window.customTriggerHits.hits)) ? window.customTriggerHits.hits.slice() : [];
    const selectedCentralHits = selectCustomTriggerHitsForUser(centralHitsRaw, __uid) || [];
    // Use live in-memory shares too (ensure we reference the window mirror explicitly)
    const liveArr = (window.sharesAtTargetPrice && Array.isArray(window.sharesAtTargetPrice)) ? window.sharesAtTargetPrice : (Array.isArray(sharesAtTargetPrice) ? sharesAtTargetPrice : []);
    // Build a union of codes across central hits and live shares so the badge reflects both
    const unionCodes = new Set();
    try { selectedCentralHits.forEach(h => { const c = String(h && (h.code || h.shareCode || h.shareName || '')).toUpperCase(); if (c) unionCodes.add(c); }); } catch(_) {}
    try { liveArr.forEach(s => { const c = String(s && (s.shareName || s.code || s.shareCode || '')).toUpperCase(); if (c) unionCodes.add(c); }); } catch(_) {}
    const customHitsCount = unionCodes.size;
    const enabledCount = customHitsCount > 0 ? customHitsCount : (Array.isArray(liveArr) ? liveArr.length : 0);
    // Global 52-week alerts: prefer *_HITS; fall back to legacy alerts structure
    const globalHighs = (window.globalHiLo52Hits && Array.isArray(window.globalHiLo52Hits.highHits))
        ? window.globalHiLo52Hits.highHits.length
        : ((window.globalHiLo52Alerts && Array.isArray(window.globalHiLo52Alerts.highs)) ? window.globalHiLo52Alerts.highs.length : 0);
    const globalLows = (window.globalHiLo52Hits && Array.isArray(window.globalHiLo52Hits.lowHits))
        ? window.globalHiLo52Hits.lowHits.length
        : ((window.globalHiLo52Alerts && Array.isArray(window.globalHiLo52Alerts.lows)) ? window.globalHiLo52Alerts.lows.length : 0);
    
    // Debug logging for 52-week low count
    console.log('[BANNER-DEBUG] global highs/lows:', { globalHighs, globalLows });
    console.log('[BANNER-DEBUG] enabledCount:', enabledCount);
    // Treat global summary counts as zero if directional thresholds are fully inactive (prevents stale badge after clearing)
    const directionalActive = isDirectionalThresholdsActive ? isDirectionalThresholdsActive() : (
        (typeof globalPercentIncrease === 'number' && globalPercentIncrease>0) ||
        (typeof globalDollarIncrease === 'number' && globalDollarIncrease>0) ||
        (typeof globalPercentDecrease === 'number' && globalPercentDecrease>0) ||
        (typeof globalDollarDecrease === 'number' && globalDollarDecrease>0)
    );
    const centralMoversCount = (function(){
        // Prefer *_HITS lengths; else use filtered/total from legacy object
        if (window.globalMoversHits) {
            const up = Array.isArray(window.globalMoversHits.upHits) ? window.globalMoversHits.upHits.length : 0;
            const down = Array.isArray(window.globalMoversHits.downHits) ? window.globalMoversHits.downHits.length : 0;
            return up + down;
        }
        if (window.globalMovers) {
            if (typeof window.globalMovers.filteredTotal === 'number') return window.globalMovers.filteredTotal;
            if (typeof window.globalMovers.totalCount === 'number') return window.globalMovers.totalCount;
        }
        return 0;
    })();
    const legacySummaryCount = (directionalActive && globalAlertSummary && globalAlertSummary.totalCount && (globalAlertSummary.enabled !== false)) ? globalAlertSummary.totalCount : 0;
    // If central doc is unavailable or zero, fall back to the last locally-computed movers snapshot
    const lastSnapshotCount = (window.__lastMoversSnapshot && Array.isArray(window.__lastMoversSnapshot.entries)) ? window.__lastMoversSnapshot.entries.length : 0;
    if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) console.debug('[BANNER-DEBUG] lastSnapshotCount:', lastSnapshotCount);
    // Prefer centralized movers when available to avoid double counting vs legacy GA_SUMMARY
    const effectiveMoversCount = centralMoversCount > 0 ? centralMoversCount : (legacySummaryCount > 0 ? legacySummaryCount : (directionalActive ? lastSnapshotCount : 0));
    const displayCount = enabledCount + effectiveMoversCount + globalHighs + globalLows;
    
    // Debug logging for final count
    console.log('[BANNER-DEBUG] centralMoversCount:', centralMoversCount, 'legacySummaryCount:', legacySummaryCount, 'effectiveMoversCount:', effectiveMoversCount);
    console.log('[BANNER-DEBUG] displayCount:', displayCount);
    const snapshot = window.__lastTargetBannerSnapshot;
    const snapshotUnchanged = snapshot.enabledCount === enabledCount && snapshot.displayCount === displayCount && snapshot.dismissed === !!targetHitIconDismissed;
    if (!snapshotUnchanged) {
        try { console.log('[Diag][updateTargetHitBanner] enabled:', enabledCount, 'displayCount:', displayCount, 'enabled IDs:', (sharesAtTargetPrice||[]).map(s=>s.id)); } catch(_) {}
    } else {
        // If nothing changed but the icon SHOULD be visible and somehow got hidden, restore it.
        const shouldBeVisible = displayCount > 0 && !targetHitIconDismissed;
        const actuallyHidden = targetHitIconBtn.style.display === 'none' || targetHitIconBtn.classList.contains('app-hidden');
        if (!(shouldBeVisible && actuallyHidden)) {
            return; // truly nothing to do
        }
        logDebug('Target Alert: Snapshot unchanged but icon hidden unexpectedly; restoring visibility.');
    }
    if (displayCount > 0 && !targetHitIconDismissed) {
        // Diagnostics: capture state before applying changes
        try {
            console.log('[Diag] targetHitIconBtn element:', targetHitIconBtn);
            console.log('[Diag] BEFORE - className:', targetHitIconBtn.className, 'style.display:', targetHitIconBtn.style.display);
        } catch (_) {}

        targetHitIconCount.textContent = String(displayCount);
        // Ensure visibility: drop any hidden class first, then set display
        targetHitIconBtn.classList.remove('app-hidden');
        targetHitIconCount.classList && targetHitIconCount.classList.remove('app-hidden');
        targetHitIconBtn.style.display = 'inline-flex';
        targetHitIconCount.style.display = 'flex';
        // Double-ensure after layout settles (guards against another late add)
        requestAnimationFrame(() => {
            targetHitIconBtn.classList.remove('app-hidden');
            targetHitIconCount.classList && targetHitIconCount.classList.remove('app-hidden');
        });

        // Diagnostics: capture state after applying changes
        try {
            console.log('[Diag] AFTER - className:', targetHitIconBtn.className, 'style.display:', targetHitIconBtn.style.display);
        } catch (_) {}

    logDebug('Target Alert: Showing icon: ' + displayCount + ' active alerts.');
    } else {
    // Hide the icon explicitly via inline style and class
    targetHitIconBtn.classList.add('app-hidden');
    targetHitIconBtn.style.display = 'none';
    targetHitIconCount.classList && targetHitIconCount.classList.add('app-hidden');
    targetHitIconCount.style.display = 'none';
        logDebug('Target Alert: No triggered alerts or icon dismissed; hiding icon.');
    }

    // Persist last known count for early UI restore
    lastKnownTargetCount = displayCount;
    try { localStorage.setItem('lastKnownTargetCount', String(lastKnownTargetCount)); } catch(e) {}

    // Highlight dropdowns if the current view has target hits
    // Removed toolbar highlight per corrected requirement; only individual rows/cards should show target-hit styling.
    // (Styling enforcement intentionally removed here to prevent duplicate calls; recomputeTriggeredAlerts will invoke it when underlying state changes.)

    // Update snapshot after successful DOM mutation
    snapshot.enabledCount = enabledCount;
    snapshot.displayCount = displayCount;
    snapshot.dismissed = !!targetHitIconDismissed;
}

// Debounced refresh for Notifications modal when it's already open
function refreshNotificationsModalIfOpen(reason) {
    try {
        const modal = (typeof targetHitDetailsModal !== 'undefined') ? targetHitDetailsModal : null;
        if (!modal) return;
        const isVisible = (() => {
            try {
                if (modal.classList && modal.classList.contains('show')) return true;
                if (modal.style && modal.style.display && modal.style.display !== 'none') return true;
                if (window.getComputedStyle) {
                    const computed = window.getComputedStyle(modal);
                    if (computed && computed.display !== 'none' && computed.visibility !== 'hidden' && computed.opacity !== '0') return true;
                }
            } catch(_) {}
            return false;
        })();
        if (!isVisible) return;
        if (window.__notifRefreshScheduled) return;
        window.__notifRefreshScheduled = true;
        setTimeout(() => {
            window.__notifRefreshScheduled = false;
            try {
                const stillVisible = (() => {
                    try {
                        if (modal.classList && modal.classList.contains('show')) return true;
                        if (modal.style && modal.style.display && modal.style.display !== 'none') return true;
                        if (window.getComputedStyle) {
                            const computed = window.getComputedStyle(modal);
                            if (computed && computed.display !== 'none' && computed.visibility !== 'hidden' && computed.opacity !== '0') return true;
                        }
                    } catch(_) {}
                    return false;
                })();
                if (!stillVisible) return;
                const alreadyUserInitiated = !!__userInitiatedTargetModal;
                showTargetHitDetailsModal({
                    explicit: true,
                    userInitiated: alreadyUserInitiated,
                    allowDuringInitialLoad: alreadyUserInitiated && window.__initialLoadPhase,
                    refresh: true,
                    reason
                });
            } catch(_) {}
        }, 250);
    } catch(_) {}
}

// Diagnostic hotkey: Alt+Shift+N dumps notification icon state
try {
    document.addEventListener('keydown', function(e){
        if (e.altKey && e.shiftKey && (e.key === 'N' || e.key === 'n')) {
            try {
                const state = {
                    dismissed: targetHitIconDismissed,
                    lastKnownTargetCount,
                    currentEnabledCount: Array.isArray(sharesAtTargetPrice)?sharesAtTargetPrice.length:0,
                    globalSummaryCount: (globalAlertSummary && globalAlertSummary.totalCount && (globalAlertSummary.enabled !== false)) ? globalAlertSummary.totalCount : 0,
                    btnDisplay: targetHitIconBtn ? targetHitIconBtn.style.display : null,
                    btnClasses: targetHitIconBtn ? targetHitIconBtn.className : null
                };
                console.log('[NotifDiag] Notification Icon State', state);
            } catch(err) { console.warn('[NotifDiag] Failed to dump state', err); }
        }
    }, true);
} catch(_){ }
// NEW (Revised): Real-time alerts listener (enabled-only notifications)
// Muted alerts (enabled === false) must not appear as active notifications or receive styling.
/* moved to dataService.js */
/* async function loadTriggeredAlertsListener() {
    if (unsubscribeAlerts) { try { unsubscribeAlerts(); } catch(_){} unsubscribeAlerts=null; }
    if (!db || !currentUserId || !firestore) { console.warn('Alerts: Firestore unavailable for triggered alerts listener'); return; }
    try {
        const alertsCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/alerts');
        unsubscribeAlerts = firestore.onSnapshot(alertsCol, (qs) => { 
            const newMap = new Map();
            const alertMetaById = new Map();
            qs.forEach(doc => { 
                const d = doc.data() || {}; 
                newMap.set(doc.id, (d.enabled !== false)); 
                alertMetaById.set(doc.id, { intent: d.intent, direction: d.direction });
            });
            alertsEnabledMap = newMap;
            // Propagate intent/direction to existing shares for inline render if missing
            try {
                allSharesData.forEach(s => {
                    const meta = alertMetaById.get(s.id);
                    if (meta) {
                        if (!s.intent && meta.intent) s.intent = meta.intent;
                        if (!s.targetDirection && meta.direction) s.targetDirection = meta.direction;
                    }
                });
            } catch(_) {}
            try { debugLog('[Diag][loadTriggeredAlertsListener] map size:', alertsEnabledMap.size); } catch(_){ }
            recomputeTriggeredAlerts();
            // Re-render watchlist to show newly available intent letters
            try { renderWatchlist(); } catch(_) {}
        }, err => console.error('Alerts: triggered alerts listener error', err));
        logDebug('Alerts: Triggered alerts listener active (enabled-state driven).');
    } catch (e) { console.error('Alerts: failed to init triggered alerts listener', e); }
} */

// Real-time listener for global summary alert documents (both regular and comprehensive)
let unsubscribeGlobalSummary = null;
let unsubscribeGlobalSummaryComprehensive = null;
let unsubscribeGlobalHiLo = null;
let unsubscribeGlobalMovers = null; // NEW: centralized movers listener handle
let unsubscribeCustomTriggerHits = null; // NEW: CUSTOM_TRIGGER_HITS listener handle
// In-memory cache of global 52-week alerts (central, cross-user)
let globalHiLo52Alerts = { updatedAt: null, highs: [], lows: [] };
window.globalHiLo52Alerts = globalHiLo52Alerts;
// In-memory cache of centralized movers document
let globalMovers = { updatedAt: null, up: [], down: [], upCount: 0, downCount: 0, totalCount: 0, thresholds: null };
window.globalMovers = globalMovers;

// Recompute filtered movers outside the modal so diagnostic properties are always present
window.recomputeGlobalMoversFiltered = function recomputeGlobalMoversFiltered(options={}) {
    try {
        const gm = window.globalMovers;
        if (!gm || (!Array.isArray(gm.up) && !Array.isArray(gm.down))) return;
        const rawUp = Array.isArray(gm.up) ? gm.up.slice() : [];
        const rawDown = Array.isArray(gm.down) ? gm.down.slice() : [];
        const rawTotal = rawUp.length + rawDown.length;
        // Build server thresholds (coerce to numbers)
        let server = null;
        if (gm.thresholds) {
            server = {
                upPercent: gm.thresholds.upPercent != null ? Number(gm.thresholds.upPercent) : null,
                upDollar: gm.thresholds.upDollar != null ? Number(gm.thresholds.upDollar) : null,
                downPercent: gm.thresholds.downPercent != null ? Number(gm.thresholds.downPercent) : null,
                downDollar: gm.thresholds.downDollar != null ? Number(gm.thresholds.downDollar) : null,
                minimumPrice: gm.thresholds.minimumPrice != null ? Number(gm.thresholds.minimumPrice) : null
            };
        }
        // Unified local threshold sourcing (globals, localStorage fallback, form inputs) for reliability
        const local = getCurrentDirectionalThresholds();
        function stricter(a,b){ if (a==null) return b; if (b==null) return a; return Math.max(a,b); }
        const effective = {
            upPercent: stricter(local.upPercent, server && server.upPercent),
            upDollar: stricter(local.upDollar, server && server.upDollar),
            downPercent: stricter(local.downPercent, server && server.downPercent),
            downDollar: stricter(local.downDollar, server && server.downDollar),
            minimumPrice: stricter(local.minimumPrice, server && server.minimumPrice)
        };
        const noDir = [effective.upPercent,effective.upDollar,effective.downPercent,effective.downDollar].every(v=>v==null);
        if (noDir && rawTotal>120) { effective.upPercent = 1; effective.downPercent = 1; }
        const filterFn = (item)=>{
            // Prefer computed values, but fall back to provided pct/change when live/prevClose are missing.
            const live = (item.live!=null && !isNaN(item.live)) ? Number(item.live) : null;
            const prev = (item.prevClose!=null && !isNaN(item.prevClose)) ? Number(item.prevClose) : null;
            let ch = null; let pct = null; let dir = null;
            if (live!=null && prev!=null && prev!==0) {
                ch = live - prev;
                pct = (ch/prev)*100;
                dir = ch>0 ? 'up' : (ch<0 ? 'down' : null);
            }
            // Use provided fields as a fallback (central doc often includes pct/change)
            if (pct==null && item.pct!=null && !isNaN(item.pct)) {
                const p = Number(item.pct);
                // Assume magnitude; use direction to sign if available
                const isDown = (item.direction||'').toLowerCase()==='down';
                pct = isDown ? -Math.abs(p) : Math.abs(p);
            }
            if (ch==null && item.change!=null && !isNaN(item.change)) {
                ch = Number(item.change);
            }
            if (!ch && ch!==0 && pct==null) return false; // cannot evaluate at all
            // Respect minimum price only when we know live; if unknown, don't exclude solely on min price
            if (effective.minimumPrice && live!=null && live < effective.minimumPrice) return false;
            // Determine direction using available signals
            if (!dir) {
                if (ch!=null) dir = ch>0?'up':(ch<0?'down':null);
                if (!dir && typeof item.direction==='string') dir = item.direction.toLowerCase();
                if (!dir && pct!=null) dir = pct>=0?'up':'down';
            }
            const pctVal = (pct!=null) ? Number(pct) : (ch!=null && prev!=null && prev!==0 ? (ch/prev)*100 : null);
            const absCh = ch!=null ? Math.abs(ch) : (item.change!=null ? Math.abs(Number(item.change)) : null);
            if (dir==='up') {
                const pctOk = (effective.upPercent!=null && pctVal!=null) ? pctVal >= effective.upPercent : false;
                const dolOk = (effective.upDollar!=null && absCh!=null) ? absCh >= effective.upDollar : false;
                if (!(pctOk || dolOk)) return false;
            } else if (dir==='down') {
                const pctOk = (effective.downPercent!=null && pctVal!=null) ? Math.abs(pctVal) >= effective.downPercent : false;
                const dolOk = (effective.downDollar!=null && absCh!=null) ? absCh >= effective.downDollar : false;
                if (!(pctOk || dolOk)) return false;
            } else {
                // Unknown direction: conservatively include (central doc already qualified it)
            }
            return true;
        };
        const upFiltered = rawUp.filter(filterFn);
        const downFiltered = rawDown.filter(filterFn);
        gm.__rawUp = rawUp; gm.__rawDown = rawDown; gm.__rawTotal = rawTotal;
        gm.__serverThresholds = server; gm.__localThresholds = local; gm.__effectiveThresholds = effective;
        gm.upFiltered = upFiltered; gm.downFiltered = downFiltered; gm.filteredTotal = upFiltered.length + downFiltered.length;
        // Discrepancy logging: identify when local stricter than server so QA can confirm backend alignment
        if (window.DEBUG_MODE) {
            try {
                const disc = {};
                if (server) {
                    ['upPercent','upDollar','downPercent','downDollar','minimumPrice'].forEach(k=>{
                        if (local[k]!=null && server[k]!=null && local[k] > server[k]) disc[k] = { local: local[k], server: server[k] };
                    });
                }
                if (Object.keys(disc).length) console.log('[GlobalMovers][threshold-discrepancy]', disc);
            } catch(_){ }
        }
        if (options.log || window.DEBUG_MODE) {
            try { console.log('[GlobalMovers][recompute]', { rawTotal, filteredTotal: gm.filteredTotal, effective, server, local }); } catch(_){}
        }
    } catch (e) { console.warn('[GlobalMovers][recompute] failed', e); }
};

// Helper returns current directional thresholds from multiple potential sources
window.getCurrentDirectionalThresholds = function getCurrentDirectionalThresholds(){
    function numPos(v){ return (typeof v === 'number' && isFinite(v) && v>0) ? v : null; }
    // Start with globals
    let upPercent = numPos(window.globalPercentIncrease);
    let upDollar = numPos(window.globalDollarIncrease);
    let downPercent = numPos(window.globalPercentDecrease);
    let downDollar = numPos(window.globalDollarDecrease);
    let minimumPrice = numPos(window.globalMinimumPrice);
    // LocalStorage fallbacks (string -> number)
    try {
        if (upPercent==null) { const v = localStorage.getItem('globalPercentIncrease'); if (v!=null) upPercent = numPos(Number(v)); }
        if (upDollar==null) { const v = localStorage.getItem('globalDollarIncrease'); if (v!=null) upDollar = numPos(Number(v)); }
        if (downPercent==null) { const v = localStorage.getItem('globalPercentDecrease'); if (v!=null) downPercent = numPos(Number(v)); }
        if (downDollar==null) { const v = localStorage.getItem('globalDollarDecrease'); if (v!=null) downDollar = numPos(Number(v)); }
        if (minimumPrice==null) { const v = localStorage.getItem('globalMinimumPrice'); if (v!=null) minimumPrice = numPos(Number(v)); }
    } catch(_){ }
    // Form input overrides if user is on settings UI (ensure latest typed values apply before save)
    try {
        // Match index.html where the form id is 'globalAlertsForm' and inputs have ids (not names)
        const form = document.getElementById('globalAlertsForm');
        if (form) {
            const gpI = form.querySelector('#globalPercentIncrease') || document.getElementById('globalPercentIncrease');
            if (gpI && gpI.value) upPercent = numPos(Number(gpI.value));
            const gdI = form.querySelector('#globalDollarIncrease') || document.getElementById('globalDollarIncrease');
            if (gdI && gdI.value) upDollar = numPos(Number(gdI.value));
            const gpD = form.querySelector('#globalPercentDecrease') || document.getElementById('globalPercentDecrease');
            if (gpD && gpD.value) downPercent = numPos(Number(gpD.value));
            const gdD = form.querySelector('#globalDollarDecrease') || document.getElementById('globalDollarDecrease');
            if (gdD && gdD.value) downDollar = numPos(Number(gdD.value));
            const gMin = form.querySelector('#globalMinimumPrice') || document.getElementById('globalMinimumPrice');
            if (gMin && gMin.value) minimumPrice = numPos(Number(gMin.value));
        }
    } catch(_){ }
    return { upPercent, upDollar, downPercent, downDollar, minimumPrice };
};

// Reliability guard: run a few delayed recompute attempts early in the session so that
// diagnostic properties (e.g., __effectiveThresholds) are present even if the user
// inspects window.globalMovers before manually opening the modal. This covers races
// where the Firestore snapshot attaches slightly before local threshold vars are
// hydrated or before the user triggers showGlobalAlertsModal(). Safe + idempotent.
(function ensureEarlyGlobalMoversDiagnostics(){
    try {
        let attempts = 0;
        const maxAttempts = 6; // ~6 * 800ms = <5s worst case
        function tick(){
            try {
                const gm = window.globalMovers;
                if (gm && (Array.isArray(gm.up) || Array.isArray(gm.down))) {
                    if (!gm.__effectiveThresholds) {
                        try { window.recomputeGlobalMoversFiltered({ log:false }); } catch(_) {}
                    }
                    if (gm.__effectiveThresholds) return; // success, stop retries
                }
            } catch(_) {}
            if (++attempts < maxAttempts) setTimeout(tick, 800);
        }
        // Slight initial delay to allow threshold globals to load
        setTimeout(tick, 400);
    } catch(_) {}
})();

// Convenience function to open the global alerts modal with defensive recompute
window.showGlobalAlertsModal = function showGlobalAlertsModal() {
    try { if (typeof hideModal==='function' && targetHitDetailsModal) hideModal(targetHitDetailsModal); } catch(_) {}
    try { window.recomputeGlobalMoversFiltered({ log: window.DEBUG_MODE }); } catch(_){ }
    try {
        if (!globalAlertsModal) { try { globalAlertsModal = document.getElementById('globalAlertsModal'); } catch(_) {} }
        if (typeof showModal === 'function' && globalAlertsModal) {
            showModal(globalAlertsModal);
            try { if (globalPercentIncreaseInput) globalPercentIncreaseInput.focus(); } catch(_) {}
            return true;
        }
    } catch(e){ console.warn('[GlobalAlerts][open] failed to open modal', e); }
    console.warn('[GlobalAlerts][open] modal not available.');
    return false;
};

// Lightweight diagnostic: compare badge count vs modal section counts for quick parity checks
// Returns an object with the computed parts and overall totals. Safe to call anytime.
window.debugGlobalAlertsParity = function debugGlobalAlertsParity() {
    try {
        // Local target hits (user-specific alerts enabled)
        const targets = Array.isArray(window.sharesAtTargetPrice) ? window.sharesAtTargetPrice.length : 0;
        // Central movers (prefer filtered to match modal lists)
        const gm = window.globalMovers || {};
        const ups = Array.isArray(gm.upFiltered) ? gm.upFiltered.length : (Array.isArray(gm.up) ? gm.up.length : 0);
        const downs = Array.isArray(gm.downFiltered) ? gm.downFiltered.length : (Array.isArray(gm.down) ? gm.down.length : 0);
        // Central hi/lo 52-week sections
        const highs = (window.globalHiLo52Alerts && Array.isArray(window.globalHiLo52Alerts.highs)) ? window.globalHiLo52Alerts.highs.length : 0;
        const lows = (window.globalHiLo52Alerts && Array.isArray(window.globalHiLo52Alerts.lows)) ? window.globalHiLo52Alerts.lows.length : 0;
        // Badge computation mirrors updateTargetHitBanner
        const centralMoversCount = (typeof gm.filteredTotal === 'number') ? gm.filteredTotal
            : (typeof gm.totalCount === 'number' ? gm.totalCount : (ups + downs));
        const legacySummaryCount = (window.globalAlertSummary && window.globalAlertSummary.totalCount && (window.globalAlertSummary.enabled !== false))
            ? window.globalAlertSummary.totalCount : 0;
        const directionalActive = (typeof window.isDirectionalThresholdsActive === 'function')
            ? window.isDirectionalThresholdsActive()
            : ((typeof window.globalPercentIncrease === 'number' && window.globalPercentIncrease>0) ||
               (typeof window.globalDollarIncrease === 'number' && window.globalDollarIncrease>0) ||
               (typeof window.globalPercentDecrease === 'number' && window.globalPercentDecrease>0) ||
               (typeof window.globalDollarDecrease === 'number' && window.globalDollarDecrease>0));
        const lastSnapshotCount = (window.__lastMoversSnapshot && Array.isArray(window.__lastMoversSnapshot.entries)) ? window.__lastMoversSnapshot.entries.length : 0;
        const effectiveMoversCount = centralMoversCount > 0 ? centralMoversCount : (legacySummaryCount > 0 ? legacySummaryCount : (directionalActive ? lastSnapshotCount : 0));
        const badgeCount = targets + effectiveMoversCount + highs + lows;
        const modalCount = targets + ups + downs + highs + lows;
        const result = { parts: { targets, movers: { ups, downs, filteredTotal: ups+downs, effectiveMoversCount }, highs, lows },
            sums: { badgeCount, modalCount }, meta: { centralMoversCount, legacySummaryCount, lastSnapshotCount } };
        try { console.log('[Parity]', result); } catch(_) {}
        return result;
    } catch (e) {
        console.warn('[Parity] Failed to compute parity', e);
        return null;
    }
};

function startGlobalSummaryListener() {
    if (unsubscribeGlobalSummary) { try { unsubscribeGlobalSummary(); } catch(_){} unsubscribeGlobalSummary = null; }
    if (unsubscribeGlobalSummaryComprehensive) { try { unsubscribeGlobalSummaryComprehensive(); } catch(_){} unsubscribeGlobalSummaryComprehensive = null; }
    if (!db || !currentUserId || !firestore) return;

    try {
        const alertsCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/alerts');

        // Listener for regular global summary (GA_SUMMARY)
        const summaryRef = firestore.doc(alertsCol, 'GA_SUMMARY');
        unsubscribeGlobalSummary = firestore.onSnapshot(summaryRef, (snap) => {
            if (snap && snap.exists()) {
                const newData = snap.data() || null;
                console.log('[GlobalAlerts] Listener received GA_SUMMARY:', newData);
                if (newData && newData.nonPortfolioCodes) {
                    console.log('[GlobalAlerts] nonPortfolioCodes from Firestore:', newData.nonPortfolioCodes);
            } else {
                    console.log('[GlobalAlerts] WARNING: nonPortfolioCodes missing from GA_SUMMARY!');
                }

                // Only update globalAlertSummary with regular data if we don't have comprehensive data
                if (!globalAlertSummary || globalAlertSummary.comprehensiveScan !== true) {
                    globalAlertSummary = newData;
                    console.log('[GlobalAlerts] Updated with REGULAR scan data (no comprehensive available)');
                }
            } else {
                console.log('[GlobalAlerts] Listener: GA_SUMMARY document does not exist');
                // Don't set to null if we have comprehensive data
                if (!globalAlertSummary || globalAlertSummary.comprehensiveScan !== true) {
                globalAlertSummary = null;
                }
            }
            try { updateTargetHitBanner(); } catch(e) {}
            try { refreshNotificationsModalIfOpen('GA_SUMMARY'); } catch(_) {}
        }, err => {
            console.error('[GlobalAlerts] Regular listener error:', err);
            console.error('Global Alerts: summary listener error', err);
        });

        // Listener for comprehensive global summary (GA_SUMMARY_COMPREHENSIVE)
        const comprehensiveSummaryRef = firestore.doc(alertsCol, 'GA_SUMMARY_COMPREHENSIVE');
        unsubscribeGlobalSummaryComprehensive = firestore.onSnapshot(comprehensiveSummaryRef, (snap) => {
            if (snap && snap.exists()) {
                const comprehensiveData = snap.data() || null;
                console.log('[GlobalAlerts] Listener received GA_SUMMARY_COMPREHENSIVE:', comprehensiveData);
                if (comprehensiveData && comprehensiveData.nonPortfolioCodes) {
                    console.log('[GlobalAlerts] Comprehensive nonPortfolioCodes from Firestore:', comprehensiveData.nonPortfolioCodes);
                }

                // Always prioritize comprehensive data over regular data
                globalAlertSummary = comprehensiveData;
                console.log('[GlobalAlerts] Updated with COMPREHENSIVE scan data');
            } else {
                console.log('[GlobalAlerts] Listener: GA_SUMMARY_COMPREHENSIVE document does not exist');
                // Keep existing comprehensive data if available, otherwise fall back to regular data
            }
            try { updateTargetHitBanner(); } catch(e) {}
            try { refreshNotificationsModalIfOpen('GA_SUMMARY_COMPREHENSIVE'); } catch(_) {}
        }, err => {
            console.error('[GlobalAlerts] Comprehensive listener error:', err);
        });

        logDebug('Global Alerts: Summary listeners active (regular + comprehensive).');
    } catch(e) { console.error('Global Alerts: failed to start summary listeners', e); }
}

// Listener for centralized global 52-week highs/lows list stored in a shared collection
function startGlobalHiLoListener() {
    if (unsubscribeGlobalHiLo) { try { unsubscribeGlobalHiLo(); } catch(_){} unsubscribeGlobalHiLo = null; }
    // Auth / env gating: ensure user and app are established
    if (!db || !firestore || !currentAppId) { console.log('[HiLo52][defer] DB/firestore/appId not ready'); return; }
    const uid = (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) ? window.firebase.auth().currentUser.uid : currentUserId;
    if (!uid) { console.log('[HiLo52][defer] auth UID not ready'); return; }
    try { verifyCentralAlertsAccess && verifyCentralAlertsAccess(); } catch(_) {}
    // Use persistent daily HITS document
    const path = 'artifacts/' + currentAppId + '/alerts/HI_LO_52W_HITS';
    if (!window.__centralRetry) window.__centralRetry = { hiLo: 0, movers: 0 };
    console.log('[HiLo52][attach] path=' + path + ' appId=' + currentAppId + ' uid=' + uid + ' attempt=' + (window.__centralRetry.hiLo+1));
    try {
        const docRef = firestore.doc(db, path);
        unsubscribeGlobalHiLo = firestore.onSnapshot(docRef, (snap) => {
            if (snap.exists()) {
                const data = snap.data() || {};
                // Persist hits and also project to legacy structure for compatibility
                const hits = {
                    updatedAt: data.updatedAt || null,
                    highHits: Array.isArray(data.highHits) ? data.highHits : (Array.isArray(data.highs) ? data.highs : []),
                    lowHits: Array.isArray(data.lowHits) ? data.lowHits : (Array.isArray(data.lows) ? data.lows : [])
                };
                window.globalHiLo52Hits = hits;
                // Back-compat projection (so old UI paths can still render if referenced)
                globalHiLo52Alerts = {
                    updatedAt: hits.updatedAt,
                    highs: hits.highHits,
                    lows: hits.lowHits
                };
                window.globalHiLo52Alerts = globalHiLo52Alerts;
                try { window.__hiLoListenerError = false; } catch(_) {}
                if (window.__centralRetry) window.__centralRetry.hiLo = 0; // reset on success
            } else {
                window.globalHiLo52Hits = { updatedAt: null, highHits: [], lowHits: [] };
                globalHiLo52Alerts = { updatedAt: null, highs: [], lows: [] };
                window.globalHiLo52Alerts = globalHiLo52Alerts;
            }
            try { updateTargetHitBanner(); } catch(_) {}
            try { refreshNotificationsModalIfOpen('HI_LO_52W_HITS'); } catch(_) {}
        }, (err) => {
            console.warn('[HiLo52] Listener error', err);
            try { window.__hiLoListenerError = true; window.__hiLoListenerErrorMessage = (err && (err.message || err.code)) || 'Listener error'; } catch(_) {}
            // Retry only on permission/auth related issues and only a few times
            const code = err && (err.code || err.message || '');
            if (/permission|auth|insufficient/i.test(code) && window.__centralRetry.hiLo < 5) {
                const attempt = ++window.__centralRetry.hiLo;
                const delay = Math.min(8000, 500 * Math.pow(2, attempt-1));
                console.log('[HiLo52][retry] Scheduling reattach attempt ' + attempt + ' in ' + delay + 'ms');
                setTimeout(() => { try { startGlobalHiLoListener(); } catch(e2){ console.warn('[HiLo52][retry] failed reattach', e2);} }, delay);
            }
            try { updateTargetHitBanner(); } catch(_) {}
        });
    } catch (e) { console.warn('[HiLo52] Failed to attach listener', e); }
}

function stopGlobalHiLoListener() {
    if (unsubscribeGlobalHiLo) { try { unsubscribeGlobalHiLo(); } catch(_) {} unsubscribeGlobalHiLo = null; }
}

// Listener for centralized global movers document (percent / dollar movers, cross-user)
function startGlobalMoversListener() {
    if (unsubscribeGlobalMovers) { try { unsubscribeGlobalMovers(); } catch(_){} unsubscribeGlobalMovers = null; }
    if (!db || !firestore || !currentAppId) { console.log('[Movers][defer] DB/firestore/appId not ready'); return; }
    const uid = (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) ? window.firebase.auth().currentUser.uid : currentUserId;
    if (!uid) { console.log('[Movers][defer] auth UID not ready'); return; }
    try { verifyCentralAlertsAccess && verifyCentralAlertsAccess(); } catch(_) {}
    if (!window.__centralRetry) window.__centralRetry = { hiLo: 0, movers: 0 };
    // Use persistent daily HITS document
    const path = 'artifacts/' + currentAppId + '/alerts/GLOBAL_MOVERS_HITS';
    console.log('[Movers][attach] path=' + path + ' appId=' + currentAppId + ' uid=' + uid + ' attempt=' + (window.__centralRetry.movers+1));
    try {
        const docRef = firestore.doc(db, path);
        unsubscribeGlobalMovers = firestore.onSnapshot(docRef, (snap) => {
            if (snap && snap.exists()) {
                const data = snap.data() || {};
                const moversHits = {
                    updatedAt: data.updatedAt || null,
                    upHits: Array.isArray(data.upHits) ? data.upHits : (Array.isArray(data.up) ? data.up : []),
                    downHits: Array.isArray(data.downHits) ? data.downHits : (Array.isArray(data.down) ? data.down : [])
                };
                window.globalMoversHits = moversHits;
                // Back-compat projection to legacy shape expected by some renderers
                globalMovers = {
                    updatedAt: moversHits.updatedAt,
                    up: moversHits.upHits,
                    down: moversHits.downHits,
                    upCount: (moversHits.upHits || []).length,
                    downCount: (moversHits.downHits || []).length,
                    totalCount: ((moversHits.upHits || []).length + (moversHits.downHits || []).length),
                    thresholds: null
                };
                window.globalMovers = globalMovers;
                try { if (window.recomputeGlobalMoversFiltered) window.recomputeGlobalMoversFiltered({ log:false }); } catch(_) {}
                if (window.__centralRetry) window.__centralRetry.movers = 0; // reset on success
            } else {
                window.globalMoversHits = { updatedAt: null, upHits: [], downHits: [] };
                globalMovers = { updatedAt: null, up: [], down: [], upCount: 0, downCount: 0, totalCount: 0, thresholds: null };
                window.globalMovers = globalMovers;
                try { if (window.recomputeGlobalMoversFiltered) window.recomputeGlobalMoversFiltered({ log:false }); } catch(_) {}
            }
                try { updateTargetHitBanner(); } catch(_) {}
                try { refreshNotificationsModalIfOpen('GLOBAL_MOVERS_HITS'); } catch(_) {}
        }, (err) => {
            console.warn('[GlobalMovers] Listener error', err);
            try { window.__globalMoversListenerError = true; window.__globalMoversListenerErrorMessage = (err && (err.message||err.code)) || 'Listener error'; } catch(_) {}
            const code = err && (err.code || err.message || '');
            if (/permission|auth|insufficient/i.test(code) && window.__centralRetry.movers < 5) {
                const attempt = ++window.__centralRetry.movers;
                const delay = Math.min(8000, 500 * Math.pow(2, attempt-1));
                console.log('[Movers][retry] Scheduling reattach attempt ' + attempt + ' in ' + delay + 'ms');
                setTimeout(() => { try { startGlobalMoversListener(); } catch(e2){ console.warn('[Movers][retry] failed reattach', e2);} }, delay);
            }
            try { updateTargetHitBanner(); } catch(_) {}
        });
    } catch(e) { console.warn('[GlobalMovers] Failed to attach listener', e); }
}

function stopGlobalMoversListener() {
    if (unsubscribeGlobalMovers) { try { unsubscribeGlobalMovers(); } catch(_){} unsubscribeGlobalMovers = null; }
}

function stopGlobalSummaryListener() {
    if (unsubscribeGlobalSummary) { try { unsubscribeGlobalSummary(); } catch(_){} unsubscribeGlobalSummary = null; }
    if (unsubscribeGlobalSummaryComprehensive) { try { unsubscribeGlobalSummaryComprehensive(); } catch(_){} unsubscribeGlobalSummaryComprehensive = null; }
}

// Listener for persistent daily custom triggers (user targets + duplicated portfolio hits)
function startCustomTriggerHitsListener() {
    if (unsubscribeCustomTriggerHits) { try { unsubscribeCustomTriggerHits(); } catch(_){} unsubscribeCustomTriggerHits = null; }
    if (!db || !firestore || !currentAppId) { console.log('[CustomHits][defer] DB/firestore/appId not ready'); return; }
    const uid = (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) ? window.firebase.auth().currentUser.uid : currentUserId;
    if (!uid) { console.log('[CustomHits][defer] auth UID not ready'); return; }
    const path = 'artifacts/' + currentAppId + '/alerts/CUSTOM_TRIGGER_HITS';
    console.log('[CustomHits][attach] path=' + path + ' appId=' + currentAppId + ' uid=' + uid);
    try {
        const docRef = firestore.doc(db, path);
        unsubscribeCustomTriggerHits = firestore.onSnapshot(docRef, (snap) => {
            if (snap && snap.exists()) {
                const data = snap.data() || {};
                window.customTriggerHits = {
                    updatedAt: data.updatedAt || null,
                    hits: Array.isArray(data.hits) ? data.hits : []
                };
            } else {
                window.customTriggerHits = { updatedAt: null, hits: [] };
            }
            try { updateTargetHitBanner(); } catch(_) {}
            try { refreshNotificationsModalIfOpen('CUSTOM_TRIGGER_HITS'); } catch(_) {}
        }, (err) => {
            console.warn('[CustomHits] Listener error', err);
        });
    } catch(e) { console.warn('[CustomHits] Failed to attach listener', e); }
}

function stopCustomTriggerHitsListener() {
    if (unsubscribeCustomTriggerHits) { try { unsubscribeCustomTriggerHits(); } catch(_){} unsubscribeCustomTriggerHits = null; }
}

// Lightweight verification helper to differentiate between:
//  (a) Security rules denial (true permission issue)
//  (b) Missing central document (backend hasn't produced it yet)
//  (c) Project / path mismatch (wrong appId)
//  (d) Auth not yet established at probe time
// Exposes diagnostic flags on window for quick console inspection.
window.verifyCentralAlertsAccess = async function verifyCentralAlertsAccess() {
    if (!db || !firestore) { console.log('[CentralVerify] Firestore not ready'); return; }
    const appId = currentAppId;
    const uid = (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) ? window.firebase.auth().currentUser.uid : currentUserId;
    if (!uid) { console.log('[CentralVerify] Skipped (no auth user yet)'); return; }
    const targets = [
        { key: 'HI_LO_52W_HITS', path: 'artifacts/' + appId + '/alerts/HI_LO_52W_HITS' },
        { key: 'GLOBAL_MOVERS_HITS', path: 'artifacts/' + appId + '/alerts/GLOBAL_MOVERS_HITS' },
        { key: 'CUSTOM_TRIGGER_HITS', path: 'artifacts/' + appId + '/alerts/CUSTOM_TRIGGER_HITS' }
    ];
    if (!window.__centralDiag) window.__centralDiag = {};
    for (const t of targets) {
        try {
            const ref = firestore.doc(db, t.path);
            const snap = await firestore.getDoc(ref);
            if (snap.exists()) {
                window.__centralDiag[t.key] = { exists: true, lastUpdated: snap.data().updatedAt || null, status: 'ok' };
                console.log('[CentralVerify] ' + t.key + ' OK (exists)');
            } else {
                window.__centralDiag[t.key] = { exists: false, status: 'missing' };
                console.warn('[CentralVerify] ' + t.key + ' document missing (not necessarily a permission issue)');
            }
        } catch(e) {
            const msg = (e && (e.code || e.message)) || String(e);
            const perm = /permission|denied|insufficient|auth/i.test(msg);
            window.__centralDiag[t.key] = { error: msg, permissionLike: perm, status: 'error' };
            console.error('[CentralVerify] ' + t.key + ' error:', msg);
        }
    }
    try { window.__centralDiag.lastProbe = new Date().toISOString(); } catch(_) {}
};

// Diagnostic helper: dumps movers listener diagnostic info and last local snapshot
window.dumpCentralMoversDiag = function dumpCentralMoversDiag() {
    try {
        const diag = {
            appId: currentAppId || null,
            userId: currentUserId || null,
            globalMovers: window.globalMovers || null,
            lastMoversSnapshot: window.__lastMoversSnapshot || null,
            centralDiag: window.__centralDiag || null,
            listenerError: window.__globalMoversListenerError || false,
            listenerErrorMessage: window.__globalMoversListenerErrorMessage || null
        };
        console.log('[MoversDiag]', diag);
        return diag;
    } catch (e) { console.error('[MoversDiag] dump failed', e); return null; }
};

// Apply a temporary filter to main watchlist showing only shares that match the last summary counts
function applyGlobalSummaryFilter(options = {}) {
    // New logic: compute movers directly from directional thresholds instead of relying on aggregated summary threshold label.
    if (!livePrices) {
        if (options.computeOnly) {
            // For computeOnly mode, return empty array if no live prices
            return [];
        }
        return null;
    }
    const hasUp = (typeof globalPercentIncrease === 'number' && globalPercentIncrease > 0) || (typeof globalDollarIncrease === 'number' && globalDollarIncrease > 0);
    const hasDown = (typeof globalPercentDecrease === 'number' && globalPercentDecrease > 0) || (typeof globalDollarDecrease === 'number' && globalDollarDecrease > 0);
    // If no thresholds configured at all, use default thresholds for movers view
    let usedDefaults = false;
    // Capture originals so we can restore if we temporarily apply defaults
    let __origPercentIncrease, __origPercentDecrease, __origDollarIncrease, __origDollarDecrease;
    if (!hasUp && !hasDown) {
        if (options.computeOnly) {
            // For computeOnly mode (used by movers view), use default 1% threshold
            // Store original values to restore later
            __origPercentIncrease = globalPercentIncrease;
            __origPercentDecrease = globalPercentDecrease;
            __origDollarIncrease = globalDollarIncrease;
            __origDollarDecrease = globalDollarDecrease;

            globalPercentIncrease = 1.0;
            globalPercentDecrease = 1.0;
            globalDollarIncrease = null;
            globalDollarDecrease = null;
            usedDefaults = true;
            console.log('[applyGlobalSummaryFilter] Using default 1% thresholds for movers computation');
        } else {
            return [];
        }
    }
    const entries = [];
    Object.entries(livePrices).forEach(([code, lp]) => {
        if (!lp || lp.live == null || lp.prevClose == null) return;
        const prev = lp.prevClose;
        if (prev == null) return;
        const live = lp.live;
        if (globalMinimumPrice && live < globalMinimumPrice) return; // respect minimum price filter
        const change = live - prev;
        if (change === 0) return;
        const up = change > 0;
        const absChange = Math.abs(change);
        const pctSigned = prev !== 0 ? (change / prev) * 100 : 0; // signed percent
        const pctMagnitude = Math.abs(pctSigned);
        let include = false;
        if (up && hasUp) {
            if ((globalPercentIncrease && pctSigned >= globalPercentIncrease) || (globalDollarIncrease && change >= globalDollarIncrease)) include = true;
        } else if (!up && hasDown) {
            if ((globalPercentDecrease && pctMagnitude >= globalPercentDecrease) || (globalDollarDecrease && absChange >= globalDollarDecrease)) include = true;
        }
        if (include) {
            entries.push({ code, change, absChange, pct: pctMagnitude, direction: up ? 'up' : 'down', live, prev });
        }
    });
    // Sort: primary by direction grouping (ups first), then by percent magnitude descending
    entries.sort((a,b)=>{
        if (a.direction !== b.direction) return a.direction === 'up' ? -1 : 1;
        return b.pct - a.pct;
    });
    try { if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) console.debug('[applyGlobalSummaryFilter][recomputed]', { hasUp, hasDown, count: entries.length }); } catch(_) {}
    const filteredEntries = entries;
    const filteredCodes = filteredEntries.map(e=>e.code);
    if (!filteredCodes.length) {
        if (!options.silent) showCustomAlert('No shares currently meet the summary threshold.');
        return [];
    }
    try { window.__lastMoversSnapshot = { ts: Date.now(), entries: filteredEntries }; } catch(_) {}

    // Restore original threshold values if we used defaults
    if (usedDefaults) {
        globalPercentIncrease = __origPercentIncrease;
        globalPercentDecrease = __origPercentDecrease;
        globalDollarIncrease = __origDollarIncrease;
        globalDollarDecrease = __origDollarDecrease;
        console.log('[applyGlobalSummaryFilter] Restored original threshold values after movers computation');
    }

    if (!options.computeOnly) {
        // Direct DOM filtering (legacy behavior) – retained for backward compatibility
        try {
            document.querySelectorAll('#shareTable tbody tr').forEach(tr => {
                const codeEl = tr.querySelector('.share-code-display');
                const code = codeEl ? codeEl.textContent.trim().toUpperCase() : null;
                tr.style.display = (code && filteredCodes.includes(code)) ? '' : 'none';
            });
            document.querySelectorAll('.mobile-share-cards .mobile-card').forEach(card => {
                const codeEl = card.querySelector('h3');
                const code = codeEl ? codeEl.textContent.trim().toUpperCase() : null;
                card.style.display = (code && filteredCodes.includes(code)) ? '' : 'none';
            });
            if (!options.silent) showCustomAlert('Filtered to ' + filteredCodes.length + ' global alert matches');
        } catch(e){ console.warn('Global filter UI error', e); }
    }
    return filteredEntries;
}

// Enforce virtual Movers view: after a render, hide non-mover rows/cards; restore when leaving
function enforceMoversVirtualView(force) {
    const isMovers = getCurrentSelectedWatchlistIds() && getCurrentSelectedWatchlistIds()[0] === '__movers';
    if (isMovers) {
        // Safety: ensure persistence keys reflect Movers so reload restores correctly even if earlier writes were skipped
    try { setLastSelectedView('__movers'); } catch(_) {}
        try { localStorage.setItem('lastWatchlistSelection', JSON.stringify(['__movers'])); } catch(_) {}
        try { sessionStorage.setItem('preResetLastSelectedView','__movers'); } catch(_) {}
    }
    const tableRows = document.querySelectorAll('#shareTable tbody tr');
    const mobileCards = document.querySelectorAll('.mobile-share-cards .mobile-card');
    if (!isMovers) {
        tableRows.forEach(tr => { tr.style.display = ''; });
        mobileCards.forEach(card => { card.style.display = ''; });
    // Clear any pending retry when leaving movers view
    try { if (window.__moversRetryTimer) { clearTimeout(window.__moversRetryTimer); window.__moversRetryTimer = null; } } catch(_) {}
        return;
    }
    // Recompute movers (fresh live movement) – fallback to snapshot only if recompute fails. Force flag triggers unconditional recompute.
    let moversEntries = [];
    let recomputeFailed = false;
    try { moversEntries = applyGlobalSummaryFilter({ silent: true, computeOnly: true }) || []; }
    catch(e){ console.warn('Movers enforce: fresh compute failed', e); recomputeFailed = true; }
    const hasActiveThresholds = (typeof globalPercentIncrease === 'number' && globalPercentIncrease>0) ||
        (typeof globalDollarIncrease === 'number' && globalDollarIncrease>0) ||
        (typeof globalPercentDecrease === 'number' && globalPercentDecrease>0) ||
        (typeof globalDollarDecrease === 'number' && globalDollarDecrease>0);
    if (!hasActiveThresholds) {
        // Purge stale snapshot so clearing thresholds empties movers immediately
        if (window.__lastMoversSnapshot) { try { delete window.__lastMoversSnapshot; } catch(_) {} }
    } else if (!moversEntries.length && window.__lastMoversSnapshot && window.__lastMoversSnapshot.entries) {
        moversEntries = window.__lastMoversSnapshot.entries;
    }
    const codeSet = new Set(moversEntries.map(e => e.code));
    const userCodes = new Set((allSharesData||[]).map(s => (s && s.shareName ? s.shareName.toUpperCase() : null)).filter(Boolean));
    const effectiveCodes = new Set();
    codeSet.forEach(c => { if (userCodes.has(c)) effectiveCodes.add(c); });
    tableRows.forEach(tr => {
        const codeEl = tr.querySelector('.share-code-display');
        const code = codeEl ? codeEl.textContent.trim().toUpperCase() : null;
        tr.style.display = (code && effectiveCodes.has(code)) ? '' : 'none';
    });
    mobileCards.forEach(card => {
        const codeEl = card.querySelector('h3');
        const code = codeEl ? codeEl.textContent.trim().toUpperCase() : null;
        card.style.display = (code && effectiveCodes.has(code)) ? '' : 'none';
    });

    // If first attempt yielded no visible movers but data exists, schedule one retry after a short delay
    if (isMovers && effectiveCodes.size === 0 && (allSharesData && allSharesData.length > 0)) {
        if (!window.__moversRetryTimer) {
            window.__moversRetryTimer = setTimeout(() => {
                window.__moversRetryTimer = null;
                // Re-run only if still in movers view and nothing visible
                const stillMovers = getCurrentSelectedWatchlistIds() && getCurrentSelectedWatchlistIds()[0] === '__movers';
                const anyVisible = Array.from(document.querySelectorAll('#shareTable tbody tr,.mobile-share-cards .mobile-card'))
                    .some(el => el.style.display !== 'none');
                if (stillMovers && !anyVisible) {
                    try { enforceMoversVirtualView(); } catch(e){ console.warn('Movers retry failed', e); }
                }
            }, 1200); // allow livePrices / snapshots to populate
        }
    }
    if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
        try { console.debug('[Movers enforce] totalFresh=', moversEntries.length, 'portfolioMatch=', effectiveCodes.size); } catch(_) {}
    }
    // Always emit a lightweight periodic summary (throttled) so user logs show counts even if group/table not expanded
    try {
        const nowTs = Date.now();
        if (!window.__lastMoversEnforceSummaryTs || (nowTs - window.__lastMoversEnforceSummaryTs) > 1500) {
            window.__lastMoversEnforceSummaryTs = nowTs;
            console.log('[Movers enforce][summary] fresh=' + moversEntries.length + ' effectiveLocal=' + effectiveCodes.size + ' (visible rows/cards may differ pre-filter render)');
        }
    } catch(_) {}
}

// DEBUG: Deep consistency checker for Movers virtual watchlist
function debugMoversConsistency(options = {}) {
    const opts = { logVisible: true, recompute: true, ...options };
    const now = new Date().toISOString();
    const result = { ts: now };
    try {
        // Fresh recompute (doesn't touch DOM) unless disabled
        let fresh = [];
        if (opts.recompute) {
            try { fresh = applyGlobalSummaryFilter({ silent: true, computeOnly: true }) || []; }
            catch(e){ console.warn('[MoversDebug] recompute failed', e); }
        } else if (window.__lastMoversSnapshot) {
            fresh = window.__lastMoversSnapshot.entries || [];
        }
        const freshCodes = fresh.map(e=>e.code).sort();
        // Snapshot codes
        const snapCodes = (window.__lastMoversSnapshot && window.__lastMoversSnapshot.entries ? window.__lastMoversSnapshot.entries.map(e=>e.code).sort() : []);
        // Visible DOM codes (table + mobile) that are currently displayed
        const visibleTable = Array.from(document.querySelectorAll('#shareTable tbody tr'))
            .filter(tr => tr.style.display !== 'none')
            .map(tr => { const el = tr.querySelector('.share-code-display'); return el ? el.textContent.trim().toUpperCase() : null; })
            .filter(Boolean);
        const visibleMobile = Array.from(document.querySelectorAll('.mobile-share-cards .mobile-card'))
            .filter(card => card.style.display !== 'none')
            .map(card => { const el = card.querySelector('h3'); return el ? el.textContent.trim().toUpperCase() : null; })
            .filter(Boolean);
        const visibleAll = Array.from(new Set([...visibleTable, ...visibleMobile])).sort();
        // Portfolio codes universe
        const portfolioCodes = (allSharesData||[]).map(s=> s && s.shareName ? s.shareName.toUpperCase() : null).filter(Boolean).sort();
        // Effective local movers = intersection freshCodes ∩ portfolioCodes
        const effectiveLocal = freshCodes.filter(c => portfolioCodes.includes(c));
        // Diffs
        const missingVisible = effectiveLocal.filter(c => !visibleAll.includes(c));
        const extraVisible = visibleAll.filter(c => !effectiveLocal.includes(c));
        result.freshCount = freshCodes.length;
        result.snapshotCount = snapCodes.length;
        result.visibleCount = visibleAll.length;
        result.effectiveLocalCount = effectiveLocal.length;
        result.missingVisible = missingVisible;
        result.extraVisible = extraVisible;
        if (opts.includeLists || window.__logMoversVerbose) {
            result.freshCodes = freshCodes;
            result.snapshotCodes = snapCodes;
            result.visibleAll = visibleAll;
            result.effectiveLocal = effectiveLocal;
        }
        console.groupCollapsed('%c[MoversDebug] Consistency ' + now,'color:#3a7bd5;font-weight:600;');
        console.table(result);
        // Emit a one-line summary outside the collapsed group so copy/paste of raw console lines captures the key metrics
        try {
            console.log('[MoversDebug][summary] fresh=' + result.freshCount + ' snapshot=' + result.snapshotCount + ' effectiveLocal=' + result.effectiveLocalCount + ' visible=' + result.visibleCount + ' missing=' + result.missingVisible.length + ' extra=' + result.extraVisible.length);
        } catch(_) {}
        if (missingVisible.length || extraVisible.length) {
            console.warn('[MoversDebug] Discrepancy detected: missingVisible=', missingVisible, 'extraVisible=', extraVisible);
        } else {
            console.info('[MoversDebug] No discrepancies.');
        }
        console.groupEnd();
    } catch(err) {
        console.error('[MoversDebug] Failed', err);
    }
    return result;
}
window.debugMoversConsistency = debugMoversConsistency; // expose globally

// Hotkey: Alt+Shift+M to dump Movers consistency when in Movers view
document.addEventListener('keydown', (e)=>{
    try {
        if (e.altKey && e.shiftKey && e.code === 'KeyM') {
            if (getCurrentSelectedWatchlistIds() && getCurrentSelectedWatchlistIds()[0] === '__movers') {
                debugMoversConsistency({ includeLists: true });
            } else {
                console.info('[MoversDebug] Hotkey pressed but not in Movers view.');
            }
        }
    } catch(_) {}
}, true);

// NEW: Helper to enable/disable a specific alert for a share
// Toggle alert enabled flag (if currently enabled -> disable; if disabled -> enable)
async function toggleAlertEnabled(shareId) {
    try {
        if (!db || !currentUserId || !firestore) throw new Error('Firestore not available');
        const alertsCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/alerts');
        const alertDocRef = firestore.doc(alertsCol, shareId);
        // Fetch current state (gracefully handle missing doc by creating one)
        let currentEnabled = true; // default enabled if field missing
        try {
            const snap = await firestore.getDoc(alertDocRef);
            if (snap.exists()) {
                const data = snap.data();
                currentEnabled = (data.enabled !== false); // undefined => true
            } else {
                // If doc missing, create baseline alert doc shell so user can mute/unmute going forward
                await firestore.setDoc(alertDocRef, { enabled: true, createdAt: firestore.serverTimestamp(), updatedAt: firestore.serverTimestamp() }, { merge: true });
                currentEnabled = true;
            }
        } catch(fetchErr) {
            console.warn('Alerts: Could not fetch current alert doc for toggle; assuming enabled.', fetchErr);
        }
        const newEnabled = !currentEnabled; // invert
        await firestore.setDoc(alertDocRef, { enabled: newEnabled, updatedAt: firestore.serverTimestamp() }, { merge: true });
    // Optimistic map update then recompute
    alertsEnabledMap.set(shareId, newEnabled);
    try { recomputeTriggeredAlerts(); } catch(e) {}
        showCustomAlert(newEnabled ? 'Alert unmuted' : 'Alert muted', 1000);
    return newEnabled;
    } catch (e) {
        console.error('Alerts: Failed to toggle enabled for share ' + shareId, e);
        showCustomAlert('Failed to update alert. Please try again.', 1500);
    throw e;
    }
}
// NEW: Recompute triggered alerts from livePrices + alertsEnabledMap (global portfolio scope)
function recomputeTriggeredAlerts() {
    // Guard: during initial load phase never auto-open the target modal (even if shares already at target)
    const suppressAutoOpen = !!window.__initialLoadPhase || !ALLOW_ALERT_MODAL_AUTO_OPEN;
    const enabled = [];
    const muted = [];
    const lpEntries = Object.entries(livePrices || {});
    const byCode = new Map();
    // Build lookup by several possible identifier fields to be tolerant of varying shapes
    (allSharesData||[]).forEach(s => {
        if (!s) return;
        try {
            const pushKey = (k) => { if (k && typeof k === 'string') byCode.set(k.toUpperCase(), s); };
            if (s.shareName) pushKey(s.shareName);
            if (s.code) pushKey(s.code);
            if (s.shareCode) pushKey(s.shareCode);
            if (s.symbol) pushKey(s.symbol);
            // also accept companyName as a fallback (rare)
            if (s.companyName) pushKey(s.companyName);
        } catch(_) {}
    });
    
            const missingMatchCodes = [];
            lpEntries.forEach(([code, lp]) => {
                    if (!lp || !lp.targetHit) return; // only shares currently at target
                    const share = byCode.get(code) || byCode.get(String(code).toUpperCase());
                    if (!share) {
                        missingMatchCodes.push(code);
                        return;
                    }
                    const enabledState = alertsEnabledMap.has(share.id) ? alertsEnabledMap.get(share.id) : true;
                    const clone = { ...share };
                    if (enabledState) enabled.push(clone); else muted.push(clone);
                });
    const newEnabled = dedupeSharesById(enabled);
    const newMuted = dedupeSharesById(muted);
    // Build signatures to detect no-op updates
    const sigEnabled = newEnabled.map(s=>s.id).sort().join(',');
    const sigMuted = newMuted.map(s=>s.id).sort().join(',');
    const prevEnabledSig = recomputeTriggeredAlerts.__lastEnabledSig;
    const prevMutedSig = recomputeTriggeredAlerts.__lastMutedSig;
    if (sigEnabled === prevEnabledSig && sigMuted === prevMutedSig) {
        // Nothing changed; skip downstream expensive/UI work
        return;
    }
    recomputeTriggeredAlerts.__lastEnabledSig = sigEnabled;
    recomputeTriggeredAlerts.__lastMutedSig = sigMuted;
    setSharesAtTargetPrice(newEnabled); // active notifications
    sharesAtTargetPriceMuted = newMuted; // muted notifications
    try { console.log('[Diag][recomputeTriggeredAlerts] enabledIds:', newEnabled.map(s=>s.id), 'mutedIds:', newMuted.map(s=>s.id)); } catch(_){ }
    if (missingMatchCodes.length > 0) {
        try { console.warn('[Diag][recomputeTriggeredAlerts] livePrices had targetHit for codes with no matching allSharesData entry:', missingMatchCodes.slice(0,20)); } catch(_){}
    }
    updateTargetHitBanner();
    try { enforceTargetHitStyling(); } catch(_) {}
    if (!suppressAutoOpen && targetHitDetailsModal && targetHitDetailsModal.style.display !== 'none') {
        const noEnabled = sharesAtTargetPrice.length === 0;
        const noMuted = !sharesAtTargetPriceMuted || sharesAtTargetPriceMuted.length === 0;
        if (noEnabled && noMuted) {
            try { hideModal(targetHitDetailsModal); } catch(_) {}
        } else {
            showTargetHitDetailsModal();
        }
    }
}

// === Global Price Alerts (Original approach - uses existing data only) ===

// Original approach: Only uses existing data (livePrices + globalExternalPriceRows)
// No new API calls to Google Apps Script - quota safe!

// Helper function to evaluate all ASX shares
// Removed evaluateAllAsxShares function - using original quota-safe approach instead
// Removed evaluateAllAsxShares function - using original quota-safe approach instead












































































































function evaluateGlobalPriceAlerts() {
    if (!currentUserId || !db || !firestore) return;
    const hasIncrease = (globalPercentIncrease && globalPercentIncrease > 0) || (globalDollarIncrease && globalDollarIncrease > 0);
    const hasDecrease = (globalPercentDecrease && globalPercentDecrease > 0) || (globalDollarDecrease && globalDollarDecrease > 0);
    if (!hasIncrease && !hasDecrease) return;

    console.log('[GlobalAlerts] Starting evaluation with thresholds:', {
        globalPercentIncrease,
        globalDollarIncrease,
        globalPercentDecrease,
        globalDollarDecrease,
        globalMinimumPrice,
        hasIncrease,
        hasDecrease
    });
    const alertsCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/alerts');
    let increaseCount = 0; let decreaseCount = 0; let dominantThreshold = null; let dominantType = null;
    const nonPortfolioCodes = new Set();
    let portfolioCount = 0; // number of triggered shares in user's portfolio/watchlists
    // Build quick lookup of portfolio/watchlist codes the user owns
    const userCodes = new Set();
    (allSharesData||[]).forEach(s => { if (s && s.shareName) userCodes.add(s.shareName.toUpperCase()); });
    if (DEBUG_MODE) console.log('[GlobalAlerts] Evaluating with thresholds', { globalPercentIncrease, globalDollarIncrease, globalPercentDecrease, globalDollarDecrease });
    // Helper to eval a single movement
    function evaluateMovement(code, live, prev) {
        if (live == null || prev == null) return;
        if (globalMinimumPrice && live < globalMinimumPrice) return; // apply minimum price filter
        const change = live - prev; if (change === 0) return;
        const absChange = Math.abs(change);
        const pct = prev !== 0 ? (absChange / prev) * 100 : 0;
        let triggered = false; let type = null; let thresholdHit = null;

        console.log(`[GlobalAlerts] Evaluating ${code}: live=${live}, prev=${prev}, change=${change}, absChange=${absChange}, pct=${pct.toFixed(2)}%`);
        if (change > 0) {
            // OR logic: trigger if EITHER percent OR dollar increase threshold satisfied (first satisfied determines threshold label)
            if (globalPercentIncrease && globalPercentIncrease > 0 && pct >= globalPercentIncrease) { triggered = true; type='increase'; thresholdHit = globalPercentIncrease + '%'; }
            else if (globalDollarIncrease && globalDollarIncrease > 0 && absChange >= globalDollarIncrease) { triggered = true; type='increase'; thresholdHit = '$' + Number(globalDollarIncrease).toFixed(2); }
            if (triggered) {
                increaseCount++;
                console.log(`[GlobalAlerts] INCREASE TRIGGERED for ${code}: ${thresholdHit}`);
            }
        } else { // decrease
            // OR logic: trigger if EITHER percent OR dollar decrease threshold satisfied
            if (globalPercentDecrease && globalPercentDecrease > 0 && pct >= globalPercentDecrease) { triggered = true; type='decrease'; thresholdHit = globalPercentDecrease + '%'; }
            else if (globalDollarDecrease && globalDollarDecrease > 0 && absChange >= globalDollarDecrease) { triggered = true; type='decrease'; thresholdHit = '$' + Number(globalDollarDecrease).toFixed(2); }
            if (triggered) {
                decreaseCount++;
                console.log(`[GlobalAlerts] DECREASE TRIGGERED for ${code}: ${thresholdHit}`);
            }
        }
        if (triggered) {
            if (!dominantThreshold) { dominantThreshold = thresholdHit; dominantType = type; }
            if (userCodes.has(code)) {
                portfolioCount++;
            } else {
                nonPortfolioCodes.add(code);
            }
        }
    }
    // Evaluate user-owned codes (livePrices)
    Object.entries(livePrices || {}).forEach(([code, lp]) => { if (!lp) return; evaluateMovement(code, lp.live, lp.prevClose); });
    // Evaluate external (non-portfolio) collected rows from last fetch
    (globalExternalPriceRows||[]).forEach(r => { if (r && r.code && !userCodes.has(r.code)) evaluateMovement(r.code, r.live, r.prevClose); });
    const total = increaseCount + decreaseCount;
    console.log(`[GlobalAlerts] Evaluation complete: total=${total}, increase=${increaseCount}, decrease=${decreaseCount}, portfolio=${portfolioCount}, nonPortfolio=${nonPortfolioCodes.size}`);
    if (total > 0) {
        const docId = 'GA_SUMMARY';
        const alertDocRef = firestore.doc(alertsCol, docId);
        const payload = {
            shareId: docId,
            shareCode: 'GLOBAL',
            userId: currentUserId,
            appId: currentAppId,
            intent: 'info',
            type: 'global',
            direction: dominantType ? ('global-' + dominantType) : 'global',
            globalPercentIncrease: globalPercentIncrease || null,
            globalDollarIncrease: globalDollarIncrease || null,
            globalPercentDecrease: globalPercentDecrease || null,
            globalDollarDecrease: globalDollarDecrease || null,
            appliedMinimumPrice: globalMinimumPrice || null,
            increaseCount,
            decreaseCount,
            totalCount: total,
            portfolioCount,
            nonPortfolioCodes: Array.from(nonPortfolioCodes).sort(),
            threshold: dominantThreshold,
            targetHit: true,
            enabled: true,
            updatedAt: firestore.serverTimestamp(),
            createdAt: firestore.serverTimestamp()
        };
        console.log('[GlobalAlerts] Writing GA_SUMMARY to Firestore:', payload);
        console.log('[GlobalAlerts] nonPortfolioCodes array:', Array.from(nonPortfolioCodes));
        firestore.setDoc(alertDocRef, payload, { merge: true })
            .then(()=> {
                console.log('[GlobalAlerts] SUCCESS: Summary upserted. Total='+ total + ' portfolio=' + portfolioCount + ' discover=' + nonPortfolioCodes.size + ' inc=' + increaseCount + ' dec=' + decreaseCount + ' threshold=' + dominantThreshold);
                logDebug('Global Alerts: Summary upserted. Total='+ total + ' portfolio=' + portfolioCount + ' discover=' + nonPortfolioCodes.size + ' inc=' + increaseCount + ' dec=' + decreaseCount + ' threshold=' + dominantThreshold);
            })
            .catch(e=> {
                console.error('[GlobalAlerts] ERROR: summary upsert failed', e);
                console.error('Global Alerts: summary upsert failed', e);
            });
    }
}

async function saveGlobalAlertSettingsDirectional(settings) {
    if (!db || !currentUserId || !firestore) return;
    const userProfileDocRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/profile/settings');
    // Use deleteField for any cleared (null) thresholds so old values cannot resurrect on reload
    const del = firestore.deleteField();
    const toSave = {
        globalPercentIncrease: (typeof settings.globalPercentIncrease === 'number' && settings.globalPercentIncrease > 0) ? settings.globalPercentIncrease : del,
        globalDollarIncrease: (typeof settings.globalDollarIncrease === 'number' && settings.globalDollarIncrease > 0) ? settings.globalDollarIncrease : del,
        globalPercentDecrease: (typeof settings.globalPercentDecrease === 'number' && settings.globalPercentDecrease > 0) ? settings.globalPercentDecrease : del,
        globalDollarDecrease: (typeof settings.globalDollarDecrease === 'number' && settings.globalDollarDecrease > 0) ? settings.globalDollarDecrease : del,
        globalMinimumPrice: (typeof settings.globalMinimumPrice === 'number' && settings.globalMinimumPrice > 0) ? settings.globalMinimumPrice : del,
        // 52-week filters + email toggle
        hiLoMinimumPrice: (typeof settings.hiLoMinimumPrice === 'number' && settings.hiLoMinimumPrice > 0) ? settings.hiLoMinimumPrice : del,
        hiLoMinimumMarketCap: (typeof settings.hiLoMinimumMarketCap === 'number' && settings.hiLoMinimumMarketCap > 0) ? settings.hiLoMinimumMarketCap : del,
        emailAlertsEnabled: (typeof settings.emailAlertsEnabled === 'boolean') ? settings.emailAlertsEnabled : del,
        // Always remove legacy single-threshold fields so they can never repopulate new directional fields after a clear
        globalPercentAlert: del,
        globalDollarAlert: del,
        globalDirectionalVersion: Date.now() // bump a version so clients can detect freshness
    };
    try { await firestore.setDoc(userProfileDocRef, toSave, { merge: true });
        logDebug('Global Alerts: Saved directional settings (normalized/deleteField applied) ' + JSON.stringify(toSave));
        try { localStorage.setItem('globalDirectionalVersion', String(toSave.globalDirectionalVersion)); } catch(e){}
        // Persist cleared sentinel so a hard reload before Firestore cache invalidation still respects cleared state
        try {
            const snapshotCache = {
                pInc: settings.globalPercentIncrease ?? null,
                dInc: settings.globalDollarIncrease ?? null,
                pDec: settings.globalPercentDecrease ?? null,
                dDec: settings.globalDollarDecrease ?? null,
                minP: settings.globalMinimumPrice ?? null,
                hiLoMinP: settings.hiLoMinimumPrice ?? null,
                hiLoMinCap: settings.hiLoMinimumMarketCap ?? null,
                emailOn: !!settings.emailAlertsEnabled,
                at: toSave.globalDirectionalVersion
            };
            localStorage.setItem('globalDirectionalSnapshot', JSON.stringify(snapshotCache));
        } catch(e){}
    }
    catch(e){ console.error('Global Alerts: save directional failed', e); }

    // Persist central settings via server-side sync only. Client-side direct writes to the
    // central document are intentionally removed because Firestore security rules prevent
    // direct client writes and produce confusing permission errors in normal operation.
    // The server-side Apps Script webapp will perform the privileged commit; trigger it now
    // and keep any failures quiet unless DEBUG_MODE is enabled.
    try {
        const uid = currentUserId || (window.firebase && window.firebase.auth && window.firebase.auth().currentUser && window.firebase.auth().currentUser.uid);
        if (uid) {
            window.triggerServerSideGlobalSettingsSync(uid).then((res)=>{
                if (!res || !res.ok) {
                    // Keep non-actionable errors out of the regular console; surface only in debug mode
                    try { debugLog && debugLog('[SyncTrigger] server-side sync response', res); } catch(_) {}
                } else {
                    try { debugLog && debugLog('[SyncTrigger] server-side sync succeeded', res); } catch(_) {}
                }
            }).catch((err)=>{
                try { debugLog && debugLog('[SyncTrigger] server-side sync failed', err); } catch(_) {}
            });
        } else {
            try { debugLog && debugLog('[SyncTrigger] No user id available for server-side sync'); } catch(_) {}
        }
    } catch(e) { /* intentionally quiet */ }
}

function applyLoadedGlobalAlertSettings(settings) {
    try {
        // If a local snapshot exists that shows all cleared, skip legacy migration to avoid resurrecting deleted values
        let snapshotClearedAll = false;
        try {
            const snapRaw = localStorage.getItem('globalDirectionalSnapshot');
            if (snapRaw) {
                const snap = JSON.parse(snapRaw);
                if (snap && snap.pInc==null && snap.dInc==null && snap.pDec==null && snap.dDec==null && snap.minP==null) snapshotClearedAll = true;
            }
        } catch(_) {}
        if (!snapshotClearedAll) {
            // Migrate legacy single threshold to increase (up) thresholds if new not present
            if (settings.globalPercentIncrease == null && typeof settings.globalPercentAlert === 'number') settings.globalPercentIncrease = settings.globalPercentAlert;
            if (settings.globalDollarIncrease == null && typeof settings.globalDollarAlert === 'number') settings.globalDollarIncrease = settings.globalDollarAlert;
        }
        globalPercentIncrease = (typeof settings.globalPercentIncrease === 'number' && settings.globalPercentIncrease > 0) ? settings.globalPercentIncrease : null;
        globalDollarIncrease = (typeof settings.globalDollarIncrease === 'number' && settings.globalDollarIncrease > 0) ? settings.globalDollarIncrease : null;
        globalPercentDecrease = (typeof settings.globalPercentDecrease === 'number' && settings.globalPercentDecrease > 0) ? settings.globalPercentDecrease : null;
        globalDollarDecrease = (typeof settings.globalDollarDecrease === 'number' && settings.globalDollarDecrease > 0) ? settings.globalDollarDecrease : null;
        globalMinimumPrice = (typeof settings.globalMinimumPrice === 'number' && settings.globalMinimumPrice > 0) ? settings.globalMinimumPrice : null;
        hiLoMinimumPrice = (typeof settings.hiLoMinimumPrice === 'number' && settings.hiLoMinimumPrice > 0) ? settings.hiLoMinimumPrice : null;
        hiLoMinimumMarketCap = (typeof settings.hiLoMinimumMarketCap === 'number' && settings.hiLoMinimumMarketCap > 0) ? settings.hiLoMinimumMarketCap : null;
        emailAlertsEnabled = (typeof settings.emailAlertsEnabled === 'boolean') ? settings.emailAlertsEnabled : false;
        if (globalPercentIncreaseInput) globalPercentIncreaseInput.value = globalPercentIncrease ?? '';
        if (globalDollarIncreaseInput) globalDollarIncreaseInput.value = globalDollarIncrease ?? '';
        if (globalPercentDecreaseInput) globalPercentDecreaseInput.value = globalPercentDecrease ?? '';
        if (globalDollarDecreaseInput) globalDollarDecreaseInput.value = globalDollarDecrease ?? '';
        if (globalMinimumPriceInput) globalMinimumPriceInput.value = globalMinimumPrice ?? '';
        if (hiLoMinimumPriceInput) hiLoMinimumPriceInput.value = hiLoMinimumPrice ?? '';
        if (hiLoMinimumMarketCapInput) {
            // Display compact currency if value present; otherwise clear
            try {
                if (typeof hiLoMinimumMarketCap === 'number' && hiLoMinimumMarketCap > 0) {
                    hiLoMinimumMarketCapInput.value = '$' + formatCompactNumber(hiLoMinimumMarketCap, { maximumFractionDigits: 1 });
                } else {
                    hiLoMinimumMarketCapInput.value = '';
                }
            } catch(_) { hiLoMinimumMarketCapInput.value = hiLoMinimumMarketCap ?? ''; }
            // Also seed the live hint
            try {
                const hint = document.getElementById('hiLoMinCapHint');
                if (hint) hint.textContent = (typeof hiLoMinimumMarketCap === 'number' && hiLoMinimumMarketCap > 0) ? ('$' + formatCompactNumber(hiLoMinimumMarketCap, { maximumFractionDigits: 1 })) : '';
            } catch(_) {}
        }
        if (emailAlertsEnabledInput) emailAlertsEnabledInput.checked = !!emailAlertsEnabled;
        // Sync segmented email toggle to loaded value
        try {
            const onBtn = document.getElementById('emailOnBtn');
            const offBtn = document.getElementById('emailOffBtn');
            if (onBtn && offBtn) {
                onBtn.classList.toggle('is-active', !!emailAlertsEnabled);
                offBtn.classList.toggle('is-active', !emailAlertsEnabled);
                onBtn.setAttribute('aria-pressed', String(!!emailAlertsEnabled));
                offBtn.setAttribute('aria-pressed', String(!emailAlertsEnabled));
            }
        } catch(_) {}
        updateGlobalAlertsSettingsSummary();
    } catch(e){ console.warn('Global Alerts: apply directional settings failed', e); }
}

// Test function to verify global alert logic
function testGlobalAlertLogic() {
    console.log('[TEST] Testing global alert evaluation logic...');

    // Test case 1: 20% increase with 15% threshold
    const testCases = [
        { code: 'TEST1', live: 12, prev: 10, expectedTrigger: true, description: '20% increase vs 15% threshold' },
        { code: 'TEST2', live: 8, prev: 10, expectedTrigger: true, description: '20% decrease vs 15% threshold' },
        { code: 'TEST3', live: 11, prev: 10, expectedTrigger: false, description: '10% increase vs 15% threshold' },
    ];

    // Set test thresholds
    const origPercentIncrease = globalPercentIncrease;
    const origPercentDecrease = globalPercentDecrease;
    const origDollarIncrease = globalDollarIncrease;
    const origDollarDecrease = globalDollarDecrease;

    globalPercentIncrease = 15;
    globalPercentDecrease = 15;
    globalDollarIncrease = null;
    globalDollarDecrease = null;

    testCases.forEach(testCase => {
        const change = testCase.live - testCase.prev;
        const absChange = Math.abs(change);
        const pct = testCase.prev !== 0 ? (absChange / testCase.prev) * 100 : 0;

        let triggered = false;
        let type = null;
        let thresholdHit = null;

        if (change > 0) {
            if (globalPercentIncrease && globalPercentIncrease > 0 && pct >= globalPercentIncrease) {
                triggered = true;
                type = 'increase';
                thresholdHit = globalPercentIncrease + '%';
            }
        } else {
            if (globalPercentDecrease && globalPercentDecrease > 0 && pct >= globalPercentDecrease) {
                triggered = true;
                type = 'decrease';
                thresholdHit = globalPercentDecrease + '%';
            }
        }

        console.log(`[TEST] ${testCase.description}: ${testCase.code} ${testCase.live}->${testCase.prev} (${pct.toFixed(1)}%) -> ${triggered ? 'TRIGGERED' : 'NOT TRIGGERED'} (expected: ${testCase.expectedTrigger ? 'TRIGGERED' : 'NOT TRIGGERED'})`);
    });

    // Restore original values
    globalPercentIncrease = origPercentIncrease;
    globalPercentDecrease = origPercentDecrease;
    globalDollarIncrease = origDollarIncrease;
    globalDollarDecrease = origDollarDecrease;

    console.log('[TEST] Test completed');
}

// Test function to manually evaluate global alerts with test data
function testGlobalAlertEvaluation() {
    console.log('[TEST] Testing global alert evaluation with sample data...');

    // Set test thresholds
    const origPercentIncrease = globalPercentIncrease;
    const origPercentDecrease = globalPercentDecrease;
    globalPercentIncrease = 5; // 5% increase threshold
    globalPercentDecrease = 5; // 5% decrease threshold

    // Mock some test data

    // Test external codes (excluding user-owned)
    testExternalRows.forEach(r => {
        if (!mockUserCodes.has(r.code)) {
            evaluateMovement(r.code, r.live, r.prevClose);
        }
    });

    console.log(`[TEST] Final counts: increase=${increaseCount}, decrease=${decreaseCount}, total=${increaseCount + decreaseCount}`);

    // Restore original values
    globalPercentIncrease = origPercentIncrease;
    globalPercentDecrease = origPercentDecrease;

    console.log('[TEST] Evaluation test completed');
}

// Debug function to check current global alert state
function debugGlobalAlerts() {
    console.log('[DEBUG] === GLOBAL ALERTS DEBUG ===');
    console.log('[DEBUG] Current thresholds:', {
        globalPercentIncrease,
        globalDollarIncrease,
        globalPercentDecrease,
        globalDollarDecrease,
        globalMinimumPrice
    });
    console.log('[DEBUG] Thresholds active?', isDirectionalThresholdsActive());
    console.log('[DEBUG] Current user:', currentUserId ? 'Logged in' : 'Not logged in');
    console.log('[DEBUG] Current app:', currentAppId || 'Not set');
    console.log('[DEBUG] Firestore available?', !!(db && firestore));
    console.log('[DEBUG] Global alert summary:', globalAlertSummary);

    // Check if global alert summary has the expected dollar thresholds
    if (globalAlertSummary) {
        console.log('[DEBUG] GA_SUMMARY dollar thresholds:', {
            globalDollarIncrease: globalAlertSummary.globalDollarIncrease,
            globalDollarDecrease: globalAlertSummary.globalDollarDecrease,
            decreaseCount: globalAlertSummary.decreaseCount,
            increaseCount: globalAlertSummary.increaseCount
        });
    }

    console.log('[DEBUG] Live prices count:', livePrices ? Object.keys(livePrices).length : 0);
    console.log('[DEBUG] External price rows count:', Array.isArray(globalExternalPriceRows) ? globalExternalPriceRows.length : 0);
    console.log('[DEBUG] Shares data count:', Array.isArray(allSharesData) ? allSharesData.length : 0);
    console.log('[DEBUG] Shares at target price count:', Array.isArray(sharesAtTargetPrice) ? sharesAtTargetPrice.length : 0);
    console.log('[DEBUG] === END DEBUG ===');
}

// Test function to force evaluation and show results
function testGlobalAlertsNow() {
    console.log('[TEST] Force evaluating global alerts now...');

    // First check current state
    debugGlobalAlerts();

    // Force evaluation
    console.log('[TEST] Calling evaluateGlobalPriceAlerts...');
    try {
        evaluateGlobalPriceAlerts();
    } catch(e) {
        console.error('[TEST] Error during evaluation:', e);
    }

    // Show updated state
    setTimeout(() => {
        console.log('[TEST] After evaluation:');
        debugGlobalAlerts();

        // Force modal render to see if global summary appears
        if (typeof showTargetHitDetailsModal === 'function') {
            console.log('[TEST] Forcing modal render...');
            showTargetHitDetailsModal();
        }
    }, 1000);
}

// Test function to specifically test the discover modal
function testDiscoverModal() {
    console.log('[TEST] Testing discover modal...');

    // First refresh the movers data
    console.log('[TEST] Refreshing movers data...');
    applyGlobalSummaryFilter({ silent: true, computeOnly: true });

    // Wait a bit for the snapshot to be created, then use global wrapper
    setTimeout(() => {
        console.log('[TEST] Opening discover modal via global wrapper...');
        if (typeof window.openGlobalDiscoverModal === 'function') {
            window.openGlobalDiscoverModal(globalAlertSummary);
        } else {
            console.log('[TEST] Global wrapper not available');
        }
    }, 200);
}

// Global wrapper for opening discover modal (for testing)
if (typeof window !== 'undefined') {
    window.openGlobalDiscoverModal = function(summaryData) {
        console.log('[GLOBAL] Opening discover modal with summary:', summaryData);
        // Call showTargetHitDetailsModal which contains openDiscoverModal
        if (typeof showTargetHitDetailsModal === 'function') {
            showTargetHitDetailsModal();
            // After modal opens, trigger the discover tab
            setTimeout(() => {
                const discoverBtn = document.querySelector('[data-action="discover"]');
                if (discoverBtn && !discoverBtn.disabled) {
                    discoverBtn.click();
                } else {
                    console.log('[GLOBAL] Discover button not found or disabled');
                }
            }, 200);
        } else {
            console.error('[GLOBAL] showTargetHitDetailsModal not available');
        }
    };

    // Function to load ALL ASX codes from CSV
    window.loadAllAsxCodes = async function() {
        try {
            console.log('[GLOBAL] Loading ALL ASX codes from CSV...');
            const response = await fetch('./asx_codes.csv');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const csvText = await response.text();

            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) {
                console.warn('[GLOBAL] ASX codes CSV is empty.');
                return [];
            }

            // Clean the header line
            const headerLine = lines[0].replace(/^\uFEFF/, '').replace(/^\u00EF\u00BB\u00BF/, '');
            const headers = headerLine.split(',').map(header => header.trim().replace(/"/g, ''));

            const asxCodeIndex = headers.findIndex(h => h.toLowerCase().includes('asx code') || h.toLowerCase() === 'asx code');
            const companyNameIndex = headers.findIndex(h => h.toLowerCase().includes('company name') || h.toLowerCase() === 'company name');

            const allAsxCodes = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = line.split(',');
                if (values.length > asxCodeIndex && values[asxCodeIndex]) {
                    const code = values[asxCodeIndex].trim().replace(/"/g, '');
                    const name = values[companyNameIndex] ? values[companyNameIndex].trim().replace(/"/g, '') : '';
                    if (code) {
                        allAsxCodes.push({ code: code.toUpperCase(), name: name });
                    }
                }
            }

            console.log(`[GLOBAL] Loaded ${allAsxCodes.length} ASX codes`);
            return allAsxCodes;
        } catch (error) {
            console.error('[GLOBAL] Error loading ASX codes:', error);
            return [];
        }
    };

    // Function to fetch prices for ALL ASX codes (for global alerts)
    window.fetchAllAsxPrices = async function(allAsxCodes) {
        try {
            console.log('[GLOBAL] Fetching prices for ALL ASX codes...');

            const defaultAppsScriptUrl = 'https://script.google.com/macros/s/AKfycbwwwMEss5DIYblLNbjIbt_TAzWh54AwrfQlVwCrT_P0S9xkAoXhAUEUg7vSEPYUPOZp/exec';
            const baseUrl = (typeof window.GOOGLE_APPS_SCRIPT_URL !== 'undefined' && window.GOOGLE_APPS_SCRIPT_URL)
                ? window.GOOGLE_APPS_SCRIPT_URL
                : ((typeof window.appsScriptUrl !== 'undefined' && window.appsScriptUrl)
                    ? window.appsScriptUrl
                    : defaultAppsScriptUrl);

            if (!baseUrl) throw new Error('Apps Script URL not defined');

            // Request ALL ASX codes (not just portfolio ones)
            const allCodes = allAsxCodes.map(item => item.code);
            const batchSize = 100; // Process in batches to avoid URL length limits
            const allPriceData = {};

            for (let i = 0; i < allCodes.length; i += batchSize) {
                const batch = allCodes.slice(i, i + batchSize);
                console.log(`[GLOBAL] Fetching batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(allCodes.length/batchSize)} (${batch.length} codes)...`);

                const qs = new URLSearchParams();
                qs.set('_ts', Date.now().toString());
                qs.set('allAsxCodes', 'true'); // Special flag to indicate we want ALL codes

                // Add the codes to the query string
                batch.forEach(code => {
                    qs.append('codes', code);
                });

                const url = qs.toString() ? (baseUrl + (baseUrl.includes('?') ? '&' : '?') + qs.toString()) : baseUrl;

                try {
                    const response = await fetch(url, { cache: 'no-store' });
                    if (!response.ok) {
                        console.warn(`[GLOBAL] Batch failed with status ${response.status}, continuing...`);
                        continue;
                    }

                    const data = await response.json();
                    if (Array.isArray(data)) {
                        data.forEach(item => {
                            const codeRaw = item.ASXCode || item.ASX_Code || item['ASX Code'] || item.Code || item.code;
                            if (codeRaw) {
                                const code = String(codeRaw).toUpperCase().trim();
                                const liveParsed = parseFloat(item.LivePrice || item['Live Price'] || item.live || item.price || 0);
                                const prevParsed = parseFloat(item.PrevClose || item['Prev Close'] || item.previous || item.prev || item.prevClose || 0);

                                if (liveParsed && prevParsed && !isNaN(liveParsed) && !isNaN(prevParsed)) {
                                    allPriceData[code] = {
                                        live: liveParsed,
                                        prevClose: prevParsed,
                                        companyName: item.CompanyName || item['Company Name'] || item.Name || item.name || ''
                                    };
                                }
                            }
                        });
                    }
                } catch (batchError) {
                    console.warn('[GLOBAL] Batch error:', batchError);
                    continue;
                }

                // Small delay between batches to avoid overwhelming the service
                if (i + batchSize < allCodes.length) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }

            console.log(`[GLOBAL] Fetched prices for ${Object.keys(allPriceData).length} ASX shares`);
            return allPriceData;
        } catch (error) {
            console.error('[GLOBAL] Error fetching all ASX prices:', error);
            return {};
        }
    };
}

// Make debug and test functions available globally
if (typeof window !== 'undefined') {
    window.testGlobalAlertLogic = testGlobalAlertLogic;
    window.testGlobalAlertEvaluation = testGlobalAlertEvaluation;
    window.debugGlobalAlerts = debugGlobalAlerts;
    window.testGlobalAlertsNow = testGlobalAlertsNow;
    window.testDiscoverModal = testDiscoverModal;

    // Debug function to check 52-week low alerts state
    window.debug52WeekLowAlerts = function() {
        console.log('[DEBUG] 52-week low alerts state:');
        console.log('- Total alerts:', window.sharesAt52WeekLow ? window.sharesAt52WeekLow.length : 0);
        console.log('- Muted map:', window.__low52MutedMap);

        if (window.sharesAt52WeekLow) {
            window.sharesAt52WeekLow.forEach((alert, idx) => {
                const mutedStatus = window.__low52MutedMap && window.__low52MutedMap[alert.code + '_low'];
                console.log(`${idx + 1}. ${alert.code}: ${alert.name} - Live: $${alert.live?.toFixed(2)} <= Low52: $${alert.low52?.toFixed(2)} (muted: ${alert.muted}, mapMuted: ${mutedStatus})`);
            });
        }

        const low52Count = Array.isArray(window.sharesAt52WeekLow) ? window.sharesAt52WeekLow.filter(item => !item.muted).length : 0;
        console.log('- Unmuted count:', low52Count);
        console.log('- Should display in modal:', window.sharesAt52WeekLow.filter(item => !item.muted).map(item => item.code).join(', '));
    };

    // Test function for 52-week low alerts
    window.test52WeekLowAlerts = async function() {
        console.log('[TEST] Testing 52-week low alerts...');
        window.__isTesting52WeekLowAlerts = true; // Set flag

        if (typeof window.fetchLivePrices === 'function') {
            await window.fetchLivePrices({ cacheBust: true });
        }

        // Reset the triggered set to allow re-triggering
        window.triggered52WeekLowSet = new Set();

        // Clear existing alerts
        window.sharesAt52WeekLow = [];

        // Clear muted status for test alerts
        if (window.__low52MutedMap) {
            ['FBR', 'BOT', 'GEM'].forEach(code => {
                delete window.__low52MutedMap[code + '_low'];
            });
            try { sessionStorage.setItem('low52MutedMap', JSON.stringify(window.__low52MutedMap)); } catch {}
        }

        // Force re-evaluation of all shares for 52-week lows
        const sharesLocal = window.allSharesData || [];
        const livePricesLocal = window.livePrices || {};

        console.log(`[TEST] Checking ${sharesLocal.length} shares for 52-week low conditions`);
        console.log(`[TEST] Live prices available for ${Object.keys(livePricesLocal).length} codes`);

        sharesLocal.forEach(share => {
            const code = (share.shareName || '').toUpperCase();
            const lpObj = livePricesLocal[code];
            
            if (!lpObj) {
                console.log(`[TEST] No live price data for ${code}`);
                return;
            }
            
            if (lpObj.live == null || isNaN(lpObj.live)) {
                console.log(`[TEST] Invalid live price for ${code}: ${lpObj.live}`);
                return;
            }
            
            if (lpObj.Low52 == null || isNaN(lpObj.Low52)) {
                console.log(`[TEST] Invalid Low52 for ${code}: ${lpObj.Low52}`);
                return;
            }

            console.log(`[TEST] Checking ${code}: live=$${lpObj.live.toFixed(2)}, Low52=$${lpObj.Low52.toFixed(2)}`);

            // For test alerts, don't check muted status - force them to be unmuted for testing
            const isMuted = false; // Force unmuted for test alerts

            // Force trigger for testing - simulate price at or below 52-week low
            if (lpObj.live <= lpObj.Low52 + 0.01) { // Add small buffer for floating point
                let displayName = code;
                const allAsxCodesLocal = window.allAsxCodes || [];
                if (Array.isArray(allAsxCodesLocal)) {
                    const match = allAsxCodesLocal.find(c => c.code === code);
                    if (match && match.name) displayName = match.name;
                }
                if (!displayName && share.companyName) displayName = share.companyName;

                window.sharesAt52WeekLow.push({
                    code,
                    name: displayName,
                    live: lpObj.live,
                    low52: lpObj.Low52,
                    type: 'low',
                    muted: isMuted
                });

                window.triggered52WeekLowSet.add(code);
                console.log(`[TEST] 52-week low triggered for ${code}: Live $${lpObj.live.toFixed(2)} <= Low52 $${lpObj.Low52.toFixed(2)}`);
            } else {
                console.log(`[TEST] ${code} does not meet 52-week low condition: $${lpObj.live.toFixed(2)} > $${(lpObj.Low52 + 0.01).toFixed(2)}`);
            }
        });

        // Test card removed - 52-week low detection is now working properly

        // Update UI
        if (typeof window.updateTargetHitBanner === 'function') window.updateTargetHitBanner();
        if (typeof window.recomputeTriggeredAlerts === 'function') window.recomputeTriggeredAlerts();

                        console.log(`[TEST] 52-week low test complete. Found ${window.sharesAt52WeekLow.length} alerts (including test card)`);

        // Debug: Log all alerts with their properties
        console.log('[TEST] Current alerts in sharesAt52WeekLow:');
        window.sharesAt52WeekLow.forEach((alert, idx) => {
            const livePriceData = window.livePrices && window.livePrices[alert.code.toUpperCase()];
            console.log(`${idx + 1}. ${alert.code}: ${alert.name} - muted: ${alert.muted}, isTestCard: ${alert.isTestCard}, testTriggered: ${alert.testTriggered}, hasLivePrice: ${!!livePriceData}`);
        });

        // Add a watcher to detect when the array gets modified
        const originalArray = [...window.sharesAt52WeekLow];
        console.log('[TEST] Starting array watcher with original array:', originalArray.map(a => a.code));
        
        const checkArray = () => {
            if (window.sharesAt52WeekLow.length !== originalArray.length) {
                console.log(`[TEST] ARRAY MODIFIED! Was ${originalArray.length}, now ${window.sharesAt52WeekLow.length}`);
                console.log('[TEST] Original array:', originalArray.map(a => a.code));
                console.log('[TEST] Current array:', window.sharesAt52WeekLow.map(a => a.code));
                console.log('[TEST] Stack trace:', new Error().stack);
            }
        };
        
        // Check every 50ms for 5 seconds
        const interval = setInterval(checkArray, 50);
        setTimeout(() => clearInterval(interval), 5000);

                    // Force open the notifications modal to show the alerts
            if (typeof window.showTargetHitDetailsModal === 'function') {
                console.log('[TEST] Opening notifications modal to display 52-week low alerts...');
                console.log('[TEST] About to call showTargetHitDetailsModal with data:', {
                    sharesAt52WeekLow: window.sharesAt52WeekLow,
                    length: window.sharesAt52WeekLow ? window.sharesAt52WeekLow.length : 0
                });

                // Add a small delay to ensure the array doesn't get cleared
                setTimeout(() => {
                    console.log('[TEST] About to call modal - sharesAt52WeekLow length:', window.sharesAt52WeekLow ? window.sharesAt52WeekLow.length : 0);

                    // Create a backup of the array before calling modal
                    const backupArray = [...window.sharesAt52WeekLow];
                    console.log('[TEST] Created backup array with length:', backupArray.length);

                    // Call the modal
                    window.showTargetHitDetailsModal({ explicit: true, userInitiated: true, allowDuringInitialLoad: true });

                    // Update the notification banner AFTER the modal is opened
                    setTimeout(() => {
                        try { 
                            console.log('[TEST] Updating notification banner - sharesAt52WeekLow length:', window.sharesAt52WeekLow ? window.sharesAt52WeekLow.length : 0);
                            updateTargetHitBanner(); 
                            console.log('[TEST] Updated notification banner with new count');
                        } catch(e) { 
                            console.warn('[TEST] Failed to update notification banner:', e); 
                        }
                    }, 200);

                    // Check if array was modified after modal call
                    setTimeout(() => {
                        if (window.sharesAt52WeekLow.length !== backupArray.length) {
                            console.log('[TEST] Array was modified after modal call! Restoring backup...');
                            console.log('[TEST] Was:', backupArray.length, 'Now:', window.sharesAt52WeekLow.length);
                            window.sharesAt52WeekLow = [...backupArray];
                            console.log('[TEST] Restored array, now calling modal again...');
                            window.showTargetHitDetailsModal({ explicit: true, userInitiated: true, allowDuringInitialLoad: true });
                        }
                    }, 50);
                }, 100);

        // Reset flag after a short delay to ensure modal has time to render
        setTimeout(() => {
            window.__isTesting52WeekLowAlerts = false;
            console.log('[TEST] Testing flag reset after modal render');
        }, 1000);
        } else {
            console.error('[TEST] showTargetHitDetailsModal function not available!');
            window.__isTesting52WeekLowAlerts = false; // Reset flag if modal not available
        }
    };

    // Function to remove the CBA test card after testing
    // Removed function to remove the CBA test card after testing

    // Target Hit Notifications Test Functions
    window.testTargetHitNotifications = function() {
        console.log('[TEST] Testing target hit notifications...');
        
        // Check if we have shares with target prices
        const sharesWithTargets = allSharesData.filter(share => 
            share && share.targetPrice && !isNaN(parseFloat(share.targetPrice))
        );
        
        console.log(`[TEST] Found ${sharesWithTargets.length} shares with target prices:`);
        sharesWithTargets.forEach(share => {
            console.log(`[TEST] - ${share.shareName}: Target $${share.targetPrice} (${share.targetDirection || 'below'})`);
        });
        
        // Check live prices for these shares
        const livePrices = getLivePrices();
        console.log(`[TEST] Live prices available for ${Object.keys(livePrices).length} shares`);
        
        // Check which shares are currently at target
        const sharesAtTarget = [];
        sharesWithTargets.forEach(share => {
            const code = share.shareName.toUpperCase();
            const liveData = livePrices[code];
            if (liveData && liveData.targetHit) {
                sharesAtTarget.push(share);
                console.log(`[TEST] ✅ ${code}: Live $${liveData.live} - TARGET HIT!`);
            } else if (liveData) {
                console.log(`[TEST] ❌ ${code}: Live $${liveData.live} - Not at target`);
            } else {
                console.log(`[TEST] ⚠️ ${code}: No live price data`);
            }
        });
        
        console.log(`[TEST] Target hit test complete. Found ${sharesAtTarget.length} shares at target`);
        
        // Force recompute and show modal
        try {
            if (typeof window.recomputeTriggeredAlerts === 'function') {
                window.recomputeTriggeredAlerts();
                console.log('[TEST] Called recomputeTriggeredAlerts');
            } else {
                console.error('[TEST] recomputeTriggeredAlerts function not found!');
            }
            
            if (typeof window.showTargetHitDetailsModal === 'function') {
                window.showTargetHitDetailsModal({ explicit: true, userInitiated: true, allowDuringInitialLoad: true });
                console.log('[TEST] Opened target hit details modal');
            }
        } catch(e) {
            console.error('[TEST] Error in target hit test:', e);
        }
    };

    window.debugTargetHitState = function() {
        console.log('[DEBUG] Target Hit State Debug:');
        console.log('[DEBUG] sharesAtTargetPrice:', sharesAtTargetPrice);
        console.log('[DEBUG] sharesAtTargetPriceMuted:', sharesAtTargetPriceMuted);
        console.log('[DEBUG] livePrices keys:', Object.keys(livePrices || {}));
        console.log('[DEBUG] livePrices with targetHit:', Object.entries(livePrices || {}).filter(([k,v]) => v && v.targetHit));
        console.log('[DEBUG] alertsEnabledMap:', alertsEnabledMap);
        console.log('[DEBUG] allSharesData with targets:', allSharesData.filter(s => s && s.targetPrice));
    };
}

// Helper: are any directional thresholds currently active?
function isDirectionalThresholdsActive() {
    return !!(
        (typeof globalPercentIncrease === 'number' && globalPercentIncrease>0) ||
        (typeof globalDollarIncrease === 'number' && globalDollarIncrease>0) ||
        (typeof globalPercentDecrease === 'number' && globalPercentDecrease>0) ||
        (typeof globalDollarDecrease === 'number' && globalDollarDecrease>0)
    );
}

function formatGlobalAlertPart(pct, dol) {
    const pctStr = pct ? (pct + '%') : null;
    const dolStr = dol ? ('$' + Number(dol).toFixed(2)) : null;
    if (pctStr && dolStr) return pctStr + ' / ' + dolStr;
    return pctStr || dolStr || 'Off';
}

function updateGlobalAlertsSettingsSummary() {
    // Update text parts for use in the in-modal summary card
    const incPart = formatGlobalAlertPart(globalPercentIncrease, globalDollarIncrease);
    const decPart = formatGlobalAlertPart(globalPercentDecrease, globalDollarDecrease);
    // Also update the in-modal thresholds summary card, if present
    try {
        const elInc = document.getElementById('gaSumIncrease');
        const elDec = document.getElementById('gaSumDecrease');
        const elMin = document.getElementById('gaSumMinPrice');
        const elHiLoMinPrice = document.getElementById('gaSumHiLoMinPrice');
        const elHiLoMinCap = document.getElementById('gaSumHiLoMinCap');
        const elEmail = document.getElementById('gaSumEmail');
        if (elInc) elInc.textContent = incPart;
        if (elDec) elDec.textContent = decPart;
        if (elMin) elMin.textContent = (typeof globalMinimumPrice === 'number' && globalMinimumPrice > 0) ? ('$' + Number(globalMinimumPrice).toFixed(2)) : 'Off';
        if (elHiLoMinPrice) elHiLoMinPrice.textContent = (typeof hiLoMinimumPrice === 'number' && hiLoMinimumPrice > 0) ? ('$' + Number(hiLoMinimumPrice).toFixed(2)) : 'Off';
        if (elHiLoMinCap) elHiLoMinCap.textContent = (typeof hiLoMinimumMarketCap === 'number' && hiLoMinimumMarketCap > 0) ? ('$' + formatCompactNumber(hiLoMinimumMarketCap, { maximumFractionDigits: 1 })) : 'Off';
        if (elEmail) elEmail.textContent = emailAlertsEnabled ? 'On' : 'Off';
    } catch(_) {}
}

// Modal wiring after DOMContentLoaded
function initGlobalAlertsUI(force) {
    if (window.__globalAlertsUIReady && !force) return; // already initialized
    window.__globalAlertsUIReady = true;
    globalAlertsBtn = document.getElementById('globalAlertsBtn');
    globalAlertsModal = document.getElementById('globalAlertsModal');
    saveGlobalAlertsBtn = document.getElementById('saveGlobalAlertsBtn');
    closeGlobalAlertsBtn = document.getElementById('closeGlobalAlertsBtn');
    globalPercentIncreaseInput = document.getElementById('globalPercentIncrease');
    globalDollarIncreaseInput = document.getElementById('globalDollarIncrease');
    globalPercentDecreaseInput = document.getElementById('globalPercentDecrease');
    globalDollarDecreaseInput = document.getElementById('globalDollarDecrease');
    globalMinimumPriceInput = document.getElementById('globalMinimumPrice');
    hiLoMinimumPriceInput = document.getElementById('hiLoMinimumPrice');
    hiLoMinimumMarketCapInput = document.getElementById('hiLoMinimumMarketCap');
    emailAlertsEnabledInput = document.getElementById('emailAlertsEnabled');
    // Segmented Email On/Off toggle wiring (controls hidden checkbox + live state)
    const emailOnBtn = document.getElementById('emailOnBtn');
    const emailOffBtn = document.getElementById('emailOffBtn');

    // Live update for Min Market Cap hint and compact input formatting/parsing
    function parseCompactCurrency(inputStr) {
        if (!inputStr) return null;
        const s = String(inputStr).trim().replace(/[$,\s]/g, '').toUpperCase();
        if (s === '' || s === '0') return null;
        const m = s.match(/^([-+]?\d*(?:\.\d+)?)([KMBT])?$/i);
        if (!m) {
            const n = Number(s);
            return (isFinite(n) && n > 0) ? n : null;
        }
        const num = parseFloat(m[1]);
        if (!isFinite(num) || num <= 0) return null;
        const suf = (m[2] || '').toUpperCase();
        const mult = suf === 'K' ? 1e3 : suf === 'M' ? 1e6 : suf === 'B' ? 1e9 : suf === 'T' ? 1e12 : 1;
        return num * mult;
    }
    function formatCompactCurrency(num) {
        if (num == null || !isFinite(Number(num)) || Number(num) <= 0) return '';
        return '$' + formatCompactNumber(Number(num), { maximumFractionDigits: 1 });
    }
    if (hiLoMinimumMarketCapInput) {
        // Initialize displayed value as compact (if existing)
        try {
            if (typeof hiLoMinimumMarketCap === 'number' && hiLoMinimumMarketCap > 0) {
                hiLoMinimumMarketCapInput.value = formatCompactCurrency(hiLoMinimumMarketCap);
            }
        } catch(_) {}
        hiLoMinimumMarketCapInput.addEventListener('focus', () => {
            // Show raw number without formatting for easy editing
            try {
                if (typeof hiLoMinimumMarketCap === 'number' && hiLoMinimumMarketCap > 0) {
                    hiLoMinimumMarketCapInput.value = String(Math.trunc(hiLoMinimumMarketCap));
                } else {
                    const parsed = parseCompactCurrency(hiLoMinimumMarketCapInput.value);
                    hiLoMinimumMarketCapInput.value = parsed ? String(Math.trunc(parsed)) : '';
                }
            } catch(_) {}
        });
        hiLoMinimumMarketCapInput.addEventListener('blur', () => {
            const parsed = parseCompactCurrency(hiLoMinimumMarketCapInput.value);
            hiLoMinimumMarketCap = parsed;
            hiLoMinimumMarketCapInput.value = formatCompactCurrency(parsed);
            try {
                const hint = document.getElementById('hiLoMinCapHint');
                if (hint) hint.textContent = parsed ? formatCompactCurrency(parsed) : '';
            } catch(_) {}
        });
        hiLoMinimumMarketCapInput.addEventListener('input', () => {
            const parsed = parseCompactCurrency(hiLoMinimumMarketCapInput.value);
            hiLoMinimumMarketCap = parsed;
            try {
                const hint = document.getElementById('hiLoMinCapHint');
                if (hint) hint.textContent = parsed ? formatCompactCurrency(parsed) : '';
            } catch(_) {}
        });
    }
    function setEmailToggleUI(isOn) {
        emailAlertsEnabled = !!isOn;
        if (emailAlertsEnabledInput) emailAlertsEnabledInput.checked = !!isOn;
        if (emailOnBtn && emailOffBtn) {
            emailOnBtn.classList.toggle('is-active', !!isOn);
            emailOffBtn.classList.toggle('is-active', !isOn);
            emailOnBtn.setAttribute('aria-pressed', String(!!isOn));
            emailOffBtn.setAttribute('aria-pressed', String(!isOn));
        }
        updateGlobalAlertsSettingsSummary();
    }
    if (emailOnBtn && emailOffBtn) {
        emailOnBtn.addEventListener('click', (e) => { e.preventDefault(); setEmailToggleUI(true); });
        emailOffBtn.addEventListener('click', (e) => { e.preventDefault(); setEmailToggleUI(false); });
    }
    if (globalAlertsBtn && globalAlertsModal) {
        globalAlertsBtn.addEventListener('click', () => {
            try { showModal(globalAlertsModal); try { scrollMainToTop(); } catch(_) {} if (globalPercentIncreaseInput) globalPercentIncreaseInput.focus(); } catch(e){ console.error('Global Alerts: failed to open modal', e);} });
    }
    if (closeGlobalAlertsBtn && globalAlertsModal) {
        closeGlobalAlertsBtn.addEventListener('click', (e) => { e.preventDefault(); try { hideModal(globalAlertsModal); } catch(e){} });
    }
    if (saveGlobalAlertsBtn) {
        saveGlobalAlertsBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            const pctIncRaw = parseFloat(globalPercentIncreaseInput?.value || '');
            const dolIncRaw = parseFloat(globalDollarIncreaseInput?.value || '');
            const pctDecRaw = parseFloat(globalPercentDecreaseInput?.value || '');
            const dolDecRaw = parseFloat(globalDollarDecreaseInput?.value || '');
            const minPriceRaw = parseFloat(globalMinimumPriceInput?.value || '');
            const hiLoMinPriceRaw = parseFloat(hiLoMinimumPriceInput?.value || '');
            const hiLoMinCapRaw = (typeof parseCompactCurrency === 'function') ? parseCompactCurrency(hiLoMinimumMarketCapInput?.value || '') : parseFloat(hiLoMinimumMarketCapInput?.value || '');
            const emailToggle = !!(emailAlertsEnabledInput && emailAlertsEnabledInput.checked);
            // Validation: disallow negative inputs; clamp to null
            function norm(v){ return (!isNaN(v) && v > 0) ? v : null; }
            const before = { globalPercentIncrease, globalDollarIncrease, globalPercentDecrease, globalDollarDecrease };
            globalPercentIncrease = (!isNaN(pctIncRaw) && pctIncRaw > 0) ? pctIncRaw : null;
            globalDollarIncrease = (!isNaN(dolIncRaw) && dolIncRaw > 0) ? dolIncRaw : null;
            globalPercentDecrease = (!isNaN(pctDecRaw) && pctDecRaw > 0) ? pctDecRaw : null;
            globalDollarDecrease = (!isNaN(dolDecRaw) && dolDecRaw > 0) ? dolDecRaw : null;
            globalMinimumPrice = (!isNaN(minPriceRaw) && minPriceRaw > 0) ? minPriceRaw : null;
            hiLoMinimumPrice = (!isNaN(hiLoMinPriceRaw) && hiLoMinPriceRaw > 0) ? hiLoMinPriceRaw : null;
            hiLoMinimumMarketCap = (hiLoMinCapRaw != null && !isNaN(hiLoMinCapRaw) && hiLoMinCapRaw > 0) ? hiLoMinCapRaw : null;
            emailAlertsEnabled = !!emailToggle;
            // Reflect cleared values back into inputs so user sees reset immediately
            if (globalPercentIncreaseInput && globalPercentIncrease === null) globalPercentIncreaseInput.value = '';
            if (globalDollarIncreaseInput && globalDollarIncrease === null) globalDollarIncreaseInput.value = '';
            if (globalPercentDecreaseInput && globalPercentDecrease === null) globalPercentDecreaseInput.value = '';
            if (globalDollarDecreaseInput && globalDollarDecrease === null) globalDollarDecreaseInput.value = '';
            if (globalMinimumPriceInput && globalMinimumPrice === null) globalMinimumPriceInput.value = '';
            if (hiLoMinimumPriceInput && hiLoMinimumPrice === null) hiLoMinimumPriceInput.value = '';
            if (hiLoMinimumMarketCapInput && hiLoMinimumMarketCap === null) hiLoMinimumMarketCapInput.value = '';
            if (emailAlertsEnabledInput) emailAlertsEnabledInput.checked = !!emailAlertsEnabled;
            try { setEmailToggleUI(!!emailAlertsEnabled); } catch(_) {}
            const after = { globalPercentIncrease, globalDollarIncrease, globalPercentDecrease, globalDollarDecrease };
            try { console.log('[GlobalAlerts][save] thresholds changed', { before, after, min: globalMinimumPrice }); } catch(_) {}
            // Edge case assist: If only decrease thresholds now exist, ensure increase ones are null (stale UI race)
            if (!globalPercentIncrease && !globalDollarIncrease && (globalPercentDecrease || globalDollarDecrease)) {
                // Forcefully null (already) but log for clarity
                try { console.log('[GlobalAlerts][save] Increase side cleared; operating in DECREASE-ONLY mode.'); } catch(_) {}
            }
            await saveGlobalAlertSettingsDirectional({ globalPercentIncrease, globalDollarIncrease, globalPercentDecrease, globalDollarDecrease, globalMinimumPrice, hiLoMinimumPrice, hiLoMinimumMarketCap, emailAlertsEnabled });
            showCustomAlert('Global alert settings saved', 1200);
            try { hideModal(globalAlertsModal); } catch(e){}
            updateGlobalAlertsSettingsSummary();
            
            // Clear cached results when thresholds change to force fresh evaluation
            try {
                if (db && currentUserId && firestore) {
                    const alertsCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/alerts');
                    const summaryRef = firestore.doc(alertsCol, 'GA_SUMMARY');
                    const comprehensiveRef = firestore.doc(alertsCol, 'GA_SUMMARY_COMPREHENSIVE');
                    await firestore.deleteDoc(summaryRef).catch(()=>{});
                    await firestore.deleteDoc(comprehensiveRef).catch(()=>{});
                    globalAlertSummary = null; // local cache clear
                    console.log('[GlobalAlerts] Cleared cached results due to threshold changes');
                }
            } catch(delErr) { console.warn('Global Alerts: failed to clear cached results after threshold change', delErr); }
            // If all thresholds cleared, also clear summary doc counts by re-evaluating (it will early return)
            // Auto-refresh evaluation after saving settings so summary & counts reflect immediately
            try {
                if (typeof evaluateGlobalPriceAlerts === 'function') {
                    await evaluateGlobalPriceAlerts();
                } else if (typeof fetchLivePrices === 'function') {
                    await fetchLivePrices();
                }
                // Populate a fresh local movers snapshot for immediate UI fallback and project it into a GLOBAL_MOVERS-shaped object
                try {
                    if (typeof applyGlobalSummaryFilter === 'function') {
                        const freshEntries = applyGlobalSummaryFilter({ silent: true, computeOnly: true }) || [];
                        // Build a local GLOBAL_MOVERS projection so the modal can render immediately without waiting for central doc
                        try {
                            const ups = freshEntries.filter(e => (e.direction||'').toLowerCase() === 'up').map(e => ({
                                code: e.code,
                                live: e.live,
                                prevClose: e.prev,
                                pct: e.pct,
                                change: e.change,
                                direction: 'up'
                            }));
                            const downs = freshEntries.filter(e => (e.direction||'').toLowerCase() === 'down').map(e => ({
                                code: e.code,
                                live: e.live,
                                prevClose: e.prev,
                                pct: e.pct,
                                change: e.change,
                                direction: 'down'
                            }));
                            const gmLocal = {
                                updatedAt: new Date().toISOString(),
                                up: ups,
                                down: downs,
                                upCount: ups.length,
                                downCount: downs.length,
                                totalCount: ups.length + downs.length,
                                thresholds: null
                            };
                            try { window.globalMovers = gmLocal; } catch(_) {}
                            try { globalMovers = gmLocal; } catch(_) {}
                        } catch(_) {}
                    }
                } catch(_) {}
                // Immediately recompute centralized movers filtering with the new thresholds
                try { if (typeof window.recomputeGlobalMoversFiltered === 'function') window.recomputeGlobalMoversFiltered({ log: false }); } catch(_) {}
                // Refresh banner counts to reflect new effective thresholds right away
                try { if (typeof window.updateTargetHitBanner === 'function') window.updateTargetHitBanner(); } catch(_) {}
                // If Notifications modal is currently open, re-render it so explainer text and counts update instantly
                try {
                    const modalOpen = (typeof targetHitDetailsModal !== 'undefined' && targetHitDetailsModal && targetHitDetailsModal.style && targetHitDetailsModal.style.display !== 'none');
                    if (modalOpen && typeof showTargetHitDetailsModal === 'function') {
                        showTargetHitDetailsModal({ explicit: true, userInitiated: true });
                    }
                } catch(_) {}
            } catch(err) { console.warn('Global Alerts: post-save refresh failed', err); }
            // Run directional diagnostics immediately after save for user transparency
            try { runDirectionalThresholdDiagnostics(); } catch(diagErr){ console.warn('Global Alerts: diagnostics failed', diagErr); }
            // If all thresholds cleared, clear movers snapshot & refresh movers view immediately
            const clearedAll = !globalPercentIncrease && !globalDollarIncrease && !globalPercentDecrease && !globalDollarDecrease;
            if (clearedAll) {
                try { delete window.__lastMoversSnapshot; } catch(_) {}
                // Proactively delete GA_SUMMARY docs so listener emits null (prevents stale global counts)
                try {
                    if (db && currentUserId && firestore) {
                        const alertsCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/alerts');
                        const summaryRef = firestore.doc(alertsCol, 'GA_SUMMARY');
                        const comprehensiveRef = firestore.doc(alertsCol, 'GA_SUMMARY_COMPREHENSIVE');
                        await firestore.deleteDoc(summaryRef).catch(()=>{});
                        await firestore.deleteDoc(comprehensiveRef).catch(()=>{});
                        globalAlertSummary = null; // local cache clear
                        console.log('[GlobalAlerts] Cleared both GA_SUMMARY and GA_SUMMARY_COMPREHENSIVE');
                    }
                } catch(delErr) { console.warn('Global Alerts: failed to delete GA_SUMMARY docs after clear', delErr); }
                // Hide any open target hit modal if it only contained global summary
                try {
                    const onlyGlobal = sharesAtTargetPrice.length === 0 && (!sharesAtTargetPriceMuted || !sharesAtTargetPriceMuted.length);
                    if (onlyGlobal && targetHitDetailsModal && targetHitDetailsModal.style.display !== 'none') hideModal(targetHitDetailsModal);
                } catch(_) {}
                // Recompute banner (will drop globalSummaryCount to zero)
                try { updateTargetHitBanner(); } catch(_) {}
                if (currentSelectedWatchlistIds && currentSelectedWatchlistIds[0] === '__movers') {
                    try { enforceMoversVirtualView(true); } catch(e2){ console.warn('Movers refresh after clear failed', e2); }
                    showCustomAlert('Directional thresholds cleared – Movers list & global movers reset', 1600);
                } else {
                    showCustomAlert('Directional thresholds cleared', 1200);
                }
            }
        });
    }
    // Reflect visual state for email toggle on modal and keep class in sync
    try {
        if (emailAlertsEnabledInput && globalAlertsModal) {
            const updateEmailClass = () => {
                if (emailAlertsEnabledInput.checked) globalAlertsModal.classList.add('ga-email-on');
                else globalAlertsModal.classList.remove('ga-email-on');
            };
            // set initial and sync segmented buttons with hidden checkbox
            updateEmailClass();
            try { setEmailToggleUI(!!emailAlertsEnabledInput.checked); } catch(_) {}
            emailAlertsEnabledInput.addEventListener('change', updateEmailClass);
        }
    } catch(e) { console.warn('GlobalAlerts: failed to bind email toggle class', e); }

// Diagnostics: Inspect each live price vs current directional thresholds to detect incorrect triggering
function runDirectionalThresholdDiagnostics(options={}) {
    if (!livePrices) { console.warn('[DiagDirectional] livePrices unavailable'); return null; }
    const results = [];
    const hasUp = (typeof globalPercentIncrease === 'number' && globalPercentIncrease>0) || (typeof globalDollarIncrease === 'number' && globalDollarIncrease>0);
    const hasDown = (typeof globalPercentDecrease === 'number' && globalPercentDecrease>0) || (typeof globalDollarDecrease === 'number' && globalDollarDecrease>0);
    Object.entries(livePrices).forEach(([code, lp])=>{
        if(!lp || lp.live==null || lp.prevClose==null) return;
        const change = lp.live - lp.prevClose;
        if(change===0) return;
        const pctSigned = lp.prevClose!==0 ? (change / lp.prevClose)*100 : 0;
        const pctMag = Math.abs(pctSigned);
        const upQualified = hasUp && ((globalPercentIncrease && pctSigned >= globalPercentIncrease) || (globalDollarIncrease && change >= globalDollarIncrease));
        const downQualified = hasDown && ((globalPercentDecrease && pctMag >= globalPercentDecrease && change < 0) || (globalDollarDecrease && Math.abs(change) >= globalDollarDecrease && change < 0));
        // Detect misclassification: positive change counted only by decrease side or vice versa
        const potentialBug = (change>0 && downQualified && !upQualified) || (change<0 && upQualified && !downQualified);
        if (upQualified || downQualified || potentialBug) {
            results.push({ code, live: lp.live, prev: lp.prevClose, change, pctSigned: +pctSigned.toFixed(2), dir: change>0?'up':'down', upQualified, downQualified, potentialBug });
        }
    });
    try {
        const summary = {
            thresholds: { upPct: globalPercentIncrease, upDol: globalDollarIncrease, downPct: globalPercentDecrease, downDol: globalDollarDecrease },
            upCount: results.filter(r=>r.upQualified && r.dir==='up').length,
            downCount: results.filter(r=>r.downQualified && r.dir==='down').length,
            potentialBugCount: results.filter(r=>r.potentialBug).length
        };
        console.groupCollapsed('%c[DiagDirectional] Threshold evaluation','color:#2d6cdf;font-weight:600;');
        console.table(results);
        console.log('[DiagDirectional][summary]', summary);
        if (summary.potentialBugCount>0) console.warn('[DiagDirectional] Potential misclassification detected.');
        console.groupEnd();
    } catch(_) {}
    return results;
}
window.runDirectionalThresholdDiagnostics = runDirectionalThresholdDiagnostics;
    if (!window.__globalAlertsEscBound) {
        window.__globalAlertsEscBound = true;
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && globalAlertsModal && globalAlertsModal.style.display !== 'none') { try { hideModal(globalAlertsModal); } catch(_) {} }
        });
    }
    if (globalAlertsModal && !globalAlertsModal.__outsideClickBound) {
        globalAlertsModal.__outsideClickBound = true;
        globalAlertsModal.addEventListener('mousedown', (e) => { if (e.target === globalAlertsModal) { try { hideModal(globalAlertsModal); } catch(_) {} } });
    }
}

if (!window.__globalAlertsDomReadyBound) {
    window.__globalAlertsDomReadyBound = true;
    document.addEventListener('DOMContentLoaded', () => initGlobalAlertsUI());
    // Safety: if script loaded after DOMContentLoaded already fired
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
        try { initGlobalAlertsUI(); } catch(_){}
    }
}

// (Deprecated) Previous alerts settings listener retained for reference
async function loadAlertsSettingsListener() {
    if (unsubscribeAlerts) { try { unsubscribeAlerts(); } catch(_){} unsubscribeAlerts=null; }
    if (!db || !currentUserId || !firestore) { console.warn('Alerts: Firestore unavailable for settings listener'); return; }
    try {
        const alertsCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/alerts');
        unsubscribeAlerts = firestore.onSnapshot(alertsCol, (qs) => {
            alertsEnabledMap = new Map();
            qs.forEach(doc => { const d = doc.data()||{}; alertsEnabledMap.set(doc.id, (d.enabled !== false)); });
            try { console.log('[Diag][alertsSettingsListener] map size:', alertsEnabledMap.size); } catch(_){}
            recomputeTriggeredAlerts();
        }, err => console.error('Alerts: settings listener error', err));
        logDebug('Alerts: Settings listener active.');
    } catch (e) { console.error('Alerts: failed to init settings listener', e); }
}

// NEW: Function to render alerts in the alert panel (currently empty, but planned for future)
function renderAlertsInPanel() {
    // alertList and closeAlertPanelBtn, clearAllAlertsBtn are currently not in index.html, so this function is a placeholder
    // If you add the alert panel back, ensure these elements exist.
    if (!alertPanel) {
        console.warn('Alert Panel: Alert panel elements not found. Skipping renderAlertsInPanel.');
        return;
    }

    // Placeholder for alert rendering logic if you re-introduce the alert panel
    logDebug('Alert Panel: Rendering alerts in panel (placeholder).');
}


/**
 * Toggles the mobile view mode between default (single column) and compact (two columns).
 * Updates the UI to reflect the new mode and saves preference to local storage.
 */
// Robust persistence with error recovery and debouncing
let viewModePersistenceTimer = null;
let sortOrderPersistenceTimer = null;
let viewModeConsistencyChecker = null;

// View mode watcher to ensure it's applied when DOM is ready
let viewModeWatcherActive = false;
let viewModeApplicationInProgress = false;
let globalViewModeWatcher = null;

// Function to ensure compact view consistency throughout the session
function startViewModeConsistencyChecker() {
    // Ensure only one consistency checker interval runs
    try { if (window.__viewModeConsistencyActive && viewModeConsistencyChecker) clearInterval(viewModeConsistencyChecker); } catch(_) {}
    window.__viewModeConsistencyActive = true;

    viewModeConsistencyChecker = setInterval(() => {
        if (!viewModeInitialized) return;

        const container = getMobileShareCardsContainer();
        if (container) {
            const hasCompactClass = container.classList.contains('compact-view');
            const expectedCompact = currentMobileViewMode === 'compact';

            if (hasCompactClass !== expectedCompact) {
                console.warn('🚨 View Mode Consistency Check: MISMATCH DETECTED!');
                console.warn('   Expected:', expectedCompact ? 'compact' : 'default');
                console.warn('   Actual DOM:', hasCompactClass ? 'compact' : 'default');
                console.warn('   Current state:', currentMobileViewMode);

                // Auto-correct the mismatch
                if (expectedCompact) {
                    container.classList.add('compact-view');
                    console.log('🔧 Consistency Check: Restored compact class');
                } else {
                    container.classList.remove('compact-view');
                    console.log('🔧 Consistency Check: Removed compact class');
                }
            }
        }
    }, 5000); // Check every 5 seconds

    console.log('✅ View Mode Consistency Checker started');
}

function startViewModeWatcher() {
    if (viewModeWatcherActive) return;
    viewModeWatcherActive = true;

    logDebug('View Mode: Starting persistent DOM watcher for mobileShareCardsContainer');

    let attempts = 0;
    const maxAttempts = 50; // 5 seconds max

    const checkAndApply = async () => {
        attempts++;

        try {
            // First, ensure we have the view mode
            if (!currentMobileViewMode) {
                const storedMode = localStorage.getItem('currentMobileViewMode');
                if (storedMode === 'compact' || storedMode === 'default') {
                    currentMobileViewMode = storedMode;
                    logDebug('View Mode: Watcher recovered mode from storage: ' + currentMobileViewMode);
                }
            }

            const mobileContainer = getMobileShareCardsContainer();
            if (mobileContainer && currentMobileViewMode) {
                // Always start with clean slate
                mobileContainer.classList.remove('compact-view');

                if (currentMobileViewMode === 'compact') {
                    mobileContainer.classList.add('compact-view');
                    logDebug('View Mode: Watcher successfully applied COMPACT mode to DOM (attempt ' + attempts + ')');
                } else {
                    logDebug('View Mode: Watcher successfully applied DEFAULT mode to DOM (attempt ' + attempts + ')');
                }

                viewModeWatcherActive = false; // Stop watching once applied
                return;
            }
        } catch (error) {
            console.warn('View Mode: Watcher failed to apply mode on attempt ' + attempts + ':', error);
        }

        // If container not ready or max attempts reached, check again
        if (viewModeWatcherActive && attempts < maxAttempts) {
            setTimeout(checkAndApply, 100);
        } else if (attempts >= maxAttempts) {
            console.warn('View Mode: Watcher gave up after ' + maxAttempts + ' attempts');
            viewModeWatcherActive = false;
        }
    };

    checkAndApply();
}

// Global view mode enforcer - runs periodically to ensure view mode is maintained
function startGlobalViewModeEnforcer() {
    // Ensure only one global enforcer interval runs
    try { if (window.__globalViewModeEnforcerActive && globalViewModeWatcher) clearInterval(globalViewModeWatcher); } catch(_) {}
    window.__globalViewModeEnforcerActive = true;

    logDebug('View Mode: Starting global enforcer');

    globalViewModeWatcher = setInterval(() => {
        try {
            // Check if DOM matches the expected state
            const container = getMobileShareCardsContainer();
            if (container && currentMobileViewMode) {
                const hasCompactClass = container.classList.contains('compact-view');
                const shouldHaveCompactClass = currentMobileViewMode === 'compact';

                if (hasCompactClass !== shouldHaveCompactClass) {
                    // DOM is wrong, fix it using centralized manager
                    console.log('View Mode: Global enforcer detected mismatch, correcting...');
                    setMobileViewMode(currentMobileViewMode, 'global_enforcer_correction');
                }
            } else if (!currentMobileViewMode || !viewModeInitialized) {
                // Try to recover the mode
                console.log('View Mode: Global enforcer detected uninitialized state, attempting recovery...');
                recoverViewMode('global_enforcer').catch(error => {
                    console.warn('View Mode: Global enforcer recovery failed:', error);
                });
            }
        } catch (error) {
            console.warn('View Mode: Global enforcer error:', error);
        }
    }, 2000); // Check every 2 seconds (less aggressive to avoid console spam)
}

async function toggleMobileViewMode() {
    const newMode = (currentMobileViewMode === 'default') ? 'compact' : 'default';
    // Push previous mode for shallow back restore
    try { pushAppStateEntry('viewMode', currentMobileViewMode); } catch(_) {}
    // Also push a browser history entry so popstate fires on Back
    try { if (typeof pushAppState === 'function') pushAppState({ viewMode: newMode }, '', '#view'); } catch(_) {}

    // Use the centralized view mode manager
    const success = setMobileViewMode(newMode, 'toggle_button');

    if (success) {
        // Show user feedback
        if (newMode === 'compact') {
            showCustomAlert('Switched to Compact View!', 1000);
        } else {
            showCustomAlert('Switched to Default View!', 1000);
        }
    }

    return success;
}

// Robust sort order persistence with error recovery and debouncing
async function robustSaveSortOrder(sortOrder) {
    if (!sortOrder) {
        console.warn('Sort: Cannot save empty sort order');
        return;
    }

    // Clear any pending save operation
    if (sortOrderPersistenceTimer) {
        clearTimeout(sortOrderPersistenceTimer);
    }

    // Debounced persistence
    sortOrderPersistenceTimer = setTimeout(async () => {
        try {
            // Save global sort order to localStorage first (immediate)
            try {
                localStorage.setItem('lastSortOrder', sortOrder);
                logDebug('Sort: Saved global sort to localStorage: ' + sortOrder);
            } catch (localError) {
                console.warn('Sort: Failed to save global sort to localStorage:', localError);
            }

            // Save global sort order to Firestore (async)
            if (currentUserId && db && firestore) {
                try {
                    await saveSortOrderPreference(sortOrder);
                    logDebug('Sort: Saved global sort to Firestore: ' + sortOrder);
                } catch (firestoreError) {
                    console.warn('Sort: Failed to save global sort to Firestore:', firestoreError);
                }
            }

            // Save per-watchlist sort order
            if (currentSelectedWatchlistIds.length > 0) {
                const currentWatchlistId = currentSelectedWatchlistIds[0];
                if (currentWatchlistId && currentUserId) {
                    try {
                        await saveWatchlistSortOrder(null, null, currentUserId, null, currentWatchlistId, sortOrder);
                        logDebug('Sort: Saved per-watchlist sort for ' + currentWatchlistId + ': ' + sortOrder);
                    } catch (watchlistError) {
                        console.warn('Sort: Failed to save per-watchlist sort order for ' + currentWatchlistId + ':', watchlistError);
                    }
                }
            }

        } catch (error) {
            console.error('Sort: Critical error in robustSaveSortOrder:', error);
            // Final fallback: ensure localStorage is set
            try {
                localStorage.setItem('lastSortOrder', sortOrder);
                logDebug('Sort: Emergency fallback - saved to localStorage only');
            } catch (emergencyError) {
                console.error('Sort: Emergency fallback also failed:', emergencyError);
            }
        }
    }, 500); // 500ms debounce for sort operations
}

// Robust preference restoration with error recovery
async function robustRestoreViewAndModeFromPreferences() {
    logDebug('Preferences: Starting robust restoration...');

    try {
        // Step 1: Restore last selected view/watchlist
        await robustRestoreLastView();
        logDebug('Preferences: Last view restored successfully');
    } catch (error) {
        console.warn('Preferences: Failed to restore last view:', error);
    }

    try {
        // Step 2: Restore view mode (compact/default)
        await robustRestoreViewMode();
        logDebug('Preferences: View mode restored successfully');
    } catch (error) {
        console.warn('Preferences: Failed to restore view mode:', error);
    }

    try {
        // Step 3: Restore sort order for current watchlist
        await robustRestoreSortOrder();
        logDebug('Preferences: Sort order restored successfully');
    } catch (error) {
        console.warn('Preferences: Failed to restore sort order:', error);
    }

    // Step 4: Force UI update to ensure everything is applied
    try {
        // Use centralized manager to ensure view mode is correct
        if (currentMobileViewMode) {
            setMobileViewMode(currentMobileViewMode, 'final_ui_update');
        }

        // Also do a direct check to ensure DOM is correct
        const container = getMobileShareCardsContainer();
        if (container && currentMobileViewMode) {
            container.classList.remove('compact-view');
            if (currentMobileViewMode === 'compact') {
                container.classList.add('compact-view');
                logDebug('Preferences: Direct DOM correction applied COMPACT mode');
            } else {
                logDebug('Preferences: Direct DOM correction applied DEFAULT mode');
            }
        }

        if (typeof renderWatchlist === 'function') {
            renderWatchlist();
            logDebug('Preferences: UI rendered after restoration');
        }
        if (typeof updateMainTitle === 'function') {
            updateMainTitle();
            logDebug('Preferences: Title updated after restoration');
        }
    } catch (error) {
        console.warn('Preferences: Failed to update UI after restoration:', error);
    }
}

async function robustRestoreLastView() {
    let lastView = null;

    // Try localStorage first (immediate)
    try {
        lastView = localStorage.getItem('lastSelectedView');
        if (lastView) {
            logDebug('Preferences: Found last view in localStorage: ' + lastView);
        }
    } catch (error) {
        console.warn('Preferences: Failed to read last view from localStorage:', error);
    }

    // Try Firestore if localStorage didn't work
    if (!lastView && userPreferences && userPreferences.lastSelectedView) {
        lastView = userPreferences.lastSelectedView;
        logDebug('Preferences: Using Firestore fallback for last view: ' + lastView);
    }

    if (lastView) {
        try {
            // Apply the last view
            if (lastView === 'portfolio') {
                if (typeof showPortfolioView === 'function') {
                    showPortfolioView();
                    try { scrollMainToTop(true); } catch(_) {}
                    logDebug('Preferences: Restored portfolio view');
                }
            } else if (typeof watchlistSelect !== 'undefined' && watchlistSelect) {
                // Check if it's a movers virtual view
                if (lastView === '__movers') {
                    try { watchlistSelect.value = ALL_SHARES_ID; } catch(_) {}
                    setCurrentSelectedWatchlistIds(['__movers']);
                    if (typeof sortShares === 'function') sortShares();
                    if (typeof enforceMoversVirtualView === 'function') enforceMoversVirtualView();
                    if (typeof updateMainTitle === 'function') updateMainTitle('Movers');
                    if (typeof scheduleMoversDeferredEnforce === 'function') scheduleMoversDeferredEnforce();
                    logDebug('Preferences: Restored movers virtual view');
                } else {
                    // Regular watchlist
                    const opt = Array.from(watchlistSelect.options).find(o => o.value === lastView);
                    if (opt) {
                        watchlistSelect.value = lastView;
                        setCurrentSelectedWatchlistIds([lastView]);
                        if (typeof sortShares === 'function') sortShares();
                        try { scrollMainToTop(); } catch(_) {}
                        if (typeof updateMainTitle === 'function') updateMainTitle();
                        logDebug('Preferences: Restored watchlist: ' + lastView);
                    } else {
                        logDebug('Preferences: Watchlist option not found: ' + lastView);
                    }
                }
            }
        } catch (error) {
            console.warn('Preferences: Failed to apply last view:', error);
        }
    } else {
        logDebug('Preferences: No last view found, defaulting to All Shares');
        // Default to All Shares when no valid last view is found
        try {
            setCurrentSelectedWatchlistIds([ALL_SHARES_ID]);
            if (typeof watchlistSelect !== 'undefined' && watchlistSelect) {
                watchlistSelect.value = ALL_SHARES_ID;
            }
            if (typeof sortShares === 'function') {
                sortShares();
            }
            if (typeof updateMainTitle === 'function') {
                updateMainTitle();
            }
            logDebug('Preferences: Successfully defaulted to All Shares');
        } catch (error) {
            console.warn('Preferences: Failed to apply All Shares default:', error);
        }
    }
}

async function robustRestoreViewMode() {
    let storedMode = null;

    // Try localStorage first
    try {
        storedMode = localStorage.getItem('currentMobileViewMode');
        if (storedMode) {
            logDebug('Preferences: Found view mode in localStorage: ' + storedMode);
        }
    } catch (error) {
        console.warn('Preferences: Failed to read view mode from localStorage:', error);
    }

    // Try Firestore fallback (direct call to new function)
    if (!storedMode && currentUserId && db && firestore) {
        try {
            logDebug('Preferences: Trying to load view mode from Firestore...');
            storedMode = await loadViewModePreference(db, firestore, currentUserId, currentAppId);
            if (storedMode) {
                logDebug('Preferences: Loaded view mode from Firestore: ' + storedMode);
            }
        } catch (error) {
            console.warn('Preferences: Failed to load view mode from Firestore:', error);
        }
    }

    // Validate and apply the mode
    if (storedMode !== 'compact' && storedMode !== 'default') {
        storedMode = 'default';
        logDebug('Preferences: Invalid view mode, defaulting to: ' + storedMode);
    }

    try {
        // Use the centralized view mode manager
        setMobileViewMode(storedMode, 'robust_restore');
        logDebug('Preferences: Successfully restored view mode using centralized manager: ' + storedMode);
    } catch (error) {
        console.warn('Preferences: Failed to restore view mode with centralized manager:', error);
        // Try recovery as last resort
        recoverViewMode('robust_restore_failed').catch(error => {
            console.warn('View Mode: Robust restore recovery failed:', error);
        });
    }
}

// Robust UI application with retry mechanism for DOM readiness
async function applyViewModeToUI(mode) {
    // Prevent multiple simultaneous applications
    if (viewModeApplicationInProgress) {
        logDebug('View Mode: Application already in progress, skipping: ' + mode);
        return;
    }

    viewModeApplicationInProgress = true;
    const maxRetries = 10;
    const retryDelay = 100; // 100ms

    try {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const container = getMobileShareCardsContainer();
                if (container) {
                    // Always start with clean slate
                    container.classList.remove('compact-view');

                    if (mode === 'compact') {
                        container.classList.add('compact-view');
                        logDebug('Preferences: Applied COMPACT view mode to UI (attempt ' + attempt + ')');
                    } else {
                        logDebug('Preferences: Applied DEFAULT view mode to UI (attempt ' + attempt + ')');
                    }

                    viewModeApplicationInProgress = false;
                    return; // Success, exit the retry loop
                } else {
                    logDebug('Preferences: mobileShareCardsContainer not ready (attempt ' + attempt + ')');
                    if (attempt < maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                    }
                }
            } catch (error) {
                console.warn('Preferences: Failed to apply view mode on attempt ' + attempt + ':', error);
                if (attempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                }
            }
        }
    } catch (error) {
        console.error('Preferences: Critical error in applyViewModeToUI:', error);
    }

    // Always reset the flag
    viewModeApplicationInProgress = false;

    // If we get here, all retries failed
    console.warn('Preferences: Failed to apply view mode after ' + maxRetries + ' attempts');
}

async function robustRestoreSortOrder() {
    let candidateSort = null;

    // Try watchlist-specific sort order first
    if (currentSelectedWatchlistIds && currentSelectedWatchlistIds.length > 0) {
        const currentWatchlistId = currentSelectedWatchlistIds[0];
        try {
            const watchlistSortOrder = getSortOrderForWatchlist(currentWatchlistId);
            if (watchlistSortOrder) {
                candidateSort = watchlistSortOrder;
                logDebug('Preferences: Found watchlist-specific sort order: ' + candidateSort);
            }
        } catch (error) {
            console.warn('Preferences: Failed to get watchlist-specific sort order:', error);
        }
    }

    // Fallback to global sort order
    if (!candidateSort) {
        try {
            candidateSort = localStorage.getItem('lastSortOrder') || null;
            if (candidateSort) {
                logDebug('Preferences: Using global sort order from localStorage: ' + candidateSort);
            }
        } catch (error) {
            console.warn('Preferences: Failed to read global sort order from localStorage:', error);
        }
    }

    // Apply the sort order
    if (candidateSort) {
        try {
            setCurrentSortOrder(candidateSort);
            logDebug('Preferences: Applied sort order: ' + candidateSort);

            // Update UI if elements are ready
            if (sortSelect) {
                sortSelect.value = candidateSort;
                if (typeof updateSortIcon === 'function') {
                    updateSortIcon();
                }
                logDebug('Preferences: Updated sort select UI');
            } else {
                logDebug('Preferences: sortSelect not ready, sort order will be applied later');
            }
        } catch (error) {
            console.warn('Preferences: Failed to apply sort order:', error);
        }
    } else {
        // Use default sort order
        const defaultSort = (currentSelectedWatchlistIds && currentSelectedWatchlistIds.includes(CASH_BANK_WATCHLIST_ID))
            ? 'name-asc'
            : 'percentageChange-desc';
        try {
            setCurrentSortOrder(defaultSort);
            logDebug('Preferences: Using default sort order: ' + defaultSort);
        } catch (error) {
            console.warn('Preferences: Failed to set default sort order:', error);
        }
    }
}

// NEW: Splash Screen Functions
let splashScreenReady = false; // Flag to ensure splash screen is ready before hiding

/**
 * Hides the splash screen with a fade-out effect.
 */
function hideSplashScreen() {
    console.log('[Debug] hideSplashScreen function called.');
    if (splashScreen) {
        // Set version text just before hiding
        const versionEl = document.getElementById('splashAppVersion');
        if (versionEl) {
            versionEl.textContent = 'v' + APP_VERSION;
        }

        console.log('[Debug] splashScreen element found. Adding "hidden" class.');
        splashScreen.classList.add('hidden'); // Start fade-out
        if (splashKangarooIcon) {
            splashKangarooIcon.classList.remove('pulsing'); // Stop animation
        }
        // Show main app content
        if (mainContainer) {
            mainContainer.classList.remove('app-hidden');
        }
        if (appHeader) { // Assuming header is part of the main app content that needs to be revealed
            appHeader.classList.remove('app-hidden');

        }
        // Temporarily remove overflow hidden from body
        document.body.style.overflow = ''; 

        // REMOVED: splashScreen.addEventListener('transitionend', () => { if (splashScreen.parentNode) { splashScreen.parentNode.removeChild(splashScreen); } }, { once: true });
        logDebug('Splash Screen: Hiding.');
    }
}

/**
 * Checks if all necessary app data is loaded and hides the splash screen if ready.
 * This function is called after each major data loading step.
 */
function hideSplashScreenIfReady() {
    console.log('[Debug] hideSplashScreenIfReady called. State:', {
        firebase: window._firebaseInitialized,
        auth: window._userAuthenticated,
        appData: window._appDataLoaded,
        livePrices: window._livePricesLoaded,
        splashReady: splashScreenReady
    });
    // Only hide if Firebase is initialized, user is authenticated, and all data flags are true
    const authGraceOk = (function(){
        try { return window.__authReadyAt && (Date.now() - window.__authReadyAt) > 9000; } catch(_) { return false; }
    })();
    // New ultra-conservative failsafe: if the user has been authenticated for a while
    // but some flag hasn’t flipped yet (e.g., a Firestore listener hiccup), force-hide
    // the splash after a longer grace. Normal behavior remains unchanged when flags are fine.
    const extendedAuthGraceOk = (function(){
        try { return window.__authReadyAt && (Date.now() - window.__authReadyAt) > 12000; } catch(_) { return false; }
    })();
    if (window._firebaseInitialized && window._userAuthenticated && window._appDataLoaded && (window._livePricesLoaded || authGraceOk)) {
        if (splashScreenReady) { // Ensure splash screen itself is ready to be hidden
            logDebug('Splash Screen: All data loaded and ready. Hiding splash screen.');
            hideSplashScreen();
            // If user last viewed portfolio, ensure portfolio view is shown now that data is ready
            try {
                const lastView = localStorage.getItem('lastSelectedView');
                if (lastView === 'portfolio' && typeof showPortfolioView === 'function') {
                    showPortfolioView();
                }
            } catch(e) {}
        } else {
            logDebug('Splash Screen: Data loaded, but splash screen not yet marked as ready. Will hide when ready.');
        }
    } else {
        logDebug('Splash Screen: Not all data loaded yet. Current state: ' +
            'Firebase Init: ' + window._firebaseInitialized +
            ', User Auth: ' + window._userAuthenticated +
            ', App Data: ' + window._appDataLoaded +
            ', Live Prices: ' + window._livePricesLoaded);

        // Force-unblock UI if user is authenticated and we’ve waited long enough.
        // This avoids indefinite splash in rare error paths while allowing the app to continue.
        if (window._firebaseInitialized && window._userAuthenticated && extendedAuthGraceOk) {
            console.warn('[Splash Failsafe] Forcing splash hide after extended auth grace. Flags:', {
                firebase: window._firebaseInitialized,
                auth: window._userAuthenticated,
                appData: window._appDataLoaded,
                livePrices: window._livePricesLoaded
            });
            if (splashScreenReady) hideSplashScreen();
        }
    }
}

/**
 * Sets up a real-time Firestore listener for shares.
 * Updates `allSharesData` and triggers UI re-render via `renderWatchlist` (indirectly through `fetchLivePrices` or `sortShares`).
 */
/* moved to dataService.js */
/* async function loadShares() {
    if (unsubscribeShares) {
        unsubscribeShares();
        unsubscribeShares = null;
        logDebug('Firestore Listener: Unsubscribed from previous shares listener.');
    }

    if (!db || !currentUserId || !firestore) {
        console.warn('Shares: Firestore DB, User ID, or Firestore functions not available for loading shares. Clearing list.');
        setAllSharesData([]); // Clear data if services aren't available
        // renderWatchlist(); // No need to call here, onAuthStateChanged will handle initial render
        window._appDataLoaded = false;
        hideSplashScreen(); 
        return;
    }
    
    try {
        const sharesCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/shares');
        let q = firestore.query(sharesCol); // Listener for all shares, filtering for display done in renderWatchlist

        unsubscribeShares = firestore.onSnapshot(q, async (querySnapshot) => {
            logDebug('Firestore Listener: Shares snapshot received. Processing changes.');
            let fetchedShares = [];
            querySnapshot.forEach((doc) => {
                const share = { id: doc.id, ...doc.data() };
                fetchedShares.push(share);
            });

            setAllSharesData(dedupeSharesById(fetchedShares));
            logDebug('Shares: Shares data updated from snapshot. Total shares: ' + allSharesData.length);

            // Backfill intent field from alertsEnabledMap / alerts collection if missing
            try {
                if (Array.isArray(allSharesData) && alertsEnabledMap && typeof alertsEnabledMap === 'object') {
                    allSharesData.forEach(s => {
                        if (s && (s.intent === undefined || s.intent === null || s.intent === '')) {
                            // Try to find corresponding alert in sharesAtTargetPriceMuted or sharesAtTargetPrice arrays first
                            const alertMatch = (sharesAtTargetPrice||[]).concat(sharesAtTargetPriceMuted||[]).find(a=>a && a.id===s.id);
                            if (alertMatch && alertMatch.intent) s.intent = alertMatch.intent;
                        }
                    });
                }
            } catch(e){ console.warn('Intent backfill failed', e); }
            
            // AGGRESSIVE FIX: Force apply current sort order after data loads
            forceApplyCurrentSort();
            
            sortShares(); // Sorts allSharesData and calls renderWatchlist
            renderAsxCodeButtons(); // Re-renders ASX buttons based on allSharesData
            
            // REMOVED this line as it's now handled by the fetchLivePrices() call in onAuthStateChanged
            // await fetchLivePrices(); 
            
            if (loadingIndicator) loadingIndicator.style.display = 'none';
            window._appDataLoaded = true;
            hideSplashScreenIfReady();

        }, (error) => {
            console.error('Firestore Listener: Error listening to shares:', error);
            showCustomAlert('Error loading shares in real-time: ' + error.message);
            if (loadingIndicator) loadingIndicator.style.display = 'none';
            window._appDataLoaded = false;
            hideSplashScreen(); 
        });

    } catch (error) {
        console.error('Shares: Error setting up shares listener:', error);
        showCustomAlert('Error setting up real-time share updates: ' + error.message);
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        window._appDataLoaded = false;
        hideSplashScreen(); 
    }
} */

// NEW: Cash & Assets Functions (3.1)

/**
 * Sets up a real-time Firestore listener for cash categories.
 * Updates `userCashCategories` and triggers UI re-render via `renderWatchlist`.
 */
/* moved to dataService.js */
/* async function loadCashCategories() {
    if (unsubscribeCashCategories) {
        unsubscribeCashCategories();
        unsubscribeCashCategories = null;
        logDebug('Firestore Listener: Unsubscribed from previous cash categories listener.');
    }

    if (!db || !currentUserId || !firestore) {
        console.warn('Cash Categories: Firestore DB, User ID, or Firestore functions not available for loading cash categories. Clearing list.');
        userCashCategories = [];
        renderCashCategories(); // Render with empty data
        return;
    }

    try {
        const cashCategoriesCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/cashCategories');
        const q = firestore.query(cashCategoriesCol);

        unsubscribeCashCategories = firestore.onSnapshot(q, (querySnapshot) => {
            logDebug('Firestore Listener: Cash categories snapshot received. Processing changes.');
            let fetchedCategories = [];
            querySnapshot.forEach((doc) => {
                const category = { id: doc.id, ...doc.data() };
                fetchedCategories.push(category);
            });

            userCashCategories = fetchedCategories; // Sort will be applied in renderCashCategories
            logDebug('Cash Categories: Data updated from snapshot. Total categories: ' + userCashCategories.length);
            
            // Trigger a re-render of the overall watchlist, which will then call renderCashCategories if needed
            renderWatchlist(); 
            calculateTotalCash(); // Ensure total is updated whenever categories change

        }, (error) => {
            console.error('Firestore Listener: Error listening to cash categories:', error);
            showCustomAlert('Error loading cash categories in real-time: ' + error.message);
        });

    } catch (error) {
        console.error('Cash Categories: Error setting up cash categories listener:', error);
        showCustomAlert('Error setting up real-time cash category updates: ' + error.message);
    }
} */

/**
 * Renders the cash categories in the UI. (1)
 */
// moved to uiService.renderCashCategories()
/**
 * Adds a new empty cash category to the UI and `userCashCategories` array.
 * This function is now primarily for triggering the modal for a new entry.
 */
function addCashCategoryUI() {
    logDebug('Cash Categories: Add new category UI triggered.');
    // This function now directly opens the modal for a new cash asset.
    try {
        // If suppression is active for cash modal reopens, avoid programmatic opens for the just-saved ID
        const shouldOpen = !(window.__suppressCashModalReopen && window.__justSavedCashAssetId);
        if (shouldOpen) showAddEditCashCategoryModal(null); else { window.logDebug && window.logDebug('Suppressed programmatic open of Add Cash modal due to recent save'); }
    } catch(_) { try { showAddEditCashCategoryModal(null); } catch(__) {} }
}

/**
 * This function is no longer used for saving from the main view,
 * as saving now occurs via the modal.
 * Kept as a placeholder in case its logic is needed elsewhere.
 */
async function saveCashCategories() {
    logDebug('saveCashCategories: This function is deprecated. Saving now handled via modal save.');
    // No longer iterates through UI inputs.
    // The onSnapshot listener handles updates from modal saves.
}

/**
 * Deletes a specific cash category from Firestore.
 * @param {string} categoryId The ID of the category to delete.
 */
async function deleteCashCategory(categoryId) {
    if (!categoryId) { showCustomAlert('No cash asset selected for deletion.'); return false; }

    // Try to resolve a friendly name for messaging
    let assetName = 'this cash asset';
    try {
        const list = (typeof getUserCashCategories === 'function') ? (getUserCashCategories() || []) : [];
        const item = list.find(x => x && (x.id === categoryId || x.docId === categoryId));
        if (item && item.name) assetName = item.name;
    } catch (_) {}

    // Show confirmation modal; perform deletion only if confirmed
    return await new Promise((resolve) => {
        const confirmFn = (typeof showCustomConfirm === 'function') ? showCustomConfirm : (window.showCustomConfirm || null);
        if (!confirmFn) { showCustomAlert('Confirmation UI unavailable, deletion cancelled.'); resolve(false); return; }
        confirmFn(`Delete "${assetName}"? This action cannot be undone.`, async (confirmed) => {
            if (!confirmed) { resolve(false); return; }
            try {
                if (window.AppService && typeof window.AppService.deleteCashCategory === 'function') {
                    await window.AppService.deleteCashCategory(categoryId);
                } else if (db && firestore && currentUserId) {
                    const categoryDocRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/cashCategories', categoryId);
                    await firestore.deleteDoc(categoryDocRef);
                } else {
                    showCustomAlert('Firestore not available. Cannot delete cash category.');
                    resolve(false);
                    return;
                }
                showCustomAlert('Category deleted successfully!', 1500);
                logDebug('Firestore: Cash category (ID: ' + categoryId + ') deleted.');
                resolve(true);
            } catch (error) {
                console.error('Firestore: Error deleting cash category:', error);
                showCustomAlert('Error deleting category: ' + error.message);
                resolve(false);
            }
        });
    });
}

/**
 * Calculates and displays the total cash balance. (1)
 */
// moved to uiService.calculateTotalCash()

// NEW: Cash Asset Form Modal Functions (2.1) moved to uiService

function clearCashAssetForm() {
    if (cashAssetNameInput) cashAssetNameInput.value = '';
    if (cashAssetBalanceInput) cashAssetBalanceInput.value = '';
    if (cashAssetCommentsContainer) cashAssetCommentsContainer.innerHTML = ''; // Clear comments
    selectedCashAssetDocId = null;
    originalCashAssetData = null; // Reset original data
    setIconDisabled(saveCashAssetBtn, true); // Disable save button
    logDebug('Cash Form: Cash asset form cleared.');
}

// moved to uiService.getCurrentCashAssetFormData()

function areCashAssetDataEqual(data1, data2) {
    if (!data1 || !data2) return false;
    let balance1 = typeof data1.balance === 'number' && !isNaN(data1.balance) ? data1.balance : null;
    let balance2 = typeof data2.balance === 'number' && !isNaN(data2.balance) ? data2.balance : null;
    
    // NEW: Compare isHidden state
    if (data1.name !== data2.name || balance1 !== balance2 || data1.isHidden !== data2.isHidden) {
        return false;
    }

    // Deep compare comments
    if (data1.comments.length !== data2.comments.length) {
        return false;
    }
    for (let i = 0; i < data1.comments.length; i++) {
        const comment1 = data1.comments[i];
        const comment2 = data2.comments[i];
        if (comment1.title !== comment2.title || comment1.text !== comment2.text) {
            return false;
        }
    }
    return true;
}

function checkCashAssetFormDirtyState() {
    const currentData = getCurrentCashAssetFormData();
    const isNameValid = currentData.name.trim() !== '';
    let canSave = isNameValid;

    if (selectedCashAssetDocId && originalCashAssetData) {
        // For existing assets, enable save if data is dirty (including checkbox state)
        const isDirty = !areCashAssetDataEqual(originalCashAssetData, currentData);
        canSave = canSave && isDirty;
        if (!isDirty) {
            logDebug('Dirty State: Existing cash asset: No changes detected, save disabled.');
        }
    } else if (!selectedCashAssetDocId) {
        // For new cash assets, enable if name is valid (no original data to compare against)
        // 'canSave' is already 'isNameValid' here.
    }

    setIconDisabled(saveCashAssetBtn, !canSave);
    logDebug('Dirty State: Cash asset save button enabled: ' + canSave);
}

async function saveCashAsset(isSilent = false) {
    logDebug('Cash Form: saveCashAsset called (delegated-only).');

    // Enforce single canonical save path: AppService.saveCashAsset must exist.
    if (!window.AppService || typeof window.AppService.saveCashAsset !== 'function') {
        console.error('saveCashAsset: AppService.saveCashAsset not available — cannot complete save.');
        if (!isSilent) {
            try { window.showCustomAlert && window.showCustomAlert('Internal error: Save service unavailable. Please refresh the page.', 4000); } catch(_) {}
        }
        return;
    }

    // Delegate to canonical service and mirror minimal local UI sync after it returns.
    try {
        try { window.logDebug && window.logDebug('saveCashAsset: Delegating to AppService.saveCashAsset'); } catch(_) {}
        await window.AppService.saveCashAsset(isSilent);

        // Sync local selected ID/state from AppService (AppService sets window.selectedCashAssetDocId)
        try { selectedCashAssetDocId = window.selectedCashAssetDocId; } catch(_) {}
        try { originalCashAssetData = getCurrentCashAssetFormData(); } catch(_) { originalCashAssetData = null; }
        try { setIconDisabled(saveCashAssetBtn, true); } catch(_) {}
    } catch (error) {
        console.error('saveCashAsset: Delegated save failed:', error);
        if (!isSilent) {
            try { window.showCustomAlert && window.showCustomAlert('Error saving cash asset: ' + (error && error.message ? error.message : 'Unknown error')); } catch(_) {}
        }
    } finally {
        try { window.__modalSaveInProgress = false; } catch(_) { window.__modalSaveInProgress = false; }
        try { checkCashAssetFormDirtyState(); } catch(_) {}
    }
}

// NEW: Cash Asset Details Modal Functions (2.2)
function showCashCategoryDetailsModal(assetId) {
    if (!assetId) {
        showCustomAlert('Please select a cash asset to view details.');
        return;
    }
    const asset = userCashCategories.find(a => a.id === assetId);
    if (!asset) {
        showCustomAlert('Selected cash asset not found.');
        return;
    }
    selectedCashAssetDocId = assetId; // Set for potential edit/delete from details modal

    modalCashAssetName.textContent = asset.name || 'N/A';
    detailCashAssetName.textContent = asset.name || 'N/A';
    detailCashAssetBalance.textContent = formatMoney((Number(asset.balance) !== null && !isNaN(Number(asset.balance)) ? Number(asset.balance) : 0));
    detailCashAssetLastUpdated.textContent = formatDate(asset.lastUpdated) || 'N/A';

    // Display comments in details modal
    if (modalCashAssetCommentsContainer) {
        modalCashAssetCommentsContainer.innerHTML = ''; // Clear existing content
        if (asset.comments && Array.isArray(asset.comments) && asset.comments.length > 0) {
            asset.comments.forEach(comment => {
                if (comment.title || comment.text) {
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'modal-comment-item';
                    
                    if (comment.title && comment.title.trim() !== '') {
                        const titleBar = document.createElement('div');
                        titleBar.classList.add('comment-title-bar');
                        titleBar.textContent = comment.title;
                        commentDiv.appendChild(titleBar);
                    }
                    
                    const commentTextP = document.createElement('p');
                    commentTextP.textContent = comment.text || '';
                    commentDiv.appendChild(commentTextP);

                    modalCashAssetCommentsContainer.appendChild(commentDiv);
                }
            });
        } else {
            modalCashAssetCommentsContainer.innerHTML = '<p style="text-align: center; color: var(--label-color);">No comments for this asset.</p>';
        }
    }

    showModal(cashAssetDetailModal);
    try { scrollMainToTop(); } catch(_) {}
    logDebug('Details: Displayed details for cash asset: ' + asset.name + ' (ID: ' + assetId + ')');
}
// (Removed legacy modal-based showCustomConfirm; migrated to toast confirm above)

/**
 * Updates the main title of the app based on the currently selected watchlist.
 */
function updateMainTitle(overrideTitle) {
    // Explicit override path (e.g., when entering virtual Movers view)
    if (overrideTitle && typeof overrideTitle === 'string') {
        try { ensureTitleStructure(); } catch(_) {}
        if (dynamicWatchlistTitleText) dynamicWatchlistTitleText.textContent = overrideTitle; else if (dynamicWatchlistTitle) dynamicWatchlistTitle.textContent = overrideTitle;
        logDebug('UI: Dynamic title force-overridden to: ' + overrideTitle);
        // If overriding to Movers, persist selection cross-device
        if (overrideTitle === 'Movers') {
            try { setLastSelectedView('__movers'); } catch(_) {}
        }
        return;
    }

    const activeId = getCurrentSelectedWatchlistIds() && getCurrentSelectedWatchlistIds()[0];

    // Ensure an ephemeral Movers option exists if Movers is active but missing from select (prevents fallback to generic label)
    function ensureEphemeralMoversOption(){
        if (!watchlistSelect) return;
        const existing = watchlistSelect.querySelector('option[value="__movers"]');
        if (activeId === '__movers') {
            if (!existing) {
                const opt = document.createElement('option');
                opt.value='__movers'; opt.textContent='Movers'; opt.dataset.ephemeral='1';
                // Insert after All Shares if present
                const allOpt = watchlistSelect.querySelector('option[value="'+ALL_SHARES_ID+'"]');
                if (allOpt && allOpt.nextSibling) allOpt.parentNode.insertBefore(opt, allOpt.nextSibling); else watchlistSelect.appendChild(opt);
                logDebug('UI: Injected ephemeral Movers option into select.');
            }
        } else if (existing && existing.dataset.ephemeral==='1') {
            existing.remove();
            logDebug('UI: Removed ephemeral Movers option (inactive).');
        }
    }
    ensureEphemeralMoversOption();

    // If no select yet, derive directly from activeId
    if (!watchlistSelect) {
        let text = 'Share Watchlist';
        if (activeId === ALL_SHARES_ID) text = 'All Shares';
        else if (activeId === CASH_BANK_WATCHLIST_ID) text = 'Cash & Assets';
        else if (activeId === 'portfolio') text = 'Portfolio';
        else if (activeId === '__movers') text = 'Movers';
        else if (activeId) {
            const wl = (userWatchlists||[]).find(w=>w.id===activeId); if (wl) text = wl.name;
        }
        try { ensureTitleStructure(); } catch(_) {}
        if (dynamicWatchlistTitleText) dynamicWatchlistTitleText.textContent = text; else if (dynamicWatchlistTitle) dynamicWatchlistTitle.textContent = text;
        logDebug('UI: Dynamic title updated (no select) to: ' + text);
        return;
    }

    const selValue = watchlistSelect.value;
    const selTextRaw = watchlistSelect.selectedIndex >=0 ? (watchlistSelect.options[watchlistSelect.selectedIndex]?.textContent || '') : '';
    let resolved;
    if (activeId === ALL_SHARES_ID) resolved = 'All Shares';
    else if (activeId === CASH_BANK_WATCHLIST_ID) resolved = 'Cash & Assets';
    else if (activeId === 'portfolio') resolved = 'Portfolio';
    else if (activeId === '__movers') resolved = 'Movers';
    else {
        const wl = (userWatchlists||[]).find(w=>w.id===activeId);
        resolved = (wl && wl.name) ? wl.name : 'Share Watchlist';
    }

    try { ensureTitleStructure(); } catch(_) {}
    if (dynamicWatchlistTitleText) dynamicWatchlistTitleText.textContent = resolved; else if (dynamicWatchlistTitle) dynamicWatchlistTitle.textContent = resolved;
    // Defensive: avoid blank
    try { if (dynamicWatchlistTitleText && !dynamicWatchlistTitleText.textContent.trim()) dynamicWatchlistTitleText.textContent = resolved || 'Share Watchlist'; } catch(_) {}
    logDebug('UI: Dynamic title updated to: ' + resolved + ' (activeId=' + activeId + ')');
    // Persist resolved selection if it maps to a concrete logical view (avoid noisy writes during early boot with undefined)
    if (resolved === 'Movers') { try { setLastSelectedView('__movers'); } catch(_) {} }
    else if (resolved === 'Portfolio') { try { setLastSelectedView('portfolio'); } catch(_) {} }
    else if (resolved === 'All Shares') { try { setLastSelectedView(ALL_SHARES_ID); } catch(_) {} }
    else if (activeId && activeId !== '__movers' && activeId !== 'portfolio' && activeId !== ALL_SHARES_ID && activeId !== CASH_BANK_WATCHLIST_ID) {
        // Persist actual watchlist id
        try { setLastSelectedView(activeId); } catch(_) {}
    }
}

// Ensure the dynamic title uses a narrow clickable span and not the whole header
function ensureTitleStructure() {
    const titleEl = document.getElementById('dynamicWatchlistTitle');
    if (!titleEl) return;
    let textEl = document.getElementById('dynamicWatchlistTitleText');
    if (!textEl) {
        // Create the inner span and move any existing text into it
        textEl = document.createElement('span');
        textEl.id = 'dynamicWatchlistTitleText';
        textEl.tabIndex = 0;
        textEl.textContent = titleEl.textContent && titleEl.textContent.trim() ? titleEl.textContent.trim() : 'Share Watchlist';
        // Clear and append
        while (titleEl.firstChild) titleEl.removeChild(titleEl.firstChild);
        titleEl.appendChild(textEl);
    }
    // Constrain click target: disable container pointer events, allow only span
    try {
        titleEl.style.pointerEvents = 'none';
        textEl.style.pointerEvents = 'auto';
        textEl.setAttribute('role','button');
    } catch(e) {}
}

/**
 * Updates the behavior of the main header's plus button and sidebar's "Add New Share" button
 * based on the selected watchlist.
 * If 'Cash & Assets' is selected, they open the cash asset form. Otherwise, they open the share form.
 */
function updateAddHeaderButton() {
    logDebug('DEBUG: updateAddHeaderButton called. Current selected watchlist IDs: ' + getCurrentSelectedWatchlistIds().join(', '));
    if (!addShareHeaderBtn) {
        console.warn('updateAddHeaderButton: addShareHeaderBtn not found.');
        return;
    }

    // Remove existing event listeners from header button to prevent multiple bindings
    addShareHeaderBtn.removeEventListener('click', handleAddShareClick);
    addShareHeaderBtn.removeEventListener('click', handleAddCashAssetClick);

    // Set the appropriate event listener for the header button
    if (getCurrentSelectedWatchlistIds().includes(CASH_BANK_WATCHLIST_ID)) {
        addShareHeaderBtn.addEventListener('click', handleAddCashAssetClick);
        logDebug('DEBUG: Header Plus Button (addShareHeaderBtn) now opens Add Cash Asset modal.');
    } else {
        addShareHeaderBtn.addEventListener('click', handleAddShareClick);
        logDebug('DEBUG: Header Plus Button (addShareHeaderBtn) now opens Add Share modal.');
    }
    // Ensure the button is enabled as its functionality is now contextual
    addShareHeaderBtn.disabled = false; 

    // Also update the sidebar's "Add New Share" button context
    updateSidebarAddButtonContext();
}

/**
 * Handles click for adding a new share.
 */
function handleAddShareClick() {
    logDebug('UI: Add Share button clicked (contextual).');
    clearForm();
    // Reset accordion state - only Core Info section should be open for new shares
    initShareFormAccordion(true);
    formTitle.textContent = 'Add New Share';
    userManuallyOverrodeDirection = false;
    try {
        if (targetIntentBuyBtn && targetIntentSellBtn) {
            targetIntentBuyBtn.classList.add('is-active');
            targetIntentBuyBtn.setAttribute('aria-pressed', 'true');
            targetIntentSellBtn.classList.remove('is-active');
            targetIntentSellBtn.setAttribute('aria-pressed', 'false');
        }
        if (targetAboveCheckbox && targetBelowCheckbox) {
            targetAboveCheckbox.checked = false;
            targetBelowCheckbox.checked = true;
        }
        if (targetDirAboveBtn && targetDirBelowBtn) {
            targetDirAboveBtn.classList.remove('is-active');
            targetDirAboveBtn.setAttribute('aria-pressed', 'false');
            targetDirBelowBtn.classList.add('is-active');
            targetDirBelowBtn.setAttribute('aria-pressed', 'true');
        }
    } catch(_) {}
    if (deleteShareBtn) { deleteShareBtn.classList.add('hidden'); }
    populateShareWatchlistSelect(null, true); // true indicates new share
    showModal(shareFormSection);
    // Ensure accordion is properly initialized after modal is shown
    setTimeout(() => initShareFormAccordion(true), 10);
    try { scrollMainToTop(); } catch(_) {}
    shareNameInput.focus();
    // Always show live price snapshot if code is present
    if (shareNameInput && shareNameInput.value.trim()) {
        updateAddFormLiveSnapshot(shareNameInput.value.trim());
    } else if (addShareLivePriceDisplay) {
        addShareLivePriceDisplay.style.display = 'none';
        addShareLivePriceDisplay.innerHTML = '';
    }
    addCommentSection(commentsFormContainer); // Add an initial empty comment section for new shares
    checkFormDirtyState(); // Check dirty state immediately after opening for new share

    // Pre-populate entry price and entry date displays for new shares
    if (!selectedShareDocId) {
        console.log('[MODAL INIT] Pre-populating entry data displays for new share');

        // Set current date in entry date display
        if (autoEntryDateDisplay) {
            const now = new Date();
            const dateString = formatDate(now.toISOString());
            autoEntryDateDisplay.textContent = dateString;
            autoEntryDateDisplay.classList.remove('ghosted-text');
            console.log('[MODAL INIT] Set entry date display to:', dateString);
        }

        // Function to update entry price when live price becomes available
        const updateEntryPriceDisplay = () => {
            const currentPriceInput = document.getElementById('currentPrice');

            if (currentPriceInput && currentPriceInput.value && autoReferencePriceDisplay) {
                const currentPrice = parseFloat(currentPriceInput.value);
                if (!isNaN(currentPrice) && currentPrice > 0) {
                    autoReferencePriceDisplay.textContent = formatMoney(currentPrice);
                    autoReferencePriceDisplay.classList.remove('ghosted-text');
                    console.log('[MODAL INIT] Auto-populated entry price display to:', formatMoney(currentPrice));
                }
            }
        };

        // Set up a mutation observer to watch for live price changes
        const currentPriceInput = document.getElementById('currentPrice');
        if (currentPriceInput) {
            const observer = new MutationObserver(updateEntryPriceDisplay);
            observer.observe(currentPriceInput, { attributes: true, attributeFilter: ['value'] });

            // Also update immediately and after a short delay
            setTimeout(updateEntryPriceDisplay, 100);
            setTimeout(updateEntryPriceDisplay, 500);
            setTimeout(updateEntryPriceDisplay, 1000);
        }

        console.log('[MODAL INIT] Entry data displays populated');
    }
}

/**
 * Handles click for adding a new cash asset.
 */
function handleAddCashAssetClick() {
    logDebug('UI: Add Cash Asset button clicked (contextual).');
    // Ensure this specific handleAddCashAssetClick (the standalone one) calls addCashCategoryUI correctly.
    // The previous instructions already ensured addCashCategoryUI calls showAddEditCashCategoryModal(null).
    addCashCategoryUI();
}

/**
 * Updates the sidebar's "Add New Share" button to be contextual.
 * It will open the Share Form or Cash Asset Form based on the selected watchlist.
 */
function updateSidebarAddButtonContext() {
    logDebug('DEBUG: updateSidebarAddButtonContext called. Current selected watchlist IDs: ' + getCurrentSelectedWatchlistIds().join(', '));
    if (!newShareBtn) {
        console.warn('updateSidebarAddButtonContext: newShareBtn not found.');
        return;
    }

    // Remove existing event listeners from sidebar button
    newShareBtn.removeEventListener('click', handleAddShareClick);
    newShareBtn.removeEventListener('click', handleAddCashAssetClick);

    // Set the appropriate event listener for the sidebar button
    if (getCurrentSelectedWatchlistIds().includes(CASH_BANK_WATCHLIST_ID)) {
        newShareBtn.addEventListener('click', handleAddCashAssetClick);
        // Update the text/icon if needed (optional, but good for clarity)
        const sidebarSpan = newShareBtn.querySelector('span');
        const sidebarIcon = newShareBtn.querySelector('i');
        if (sidebarSpan) sidebarSpan.textContent = 'Add New Cash Asset';
        if (sidebarIcon) sidebarIcon.className = 'fas fa-money-bill-wave'; // Example icon change
        logDebug('DEBUG: Sidebar "Add New Share" button (newShareBtn) now opens Add Cash Asset modal.');
    } else {
        newShareBtn.addEventListener('click', handleAddShareClick);
        // Revert text/icon to original for stock view
        const sidebarSpan = newShareBtn.querySelector('span');
        const sidebarIcon = newShareBtn.querySelector('i');
        if (sidebarSpan) sidebarSpan.textContent = 'Add New Share';
        if (sidebarIcon) sidebarIcon.className = 'fas fa-plus-circle'; // Original icon
        logDebug('DEBUG: Sidebar "Add New Share" button (newShareBtn) now opens Add Share modal.');
    }
}

async function migrateOldSharesToWatchlist() {
    if (!db || !currentUserId || !firestore) {
        console.warn('Migration: Firestore DB, User ID, or Firestore functions not available for migration.');
        return false;
    }
    const sharesCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/shares');
    const q = firestore.query(sharesCol);
    let sharesToUpdate = [];
    let anyMigrationPerformed = false;
    try {
        logDebug('Migration: Checking for old shares to migrate/update schema and data types.');
        const querySnapshot = await firestore.getDocs(q);
        querySnapshot.forEach(doc => {
            const shareData = doc.data();
            let updatePayload = {};
            let needsUpdate = false;
            if (!shareData.hasOwnProperty('watchlistId')) {
                needsUpdate = true;
                updatePayload.watchlistId = getDefaultWatchlistId(currentUserId);
                logDebug('Migration: Share \'' + doc.id + '\' missing watchlistId. Assigning to default.');
            }
            if ((!shareData.shareName || String(shareData.shareName).trim() === '') && shareData.hasOwnProperty('name') && String(shareData.name).trim() !== '') {
                needsUpdate = true;
                updatePayload.shareName = String(shareData.name).trim();
                updatePayload.name = firestore.deleteField();
                logDebug('Migration: Share \'' + doc.id + '\' missing \'shareName\' but has \'name\' (\'' + shareData.name + '\'). Migrating \'name\' to \'shareName\'.');
            }
            const fieldsToConvert = ['currentPrice', 'targetPrice', 'dividendAmount', 'frankingCredits', 'entryPrice', 'lastFetchedPrice', 'previousFetchedPrice'];
            fieldsToConvert.forEach(field => {
                const value = shareData[field];
                const originalValueType = typeof value;
                let parsedValue = value;
                if (originalValueType === 'string' && value.trim() !== '') {
                    parsedValue = parseFloat(value);
                    if (!isNaN(parsedValue)) {
                        if (originalValueType !== typeof parsedValue || value !== String(parsedValue)) {
                            needsUpdate = true;
                            updatePayload[field] = parsedValue;
                            logDebug('Migration: Share \'' + doc.id + '\': Converted ' + field + ' from string \'' + value + '\' (type ' + originalValueType + ') to number ' + parsedValue + '.');
                        }
                    } else {
                        needsUpdate = true;
                        updatePayload[field] = null;
                        console.warn('Migration: Share \'' + doc.id + '\': Field \'' + field + '\' was invalid string \'' + value + '\', setting to null.');
                    }
                } else if (originalValueType === 'number' && isNaN(value)) {
                    needsUpdate = true;
                    updatePayload[field] = null;
                    console.warn('Migration: Share \'' + doc.id + '\': Field \'' + field + '\' was NaN number, setting to null.');
                }
                if (field === 'frankingCredits' && typeof parsedValue === 'number' && !isNaN(parsedValue)) {
                    if (parsedValue > 0 && parsedValue < 1) {
                        needsUpdate = true;
                        updatePayload.frankingCredits = parsedValue * 100;
                        logDebug('Migration: Share \'' + doc.id + '\': Converted frankingCredits from decimal ' + parsedValue + ' to percentage ' + (parsedValue * 100) + '.');
                    }
                }
            });
            const effectiveCurrentPrice = (typeof updatePayload.currentPrice === 'number' && !isNaN(updatePayload.currentPrice)) ? updatePayload.currentPrice :
                                           ((typeof shareData.currentPrice === 'string' ? parseFloat(shareData.currentPrice) : shareData.currentPrice) || null);
            if (!shareData.hasOwnProperty('lastFetchedPrice') || (typeof shareData.lastFetchedPrice === 'string' && isNaN(parseFloat(shareData.lastFetchedPrice)))) {
                needsUpdate = true;
                updatePayload.lastFetchedPrice = effectiveCurrentPrice;
                logDebug('Migration: Share \'' + doc.id + '\': Setting missing lastFetchedPrice to ' + effectiveCurrentPrice + '.');
            }
            if (!shareData.hasOwnProperty('previousFetchedPrice') || (typeof shareData.previousFetchedPrice === 'string' && isNaN(parseFloat(shareData.previousFetchedPrice)))) {
                needsUpdate = true;
                updatePayload.previousFetchedPrice = effectiveCurrentPrice;
                logDebug('Migration: Share \'' + doc.id + '\': Setting missing previousFetchedPrice to ' + effectiveCurrentPrice + '.');
            }
            if (!shareData.hasOwnProperty('lastPriceUpdateTime')) {
                needsUpdate = true;
                updatePayload.lastPriceUpdateTime = new Date().toISOString();
                logDebug('Migration: Share \'' + doc.id + '\': Setting missing lastPriceUpdateTime.');
            }
            if (needsUpdate) { sharesToUpdate.push({ ref: doc.ref, data: updatePayload }); }
        });
        if (sharesToUpdate.length > 0) {
            logDebug('Migration: Performing consolidated update for ' + sharesToUpdate.length + ' shares.');
            for (const item of sharesToUpdate) { await firestore.updateDoc(item.ref, item.data); }
            showCustomAlert('Migrated/Updated ' + sharesToUpdate.length + ' old shares.', 2000);
            logDebug('Migration: Migration complete. Setting up shares listener.');
            // No need to call loadShares here, the onSnapshot listener will handle updates automatically
            anyMigrationPerformed = true;
        } else {
            logDebug('Migration: No old shares found requiring migration or schema update.');
        }
        return anyMigrationPerformed;
    } catch (error) {
        console.error('Migration: Error during data migration: ' + error.message);
        showCustomAlert('Error during data migration: ' + error.message);
        // NEW: Hide splash screen on error
        hideSplashScreen();
        return false;
    }
}
function showContextMenu(event, shareId) {
    if (!shareContextMenu) return;
    
    currentContextMenuShareId = shareId;
    
    let x = event.clientX;
    let y = event.clientY;

    if (event.touches && event.touches.length > 0) {
        x = event.touches[0].clientX;
        y = event.touches[0].clientY;
    }

    const menuWidth = shareContextMenu.offsetWidth;
    const menuHeight = shareContextMenu.offsetHeight;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    if (x + menuWidth > viewportWidth) {
        x = viewportWidth - menuWidth - 10;
    }
    if (y + menuHeight > viewportHeight) {
        y = viewportHeight - menuHeight - 10;
    }
    if (x < 10) x = 10;
    if (y < 10) y = 10;

    shareContextMenu.style.left = `${x}px`;
    shareContextMenu.style.top = `${y}px`;
    shareContextMenu.style.display = 'block';
    contextMenuOpen = true;
    logDebug('Context Menu: Opened for share ID: ' + shareId + ' at (' + x + ', ' + y + ')');
}

function hideContextMenu() {
    if (shareContextMenu) {
        shareContextMenu.style.display = 'none';
        contextMenuOpen = false;
        currentContextMenuShareId = null;
        deselectCurrentShare();
        logDebug('Context Menu: Hidden.');
    }
}

function toggleAppSidebar(forceState = null) {
    // Delegate to UI module if present
    if (window.UI && typeof window.UI.toggleAppSidebar === 'function') {
        const wasOpen = appSidebar && appSidebar.classList.contains('open');
        const result = window.UI.toggleAppSidebar(forceState);
        const isOpen = appSidebar && appSidebar.classList.contains('open');
        if (!wasOpen && isOpen) { try { if (typeof pushAppState === 'function') pushAppState({ sidebarOpen: true }, '', '#sidebar'); } catch(_){} }
        return result;
    }

    // Minimal fallback behavior if UI module absent
    try {
        const isDesktop = window.innerWidth > 768;
        const isOpen = appSidebar && appSidebar.classList.contains('open');
        if (forceState === true || (forceState === null && !isOpen)) {
            try { if (typeof pushAppState === 'function') pushAppState({ sidebarOpen: true }, '', '#sidebar'); } catch(_){}
            document.body.style.overflow = 'hidden';
            if (appSidebar) appSidebar.classList.add('open');
            if (sidebarOverlay) sidebarOverlay.classList.add('open');
            if (isDesktop) document.body.classList.add('sidebar-active');
            if (hamburgerBtn) hamburgerBtn.setAttribute('aria-expanded', 'true');
        } else {
            if (appSidebar) appSidebar.classList.remove('open');
            if (sidebarOverlay) sidebarOverlay.classList.remove('open');
            document.body.classList.remove('sidebar-active');
            document.body.style.overflow = '';
            if (hamburgerBtn) hamburgerBtn.setAttribute('aria-expanded', 'false');
        }
    } catch (e) { console.warn('toggleAppSidebar fallback failed', e); }
}

/**
 * Escapes a string for CSV by enclosing it in double quotes and doubling any existing double quotes.
 * @param {any} value The value to escape.
 * @returns {string} The CSV-escaped string.
 */

/**
 * Exports the current watchlist data to a CSV file.
 */
function exportWatchlistToCSV() {
    if (!currentUserId || getCurrentSelectedWatchlistIds().length === 0) {
        showCustomAlert('Please sign in and select watchlists to export.');
        return;
    }
    
    // Do not export cash data via this function
    if (getCurrentSelectedWatchlistIds().includes(CASH_BANK_WATCHLIST_ID)) {
        showCustomAlert('Cash & Assets data cannot be exported via this function. Please switch to a stock watchlist.', 3000); // UPDATED TEXT
        return;
    }

    let sharesToExport = [];
    let exportFileNamePrefix = 'selected_watchlists';

    if (getCurrentSelectedWatchlistIds().length === 1) {
        const selectedWatchlistId = getCurrentSelectedWatchlistIds()[0];
        if (selectedWatchlistId === ALL_SHARES_ID) {
            sharesToExport = [...allSharesData];
            exportFileNamePrefix = 'all_shares';
        } else {
            sharesToExport = allSharesData.filter(share => shareBelongsTo(share, selectedWatchlistId));
            const wl = userWatchlists.find(w => w.id === selectedWatchlistId);
            if (wl) { exportFileNamePrefix = wl.name; }
        }
    } else {
        // If multiple stock watchlists are selected, export all shares
        sharesToExport = [...allSharesData];
        exportFileNamePrefix = 'all_shares';
    }

    if (sharesToExport.length === 0) {
        showCustomAlert('No shares in the current selection to export.', 2000);
        return;
    }

    const headers = [
        'Code', 'Entered Price', 'Live Price', 'Price Change', 'Alert Target', 'Dividend Amount', 'Franking Credits (%)',
        'Unfranked Yield (%)', 'Franked Yield (%)', 'Entry Date'
    ];

    const csvRows = [];
    csvRows.push(headers.map(escapeCsvValue).join(','));

    sharesToExport.forEach(share => {
        const enteredPriceNum = Number(share.entryPrice || share.currentPrice);
        const dividendAmountNum = Number(share.dividendAmount);
        const frankingCreditsNum = Number(share.frankingCredits);
        const targetPriceNum = Number(share.targetPrice);

        // Get live price data from the global livePrices object
        const livePriceData = livePrices[share.shareName.toUpperCase()];
        const livePrice = livePriceData ? livePriceData.live : undefined;
        const prevClosePrice = livePriceData ? livePriceData.prevClose : undefined;

        let priceChange = '';
        if (livePrice !== undefined && livePrice !== null && !isNaN(livePrice) && 
            prevClosePrice !== undefined && prevClosePrice !== null && !isNaN(prevClosePrice)) {
            const change = livePrice - prevClosePrice;
            const percentageChange = (prevClosePrice !== 0 && !isNaN(prevClosePrice)) ? (change / prevClosePrice) * 100 : 0;
            priceChange = formatDailyChange(change, percentageChange); // Use centralized format for CSV too
        }

        const priceForYield = (livePrice !== undefined && livePrice !== null && !isNaN(livePrice)) ? livePrice : enteredPriceNum;

        const unfrankedYield = calculateUnfrankedYield(dividendAmountNum, priceForYield);
        const frankedYield = calculateFrankedYield(dividendAmountNum, priceForYield, frankingCreditsNum);

        const row = [
            share.shareName || '',
            (!isNaN(enteredPriceNum) && enteredPriceNum !== null) ? formatAdaptivePrice(enteredPriceNum) : '',
            (livePrice !== undefined && livePrice !== null && !isNaN(livePrice)) ? formatAdaptivePrice(livePrice) : '',
            priceChange, // Now includes the calculated price change
            (!isNaN(targetPriceNum) && targetPriceNum !== null) ? formatAdaptivePrice(targetPriceNum) : '',
            (!isNaN(dividendAmountNum) && dividendAmountNum !== null) ? dividendAmountNum.toFixed( (String(share.dividendAmount||'').match(/\.\d{3,}$/) ? 3 : 2) ) : '',
            (!isNaN(frankingCreditsNum) && frankingCreditsNum !== null) ? Math.trunc(frankingCreditsNum).toString() : '',
            unfrankedYield !== null && !isNaN(unfrankedYield) ? formatAdaptivePercent(unfrankedYield) : '0.00', // Ensure numerical output
            frankedYield !== null && !isNaN(frankedYield) ? formatAdaptivePercent(frankedYield) : '0.00', // Ensure numerical output
            formatDate(share.entryDate) || ''
        ];
        csvRows.push(row.map(escapeCsvValue).join(','));
    });

    const csvString = csvRows.join('\n');
    const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    
    const formattedDate = new Date().toISOString().slice(0, 10);
    const safeFileNamePrefix = exportFileNamePrefix.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    link.download = safeFileNamePrefix + '_watchlist_' + formattedDate + '.csv';
    
    link.href = URL.createObjectURL(blob);
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
    
    showCustomAlert('Exported shares to CSV!', 2000);
    logDebug('Export: Shares exported to CSV with prefix: \'' + exportFileNamePrefix + '\'.');
}

/**
 * Gathers current data from the Add/Manage Watchlist form inputs.
 * @param {boolean} isAddModal True if gathering data from the Add Watchlist modal, false for Manage Watchlist.
 * @returns {object} An object representing the current state of the watchlist form.
 */
function getCurrentWatchlistFormData(isAddModal) {
    if (isAddModal) {
        return {
            name: newWatchlistNameInput ? newWatchlistNameInput.value.trim() : ''
        };
    } else {
        return {
            name: editWatchlistNameInput ? editWatchlistNameInput.value.trim() : ''
        };
    }
}

/**
 * Compares two watchlist data objects to check for equality.
 * @param {object} data1
 * @param {object} data2
 * @returns {boolean} True if data is identical, false otherwise.
 */
function areWatchlistDataEqual(data1, data2) {
    if (!data1 || !data2) return false;
    return data1.name === data2.name;
}

/**
 * Checks the current state of the watchlist form against the original data (if editing)
 * and enables/disables the save button accordingly.
 * @param {boolean} isAddModal True if checking the Add Watchlist modal, false for Manage Watchlist.
 */
function checkWatchlistFormDirtyState(isAddModal) {
    const currentData = getCurrentWatchlistFormData(isAddModal);
    const isNameValid = currentData.name.trim() !== '';
    let canSave = isNameValid;

    if (!isAddModal && originalWatchlistData) { // Only for editing existing watchlists
        const isDirty = !areWatchlistDataEqual(originalWatchlistData, currentData);
        canSave = canSave && isDirty;
        if (!isDirty) {
            logDebug('Dirty State: Existing watchlist: No changes detected, save disabled.');
        }
    } else if (isAddModal) {
        // For new watchlists, enable if name is valid
    }

    const targetSaveBtn = isAddModal ? saveWatchlistBtn : saveWatchlistNameBtn;
    setIconDisabled(targetSaveBtn, !canSave);
    logDebug('Dirty State: Watchlist save button enabled: ' + canSave + ' (Modal: ' + (isAddModal ? 'Add' : 'Edit') + ')');
}

/**
 * Saves or updates watchlist data to Firestore. Can be called silently for auto-save.
 * @param {boolean} isSilent If true, no alert messages are shown on success.
 * @param {string} newName The new name for the watchlist.
 * @param {string|null} watchlistId The ID of the watchlist to update, or null if adding new.
 */
async function saveWatchlistChanges(isSilent = false, newName, watchlistId = null) {
    logDebug('Watchlist Form: saveWatchlistChanges called.');

    if (!newName || newName.trim() === '') {
        if (!isSilent) showCustomAlert('Watchlist name is required!');
        console.warn('Save Watchlist: Watchlist name is empty. Skipping save.');
        return;
    }

    // Check for duplicate name (case-insensitive, excluding current watchlist if editing)
    console.log('[DUPLICATE CHECK] Checking for watchlist name:', newName);
    console.log('[DUPLICATE CHECK] Current userWatchlists count:', userWatchlists.length);
    console.log('[DUPLICATE CHECK] Current userWatchlists:', userWatchlists.map(w => ({ id: w.id, name: w.name })));

    const isDuplicate = userWatchlists.some(w => {
        const isMatch = w.name.toLowerCase() === newName.toLowerCase() && w.id !== watchlistId;
        if (isMatch) {
            console.log('[DUPLICATE CHECK] Found duplicate:', w.name, '(ID:', w.id, ')');
        }
        return isMatch;
    });

    if (isDuplicate) {
        console.warn('[DUPLICATE CHECK] Duplicate watchlist name detected, skipping save');
        if (!isSilent) {
            const message = `A watchlist named "${newName}" already exists. Please choose a different name.`;
            try {
                showCustomAlert(message, 3000, 'warning');
            } catch (error) {
                console.error('[DUPLICATE CHECK] Error showing alert:', error);
                alert(message);
            }
        }
        return; // Exit the function if it's a duplicate
    }

    console.log('[DUPLICATE CHECK] No duplicate found, proceeding with save');

    try {
        if (watchlistId) { // Editing existing watchlist
            const watchlistDocRef = firestore.doc(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/watchlists', watchlistId);
            await firestore.updateDoc(watchlistDocRef, { name: newName });
            if (!isSilent) showCustomAlert('Watchlist renamed to \'' + newName + '\'!', 1500);
            // --- IMPORTANT FIX: Reload all settings to refresh UI after renaming ---
            await loadUserWatchlistsAndSettings();
                        // Load Firestore-backed UI preferences (compact view etc.)
                        await loadUserPreferences();
                // Bootstrap defaults if empty
                if (Object.keys(userPreferences||{}).length === 0) {
                    if (DEBUG_MODE) console.log('[Prefs] Bootstrapping default preferences');
                    try { await persistUserPreference('compactViewMode', localStorage.getItem('currentMobileViewMode') || currentMobileViewMode); } catch(_) {}
                }
            // --- END IMPORTANT FIX ---
            logDebug('Firestore: Watchlist (ID: ' + watchlistId + ') renamed to \'' + newName + '\'.');
        } else { // Adding new watchlist
            const watchlistsColRef = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/watchlists');
            const newDocRef = await firestore.addDoc(watchlistsColRef, {
                name: newName,
                createdAt: new Date().toISOString(),
                userId: currentUserId
            });
            if (!isSilent) showCustomAlert('Watchlist \'' + newName + '\' added!', 1500);
            logDebug('Firestore: Watchlist \'' + newName + '\' added with ID: ' + newDocRef.id);

            // Set the newly created watchlist as the current selection and save this preference.
            setCurrentSelectedWatchlistIds([newDocRef.id]);
            await saveLastSelectedWatchlistIds(currentSelectedWatchlistIds);

            // --- IMPORTANT FIX: Update in-memory userWatchlists array immediately if missing ---
            // Only add if not already present to avoid duplicates when loadUserWatchlistsAndSettings reloads from Firestore.
            try {
                if (!userWatchlists.some(w => w.id === newDocRef.id)) {
                    userWatchlists.push({ id: newDocRef.id, name: newName });
                } else {
                    logDebug('Save Watchlist: new watchlist already present in memory, skipping push to userWatchlists.');
                }
            } catch (e) { console.warn('Save Watchlist: Failed to update in-memory userWatchlists safely', e); }
            // Re-sort userWatchlists to ensure the new watchlist is in the correct order for the dropdown
            userWatchlists.sort((a, b) => {
                // Keep "Cash & Assets" at the bottom if it's there
                if (a.id === CASH_BANK_WATCHLIST_ID) return 1;
                if (b.id === CASH_BANK_WATCHLIST_ID) return -1;
                return a.name.localeCompare(b.name);
            });
            logDebug('Firestore: userWatchlists array updated in memory with new watchlist and re-sorted.');
            // --- END IMPORTANT FIX ---

            // Call loadUserWatchlistsAndSettings to fully refresh the watchlist data,
            // update the dropdown, and render the correct watchlist on the main screen.
            await loadUserWatchlistsAndSettings();

            // After loadUserWatchlistsAndSettings completes, ensure the newly created watchlist is selected
            // and navigate to it immediately
            try {
                console.log('[WATCHLIST NAV] Setting currentSelectedWatchlistIds to new watchlist:', newDocRef.id);
                setCurrentSelectedWatchlistIds([newDocRef.id]);
                
                // Update the dropdown selection
                if (watchlistSelect) {
                    watchlistSelect.value = newDocRef.id;
                    console.log('[WATCHLIST NAV] Set dropdown value to:', newDocRef.id);
                }
                
                // Save the selection to localStorage
                try {
                    localStorage.setItem('lastWatchlistSelection', JSON.stringify([newDocRef.id]));
                    localStorage.setItem('lastSelectedView', newDocRef.id);
                } catch (e) {
                    console.warn('[WATCHLIST NAV] Error saving to localStorage:', e);
                }
                
                // Render the watchlist immediately
                console.log('[WATCHLIST NAV] Rendering watchlist for new watchlist');
                if (typeof renderWatchlist === 'function') {
                    renderWatchlist();
                }
                
                // Update UI elements
                if (typeof updateMainTitle === 'function') {
                    updateMainTitle();
                }
                if (typeof updateAddHeaderButton === 'function') {
                    updateAddHeaderButton();
                }
                
            } catch (error) {
                console.error('[WATCHLIST NAV] Error navigating to new watchlist:', error);
            }
        }
        
        // This block now handles both new and edited watchlists.
        // loadUserWatchlistsAndSettings() is responsible for all subsequent UI updates.
        // The 'if (watchlistId)' condition around loadUserWatchlistsAndSettings is removed
        // because it needs to run for new watchlists too for consistent state management.

        if (!isSilent) closeModals(); // Only close if not a silent save
        originalWatchlistData = getCurrentWatchlistFormData(watchlistId === null); // Update original data after successful save
        checkWatchlistFormDirtyState(watchlistId === null); // Disable save button after saving
    } catch (error) {
        console.error('Firestore: Error saving watchlist:', error);
        if (!isSilent) showCustomAlert('Error saving watchlist: ' + error.message);
    }
}
/**
 * Deletes all user-specific data from Firestore for the current user.
 * This is a destructive and irreversible action.
 */
async function deleteAllUserData() {
    if (!db || !currentUserId || !firestore) {
        showCustomAlert('Firestore not available. Cannot delete data.');
        return;
    }

    showCustomConfirm('Are you absolutely sure you want to delete ALL your data? This action is irreversible and will permanently remove all shares, watchlists, cash assets, and settings associated with your account.', async (confirmed) => {
        if (!confirmed) {
            showCustomAlert('Data deletion cancelled.', 1000);
            return;
        }

        showCustomAlert('Deleting all data...', 999999); // Show persistent alert during deletion
        if (loadingIndicator) loadingIndicator.style.display = 'flex'; // Show loading spinner

        try {
            const collectionsToDelete = ['shares', 'watchlists', 'cashCategories'];
            const batch = firestore.writeBatch(db);

            // 1. Delete documents from collections
            for (const collectionName of collectionsToDelete) {
                const collectionRef = firestore.collection(db, `artifacts/${currentAppId}/users/${currentUserId}/${collectionName}`);
                const querySnapshot = await firestore.getDocs(firestore.query(collectionRef));
                querySnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });
                logDebug(`Firestore: Added ${querySnapshot.docs.length} documents from '${collectionName}' to batch for deletion.`);
            }

            // 2. Delete the user's profile/settings document (if it exists)
            const userProfileDocRef = firestore.doc(db, `artifacts/${currentAppId}/users/${currentUserId}/profile/settings`);
            const profileDocSnap = await firestore.getDoc(userProfileDocRef);
            if (profileDocSnap.exists()) {
                batch.delete(userProfileDocRef);
                logDebug('Firestore: Added user profile settings to batch for deletion.');
            }

            // Commit the batch
            await batch.commit();
            logDebug('Firestore: All user data batch committed successfully.');

            // 3. Sign out the user after data deletion
            if (auth && authFunctions) {
                await authFunctions.signOut(auth);
                showCustomAlert('All your data has been permanently deleted. You have been logged out.', 3000);
                logDebug('Auth: User signed out after data deletion.');
            } else {
                showCustomAlert('All your data has been permanently deleted. Please log out manually.', 3000);
                console.warn('Auth: Could not sign out user automatically after data deletion.');
            }

        } catch (error) {
            console.error('Firestore: Error deleting all user data:', error);
            showCustomAlert('Error deleting all data: ' + error.message, 3000);
        } finally {
            if (loadingIndicator) loadingIndicator.style.display = 'none';
            closeModals(); // Close any open modals
        }
    });
}

function restorePersistedState() {
    logDebug('State Management: Restoring persisted state from localStorage.');

    // Restore Compact View Mode using centralized manager
    const savedMobileViewMode = localStorage.getItem('currentMobileViewMode');
    if (savedMobileViewMode === 'compact' || savedMobileViewMode === 'default') {
        setMobileViewMode(savedMobileViewMode, 'restore_persisted_state');
        logDebug(`State Management: Restored mobile view mode using centralized manager: '${savedMobileViewMode}'.`);
    }

    // Restore Last Selected Watchlist/View
    const savedLastView = localStorage.getItem('lastSelectedView');
    if (savedLastView) {
        setCurrentSelectedWatchlistIds([savedLastView]);
        logDebug(`State Management: Restored last selected view to '${savedLastView}'.`);
    }

    // Restore Sort Order
    const savedSortOrder = localStorage.getItem('lastSortOrder');
    if (savedSortOrder) {
        setCurrentSortOrder(savedSortOrder);
        logDebug(`State Management: Restored sort order to '${currentSortOrder}'.`);
    }
}

async function initializeAppLogic() {
    // Note: View mode application is now handled by robust restoration
    // applyCompactViewMode(); // Disabled to prevent conflicts

    // Start global view mode enforcer as backup
    try {
        startGlobalViewModeEnforcer();
        startViewModeConsistencyChecker();
        logDebug('Init: View mode monitoring systems started');
    } catch (error) {
        console.warn('Init: Failed to start view mode monitoring:', error);
    }

    // DEBUG: Log when initializeAppLogic starts
    logDebug('initializeAppLogic: Firebase is ready. Starting app logic.');

    // Initial modal hiding
    if (shareFormSection) shareFormSection.style.setProperty('display', 'none', 'important');
    if (dividendCalculatorModal) dividendCalculatorModal.style.setProperty('display', 'none', 'important');
    if (shareDetailModal) shareDetailModal.style.setProperty('display', 'none', 'important');
    if (addWatchlistModal) addWatchlistModal.style.setProperty('display', 'none', 'important');
    if (manageWatchlistModal) manageWatchlistModal.style.setProperty('display', 'none', 'important');
    // customDialogModal removed
    if (calculatorModal) calculatorModal.style.setProperty('display', 'none', 'important');
    if (shareContextMenu) shareContextMenu.style.setProperty('display', 'none', 'important');
    if (targetHitIconBtn) targetHitIconBtn.style.display = 'none'; // Ensure icon is hidden initially via inline style
    if (alertPanel) alertPanel.style.display = 'none'; // NEW: Ensure alert panel is hidden initially
    // NEW: Hide cash asset modals initially
    if (cashAssetFormModal) cashAssetFormModal.style.setProperty('display', 'none', 'important');
    if (cashAssetDetailModal) cashAssetDetailModal.style.setProperty('display', 'none', 'important');
    if (stockSearchModal) {
        stockSearchModal.classList.remove('show'); // Ensure stock search modal is hidden on initialization
    }
    // The targetHitDetailsModal itself is hidden by showModal/hideModal, so no explicit line needed for its close button.


    // Service Worker Registration + Robust Auto-Update Flow
    if ('serviceWorker' in navigator) {
        let refreshing = false;
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (refreshing) return;
            refreshing = true;
            // Reload to get the new cached assets (CSS/JS)
            window.location.reload();
        });
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./service-worker.js', { scope: './' })
                .then(reg => {
                    logDebug('Service Worker: Registered with scope:', reg.scope);
                    // If there is an updated service worker waiting or installing, prompt it to activate
                    function promptUpdate(sw) {
                        if (!sw) return;
                        // Tell the new SW to skip waiting so it becomes active immediately
                        sw.postMessage({ type: 'SKIP_WAITING' });
                    }
                    if (reg.waiting) {
                        promptUpdate(reg.waiting);
                    }
                    if (reg.installing) {
                        reg.installing.addEventListener('statechange', () => {
                            if (reg.installing && reg.installing.state === 'installed') {
                                promptUpdate(reg.installing);
                            }
                        });
                    }
                    reg.addEventListener('updatefound', () => {
                        const newWorker = reg.installing;
                        if (!newWorker) return;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed') {
                                promptUpdate(newWorker);
                            }
                        });
                    });
                })
                .catch(error => {
                    console.error('Service Worker: Registration failed:', error);
                });
        });
    }

    // Removed version badge insertion for cleaner title bar.

    // (Removed mid-pipeline mobile view preference load; now handled early + during auth apply)


    // Share Name Input to uppercase + live suggestions
    if (shareNameInput) {
        let shareNameSelectedSuggestionIndex = -1;
        shareNameInput.addEventListener('input', function() {
            this.value = this.value.toUpperCase();
            checkFormDirtyState();

            if (!shareNameSuggestions) return;
            const query = this.value.trim();
            // Lazy-load ASX codes if not loaded yet
            if (allAsxCodes.length === 0 && typeof loadAsxCodesFromCSV === 'function') {
                loadAsxCodesFromCSV().then(codes => {
                    setAllAsxCodes(codes || []);
                    // Re-run rendering if user is still typing the same query
                    if (shareNameInput.value.trim() === query) {
                        renderShareNameSuggestions(query);
                    }
                }).catch(() => {/* ignore */});
            }
            shareNameSuggestions.innerHTML = '';
            shareNameSelectedSuggestionIndex = -1;

            if (query.length < 2) {
                shareNameSuggestions.classList.remove('active');
                // Clear company name if user deletes input
                if (formCompanyName) formCompanyName.textContent = '';
                return;
            }
            renderShareNameSuggestions(query);
        });

        // Keyboard navigation for shareName suggestions
        shareNameInput.addEventListener('keydown', (e) => {
            if (!shareNameSuggestions || !shareNameSuggestions.classList.contains('active')) return;
            const items = shareNameSuggestions.querySelectorAll('.suggestion-item');
            if (items.length === 0) return;
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                shareNameSelectedSuggestionIndex = (shareNameSelectedSuggestionIndex + 1) % items.length;
                updateShareNameSelectedSuggestion(items, shareNameSelectedSuggestionIndex);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                shareNameSelectedSuggestionIndex = (shareNameSelectedSuggestionIndex - 1 + items.length) % items.length;
                updateShareNameSelectedSuggestion(items, shareNameSelectedSuggestionIndex);
            } else if (e.key === 'Enter') {
                if (shareNameSelectedSuggestionIndex > -1) {
                    e.preventDefault();
                    const code = items[shareNameSelectedSuggestionIndex].dataset.code;
                    const match = allAsxCodes.find(s => s.code === code);
                    if (match) applyShareCodeSelection(match.code, match.name);
                } else if (shareNameInput.value.trim()) {
                    // If user pressed Enter without selecting, try to match the current value
                    const code = shareNameInput.value.trim().toUpperCase();
                    const match = allAsxCodes.find(s => s.code === code);
                    if (match) {
                        e.preventDefault();
                        applyShareCodeSelection(match.code, match.name);
                    }
                }
            } else if (e.key === 'Escape') {
                shareNameSuggestions.classList.remove('active');
            }
        });

        function updateShareNameSelectedSuggestion(items, idx) {
            items.forEach((el, i) => el.classList.toggle('selected', i === idx));
            if (idx > -1) {
                shareNameInput.value = items[idx].dataset.code;
            }
        }

        async function applyShareCodeSelection(code, name) {
                // Mark selection in progress to prevent blur handlers from hiding UI incorrectly
                try { window.__shareFormSelectionInProgress = true; } catch(_){}

                shareNameInput.value = code;
                if (formCompanyName) formCompanyName.textContent = name || '';
                if (shareNameSuggestions) shareNameSuggestions.classList.remove('active');

                // On touch devices, avoid forcing focus to the next input to prevent visualViewport/keyboard
                // changes that can cause mobile layout jumps (which were opening the "Other Details" accordion)
                const next = targetPriceInput;
                try {
                    if (!('ontouchstart' in window) && next) next.focus();
                } catch(_) {}

                checkFormDirtyState();

                // Temporarily suppress any passive auto-open behavior for the share form accordion
                try { window.__suppressShareFormAccordionOpen = true; } catch(_) {}

                // Fetch live snapshot for the selected code to show context in the form and prefill price
                try {
                    if (typeof window.updateAddFormLiveSnapshot === 'function') window.updateAddFormLiveSnapshot(code);
                    else if (typeof updateAddFormLiveSnapshot === 'function') updateAddFormLiveSnapshot(code);
                } catch (err) {
                    try { if (typeof updateAddFormLiveSnapshot === 'function') updateAddFormLiveSnapshot(code); } catch(_){ }
                }

                // Ensure the "Other Details" accordion section remains closed after selection (defensive)
                try {
                    const other = document.querySelector('#shareFormAccordion .accordion-section[data-section="other"]');
                    if (other) {
                        other.classList.remove('open');
                        const toggleBtn = other.querySelector('.accordion-toggle');
                        if (toggleBtn) toggleBtn.setAttribute('aria-expanded', 'false');
                    }
                } catch(_){}

                // Clear suppression/selection flags shortly after to restore normal behavior
                setTimeout(() => {
                    try { delete window.__suppressShareFormAccordionOpen; } catch(_){}
                    try { delete window.__shareFormSelectionInProgress; } catch(_){}
                }, 400);
        }

        function renderShareNameSuggestions(query) {
            shareNameSuggestions.innerHTML = '';
            const matches = allAsxCodes
                .filter(s => s.code.includes(query) || s.name.toUpperCase().includes(query))
                .slice(0, 8);

            if (matches.length === 0) {
                shareNameSuggestions.classList.remove('active');
                return;
            }

            matches.forEach((s) => {
                const div = document.createElement('div');
                div.classList.add('suggestion-item');
                div.textContent = `${s.code} - ${s.name}`;
                div.dataset.code = s.code;
                // Use pointerup or click for selection to avoid blocking touch scroll; keep pointerdown passive
                const handler = (e) => {
                    // Mark that a selection is happening so blur handlers don't immediately hide suggestions
                    try { if (shareNameSuggestions) shareNameSuggestions.dataset.selectionInProgress = '1'; } catch(_){}
                    // Selection handler; do not call preventDefault here to allow scrolling on touch devices
                    applyShareCodeSelection(s.code, s.name);
                };
                // Use pointerdown to capture touch/click early, prevent blur-before-click issues
                div.addEventListener('pointerdown', function(e){
                    // prevent default to stop input blur race on some browsers
                    try { e.preventDefault(); } catch(_){}
                }, { passive: false });
                // pointerup triggers the selection
                div.addEventListener('pointerup', handler, { once: true });
                // click fallback for older browsers / devices
                div.addEventListener('click', handler, { once: true });
                shareNameSuggestions.appendChild(div);
            });
            shareNameSuggestions.classList.add('active');
        }

        // Keep a lightweight blur handler for clearing company name if field emptied
        shareNameInput.addEventListener('blur', () => {
            setTimeout(() => { // Delay to allow click selection to complete
                if (shareNameSuggestions && !shareNameSuggestions.dataset.selectionInProgress) shareNameSuggestions.classList.remove('active');
                const asxCode = shareNameInput.value.trim().toUpperCase();
                if (!asxCode && formCompanyName) formCompanyName.textContent = '';
                // Post-blur validation: if a code was intended (from lastSearch) but input empty, restore
                if (!asxCode && window.lastSelectedSearchCode) {
                    const fallback = String(window.lastSelectedSearchCode).toUpperCase();
                    if (fallback.length >= 2) {
                        shareNameInput.value = fallback;
                        const match = (allAsxCodes||[]).find(s=>s.code===fallback);
                        if (match && formCompanyName) formCompanyName.textContent = match.name || '';
                    }
                }
                // clear transient flag
                try { delete shareNameSuggestions.dataset.selectionInProgress; } catch(_){}
            }, 250);
        });
    }

    // Hide shareName suggestions when clicking outside
    document.addEventListener('click', (e) => {
        if (shareNameSuggestions && !shareNameSuggestions.contains(e.target) && e.target !== shareNameInput) {
            shareNameSuggestions.classList.remove('active');
        }
    });
    // NEW: Autocomplete Search Input Listeners for Stock Search Modal (Consolidated & Corrected)
    if (asxSearchInput) {
        let currentSuggestions = []; // Stores the current filtered suggestions
        // Helper to centralize quick-add behavior and reduce duplication.
        function quickAddFromSearch(code, name) {
            // Two-step workflow enforcement: only display research; don't open Add Share modal here.
            if (!code) return;
            window.lastSelectedSearchCode = code;
            // Simply trigger the research detail rendering; button inside detail view will open Add Share.
            displayStockDetailsInSearchModal(code);
        }

        asxSearchInput.addEventListener('input', () => {
            const query = asxSearchInput.value.trim().toUpperCase();
            asxSuggestions.innerHTML = ''; // Clear previous suggestions
            currentSelectedSuggestionIndex = -1; // Reset selection

            if (query.length < 2) { // Only show suggestions if query is at least 2 characters
                asxSuggestions.classList.remove('active');
                searchResultDisplay.innerHTML = '<p class="initial-message">Start typing an ASX code to search.</p>'; // Reset display
                searchModalActionButtons.innerHTML = ''; // Clear action buttons
                currentSearchShareData = null;
                return;
            }

            // Filter suggestions by code or company name
            currentSuggestions = allAsxCodes.filter(stock => 
                stock.code.includes(query) || stock.name.toUpperCase().includes(query)
            ).slice(0, 10); // Limit to top 10 suggestions

            if (currentSuggestions.length > 0) {
                currentSuggestions.forEach((stock) => {
                    const div = document.createElement('div');
                    div.classList.add('suggestion-item');
                    div.textContent = `${stock.code} - ${stock.name}`;
                    div.dataset.code = stock.code;
                    div.dataset.name = stock.name;
                    // Use pointerup/click for selection to avoid blocking touch scrolling
                    const handler = (ev) => {
                        console.log('[Autocomplete] Select suggestion', stock.code, stock.name);
                        asxSearchInput.value = stock.code;
                        asxSuggestions.classList.remove('active');
                        quickAddFromSearch(stock.code, stock.name);
                    };
                    div.addEventListener('pointerup', handler, { passive: true });
                    div.addEventListener('click', handler); // fallback
                    asxSuggestions.appendChild(div);
                });
                asxSuggestions.classList.add('active');
            } else {
                asxSuggestions.classList.remove('active'); // Hide suggestions if no matches
                searchResultDisplay.innerHTML = '<p class="initial-message">No matching stocks found.</p>';
                searchModalActionButtons.innerHTML = '';
                currentSearchShareData = null;
            }
        });

        // Keyboard navigation for suggestions
        asxSearchInput.addEventListener('keydown', (e) => {
            const items = asxSuggestions.querySelectorAll('.suggestion-item');
            if (items.length === 0) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault(); // Prevent cursor movement in input
                currentSelectedSuggestionIndex = (currentSelectedSuggestionIndex + 1) % items.length;
                updateSelectedSuggestion(items);
                items[currentSelectedSuggestionIndex].scrollIntoView({ block: 'nearest' });
            } else if (e.key === 'ArrowUp') {
                e.preventDefault(); // Prevent cursor movement in input
                currentSelectedSuggestionIndex = (currentSelectedSuggestionIndex - 1 + items.length) % items.length;
                updateSelectedSuggestion(items);
                items[currentSelectedSuggestionIndex].scrollIntoView({ block: 'nearest' });
            } else if (e.key === 'Enter') {
                e.preventDefault(); // Prevent form submission
                if (currentSelectedSuggestionIndex > -1) {
                    // Use the code from the selected suggestion's dataset
                    const selectedCode = items[currentSelectedSuggestionIndex].dataset.code;
                    asxSearchInput.value = selectedCode; // Update input field with the selected code
                    asxSuggestions.classList.remove('active'); // Hide suggestions
                    displayStockDetailsInSearchModal(selectedCode); // Display details for the *selected* stock
                } else if (asxSearchInput.value.trim() !== '') {
                    // If no suggestion selected but input has value, search directly
                    displayStockDetailsInSearchModal(asxSearchInput.value.trim().toUpperCase());
                    asxSuggestions.classList.remove('active'); // Hide suggestions
                }
            } else if (e.key === 'Escape') {
                asxSuggestions.classList.remove('active'); // Hide suggestions
                asxSearchInput.value = ''; // Clear input
                searchResultDisplay.innerHTML = '<p class="initial-message">Start typing an ASX code to search.</p>';
                searchModalActionButtons.innerHTML = '';
                currentSearchShareData = null;
            }
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (asxSuggestions && !asxSuggestions.contains(e.target) && e.target !== asxSearchInput) {
                asxSuggestions.classList.remove('active');
            }
        });

        // Delegated fallback: clicking the code header in search results populates form
        if (searchResultDisplay) {
            searchResultDisplay.addEventListener('click', (e) => {
                const header = e.target.closest('.search-modal-code-header');
                if (!header) return;
                const code = header.getAttribute('data-code');
                const name = header.getAttribute('data-name');
                console.log('[Autocomplete] Header fallback click', code, name);
                if (!code) return;
                quickAddFromSearch(code, name);
            });
        }

        // Global delegated listener on container to catch any missed clicks (safety net)
        if (asxSuggestions) {
            asxSuggestions.addEventListener('click', (e) => {
                const item = e.target.closest('.suggestion-item');
                if (!item) return;
                const code = item.dataset.code;
                const name = item.dataset.name;
                console.log('[Autocomplete] Delegated suggestion click', code, name);
                if (!code) return;
                // Simulate normal path if direct listener failed
                const stock = { code, name };
                asxSearchInput.value = code;
                asxSuggestions.classList.remove('active');
                quickAddFromSearch(code, name);
            });
        }

        function updateSelectedSuggestion(items) {
            items.forEach((item, index) => {
                if (index === currentSelectedSuggestionIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
            // Update input value to selected suggestion for better UX
            if (currentSelectedSuggestionIndex > -1) {
                asxSearchInput.value = items[currentSelectedSuggestionIndex].dataset.code;
            }
        }
    }

    // Add event listeners to all form inputs for dirty state checking
    formInputs.forEach(input => {
        if (input) {
            input.addEventListener('input', checkFormDirtyState);
            input.addEventListener('change', checkFormDirtyState);
            input.addEventListener('focus', function() {
                // Removed: The 'this.select()' call, as it was causing a TypeError on SELECT elements (dropdowns) on focus.
                // The automatic text selection on focus is now bypassed for stability.
            });
        }
    });

    // Phase 1: Direction toggles + legacy checkboxes mutual exclusivity and sync
    const syncDirButtonsFromCheckboxes = () => {
        if (!targetDirAboveBtn || !targetDirBelowBtn) return;
        const isAbove = !!(targetAboveCheckbox && targetAboveCheckbox.checked);
        targetDirAboveBtn.classList.toggle('is-active', isAbove);
        targetDirAboveBtn.setAttribute('aria-pressed', String(isAbove));
        const isBelow = !isAbove;
        targetDirBelowBtn.classList.toggle('is-active', isBelow);
        targetDirBelowBtn.setAttribute('aria-pressed', String(isBelow));
    };

    if (targetAboveCheckbox && targetBelowCheckbox) {
        targetAboveCheckbox.addEventListener('change', () => {
            if (targetAboveCheckbox.checked) {
                targetBelowCheckbox.checked = false;
            }
            syncDirButtonsFromCheckboxes();
            checkFormDirtyState();
            const tp = parseFloat(targetPriceInput ? targetPriceInput.value : '');
            if (!isNaN(tp) && tp !== 0) scheduleAlertAutoSave('dir-checkbox-above');
        });

        targetBelowCheckbox.addEventListener('change', () => {
            if (targetBelowCheckbox.checked) {
                targetAboveCheckbox.checked = false;
            }
            syncDirButtonsFromCheckboxes();
            checkFormDirtyState();
            const tp = parseFloat(targetPriceInput ? targetPriceInput.value : '');
            if (!isNaN(tp) && tp !== 0) scheduleAlertAutoSave('dir-checkbox-below');
        });
    }

    // Wire UI segmented direction buttons -> legacy checkboxes
    if (targetDirAboveBtn && targetDirBelowBtn && targetAboveCheckbox && targetBelowCheckbox) {
        targetDirAboveBtn.addEventListener('click', () => {
            userManuallyOverrodeDirection = true;
            targetAboveCheckbox.checked = true;
            targetBelowCheckbox.checked = false;
            syncDirButtonsFromCheckboxes();
            checkFormDirtyState();
            const tp = parseFloat(targetPriceInput ? targetPriceInput.value : '');
            if (!isNaN(tp) && tp !== 0) scheduleAlertAutoSave('dir-btn-above');
        });
        targetDirBelowBtn.addEventListener('click', () => {
            userManuallyOverrodeDirection = true;
            targetAboveCheckbox.checked = false;
            targetBelowCheckbox.checked = true;
            syncDirButtonsFromCheckboxes();
            checkFormDirtyState();
            const tp = parseFloat(targetPriceInput ? targetPriceInput.value : '');
            if (!isNaN(tp) && tp !== 0) scheduleAlertAutoSave('dir-btn-below');
        });
        // Initial sync
        syncDirButtonsFromCheckboxes();
    }

    // Wire Intent buttons: set defaults when user hasn't manually overridden
    if (targetIntentBuyBtn && targetIntentSellBtn) {
        const setIntentUI = (intent) => {
            const isBuy = intent === 'buy';
            targetIntentBuyBtn.classList.toggle('is-active', isBuy);
            targetIntentBuyBtn.setAttribute('aria-pressed', String(isBuy));
            targetIntentSellBtn.classList.toggle('is-active', !isBuy);
            targetIntentSellBtn.setAttribute('aria-pressed', String(!isBuy));
            const tp = parseFloat(targetPriceInput ? targetPriceInput.value : '');
            if (!isNaN(tp) && tp !== 0) scheduleAlertAutoSave('intent-'+intent);
        };
        targetIntentBuyBtn.addEventListener('click', () => {
            setIntentUI('buy');
            if (!userManuallyOverrodeDirection && targetAboveCheckbox && targetBelowCheckbox) {
                // Buy defaults to Below
                targetAboveCheckbox.checked = false;
                targetBelowCheckbox.checked = true;
                syncDirButtonsFromCheckboxes();
                checkFormDirtyState();
                const tp = parseFloat(targetPriceInput ? targetPriceInput.value : '');
                if (!isNaN(tp) && tp !== 0) scheduleAlertAutoSave('intent-buy-default-dir');
            }
        });
        targetIntentSellBtn.addEventListener('click', () => {
            setIntentUI('sell');
            if (!userManuallyOverrodeDirection && targetAboveCheckbox && targetBelowCheckbox) {
                // Sell defaults to Above
                targetAboveCheckbox.checked = true;
                targetBelowCheckbox.checked = false;
                syncDirButtonsFromCheckboxes();
                checkFormDirtyState();
                const tp = parseFloat(targetPriceInput ? targetPriceInput.value : '');
                if (!isNaN(tp) && tp !== 0) scheduleAlertAutoSave('intent-sell-default-dir');
            }
        });
        // Default to Buy on load
        setIntentUI('buy');
    }

// Target price auto-save on blur / Enter (only when non-zero)
if (targetPriceInput) {
    targetPriceInput.addEventListener('blur', () => {
        const tp = parseFloat(targetPriceInput.value);
        if (!isNaN(tp) && tp !== 0) scheduleAlertAutoSave('tp-blur');
    });
    targetPriceInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const tp = parseFloat(targetPriceInput.value);
            if (!isNaN(tp) && tp !== 0) scheduleAlertAutoSave('tp-enter');
        }
    });
}
    
    // NEW: Add event listeners for cash asset form inputs for dirty state checking (2.1)
    if (cashAssetNameInput) cashAssetNameInput.addEventListener('input', checkCashAssetFormDirtyState);
    if (cashAssetBalanceInput) cashAssetBalanceInput.addEventListener('input', checkCashAssetFormDirtyState);

    formInputs.forEach((inputElement, index) => { // Renamed 'input' to 'inputElement' for clarity
        if (inputElement) {
            inputElement.addEventListener('keydown', function(event) { // 'this' refers to 'inputElement'
                if (event.key === 'Enter') {
                    event.preventDefault();

                    // Case 1: If it's a SELECT element (e.g., shareRatingSelect)
                    if (this.tagName === 'SELECT') {
                        const nextElement = formInputs[index + 1];
                        if (nextElement) {
                            nextElement.focus();
                        } else if (addCommentSectionBtn && addCommentSectionBtn.offsetParent !== null && !addCommentSectionBtn.classList.contains('is-disabled-icon')) {
                            addCommentSectionBtn.click();
                            const newCommentTitleInput = commentsFormContainer.lastElementChild?.querySelector('.comment-title-input');
                            if (newCommentTitleInput) {
                                newCommentTitleInput.focus();
                            }
                        } else if (saveShareBtn && !saveShareBtn.classList.contains('is-disabled-icon')) {
                            saveShareBtn.click();
                        }
                        return; // Stop processing after handling SELECT
                    }

                    // Case 2: If it's an INPUT or TEXTAREA element
                    if (this.tagName === 'INPUT' || this.tagName === 'TEXTAREA') {
                        // Removed: The 'this.select()' call, as it was causing an inexplicable TypeError on SELECT elements.
                        // The original intention was to select text in text inputs, but this is now bypassed for stability.
                        // The focus logic below will still proceed.
                        const nextElement = formInputs[index + 1];
                        if (nextElement) {
                            nextElement.focus();
                        } else if (addCommentSectionBtn && addCommentSectionBtn.offsetParent !== null && !addCommentSectionBtn.classList.contains('is-disabled-icon')) {
                            addCommentSectionBtn.click();
                            const newCommentTitleInput = commentsFormContainer.lastElementChild?.querySelector('.comment-title-input');
                            if (newCommentTitleInput) {
                                newCommentTitleInput.focus();
                            }
                        } else if (saveShareBtn && !saveShareBtn.classList.contains('is-disabled-icon')) {
                            saveShareBtn.click();
                        }
                        return; // Stop processing after handling INPUT/TEXTAREA
                    }

                    // Fallback for any other element type (shouldn't happen with formInputs array)
                    // Or if no specific action was taken, try to focus next general element
                    const nextElement = formInputs[index + 1];
                    if (nextElement) {
                        nextElement.focus();
                    }
                }
            });
        }
    });

    // Add Comment Section Button for Shares
    if (addCommentSectionBtn) {
        setIconDisabled(addCommentSectionBtn, false);
        addCommentSectionBtn.addEventListener('click', () => {
            addCommentSection(commentsFormContainer);
            checkFormDirtyState();
        });
    }

    // NEW: Add Comment Section Button for Cash Assets
    if (addCashAssetCommentBtn) {
        setIconDisabled(addCashAssetCommentBtn, false);
        addCashAssetCommentBtn.addEventListener('click', () => {
            addCommentSection(cashAssetCommentsContainer, '', '', true); // true for cash asset comment
            checkCashAssetFormDirtyState();
        });
    }
    // Close buttons for modals
    document.querySelectorAll('.close-button').forEach(button => {
        if (button.classList.contains('form-close-button')) { // Specific for the share form's 'X' (Cancel button)
            button.addEventListener('click', () => {
                logDebug('Form: Share form close button (X) clicked. Clearing form before closing to cancel edits.');
                clearForm(); // This will reset originalShareData and selectedShareDocId, preventing auto-save
                closeModals(); // Now closeModals won't trigger auto-save for this form
            });
        } else if (button.classList.contains('cash-form-close-button')) { // NEW: Specific for cash asset form's 'X' (Cancel button)
            button.addEventListener('click', () => {
                logDebug('Cash Form: Cash asset form close button (X) clicked. Clearing form before closing to cancel edits.');
                clearCashAssetForm(); // Reset originalCashAssetData and selectedCashAssetDocId
                closeModals();
            });
        }
        else {
            button.addEventListener('click', closeModals); // Other modals still close normally
        }
    });

    // NEW: Close button for stock search modal
    if (searchModalCloseButton) {
        searchModalCloseButton.addEventListener('click', () => {
            logDebug('Search Modal: Close button clicked.');
            asxSearchInput.value = ''; // Clear input on close
            searchResultDisplay.innerHTML = '<p class="initial-message">Start typing an ASX code to search.</p>'; // Reset display
            searchModalActionButtons.innerHTML = ''; // Clear action buttons
            asxSuggestions.classList.remove('active'); // Hide suggestions
            currentSelectedSuggestionIndex = -1; // Reset selection
            currentSearchShareData = null; // Clear current search data
            hideModal(stockSearchModal);
        });
    }

    // Global click listener to close modals/context menu if clicked outside
    window.addEventListener('click', (event) => {
        // If we're in a brief modal-to-modal transition, skip global close logic
        try { if (window.__modalTransitioning && (Date.now() - window.__modalTransitioning) < 250) return; } catch(_) {}
        // Handle targetHitDetailsModal minimization specifically.
        // This ensures clicks *outside* the modal content and *not* on the trigger button minimize it.
        if (targetHitDetailsModal && targetHitDetailsModal.style.display !== 'none') {
            const clickedInsideModalContent = targetHitDetailsModal.querySelector('.modal-content').contains(event.target);
            const clickedOnTargetIconButton = (event.target === targetHitIconBtn || targetHitIconBtn.contains(event.target));
            
            if (!clickedInsideModalContent && !clickedOnTargetIconButton) {
                logDebug('Global Click: Clicked outside targetHitDetailsModal (and not on icon). Minimizing it.');
                hideModal(targetHitDetailsModal); // Directly hide the modal
                return; // Prevent further modal closing logic for this click
            }
        }

        // General modal closing logic (for other modals)
        if (event.target === shareDetailModal || event.target === dividendCalculatorModal ||
            event.target === shareFormSection ||
            event.target === calculatorModal || event.target === addWatchlistModal ||
            event.target === manageWatchlistModal || event.target === alertPanel ||
            event.target === cashAssetFormModal || event.target === cashAssetDetailModal ||
            event.target === stockSearchModal) {
            closeModals();
        }

        // Context menu closing logic
        if (contextMenuOpen && shareContextMenu && !shareContextMenu.contains(event.target)) {
            hideContextMenu();
        }
    });

    // The event listener for targetHitIconBtn needs to be robust.
    // Ensure it is only added once during initialization and always re-shows the modal.
    // This part should be in `initializeAppLogic` as confirmed previously.
    // Make sure the `initializeAppLogic` function's relevant section looks like this:
    /*
    if (targetHitIconBtn) {
        // Remove existing listeners to prevent multiple bindings if initializeAppLogic runs again
        targetHitIconBtn.removeEventListener('click', showTargetHitDetailsModal);
        targetHitIconBtn.addEventListener('click', (event) => {
            logDebug('Target Alert: Icon button clicked. Opening details modal.');
            // Ensure the modal is explicitly shown
            showModal(targetHitDetailsModal);
            try { scrollMainToTop(); } catch(_) {}
        });
    }
    */
    // For this specific update, I will also add the `removeEventListener` directly to the `targetHitIconBtn` section in `initializeAppLogic`.

    // Locate the `targetHitIconBtn` listener setup inside `initializeAppLogic`
    // and replace it with the more robust version if it's not already like this.
    // This is not part of the immediately surrounding code, but essential for the fix.
    // So, this is a reminder for you to check this part in the `initializeAppLogic` function too:
    // **No change in the provided snippet above for the targetHitIconBtn,
    // as it is correctly handled in `initializeAppLogic` as a separate concern.**

    // The fix for this immediate context is primarily the global click listener logic.

    // Google Auth Button (Sign In/Out) - This button is removed from index.html.
    // Its functionality is now handled by splashSignInBtn.

    // NEW: Splash Sign-In with popup-first and redirect fallback (handles COOP/COEP popup issues)

    // Early environment safety check: mobile + file:// cannot perform Google auth
    try {
        const precheckUA = navigator.userAgent || navigator.vendor || '';
        const precheckIsMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(precheckUA);
        const precheckIsFile = (window.location && window.location.protocol === 'file:');
        if (splashSignInBtn && precheckIsMobile && precheckIsFile) {
            updateSplashSignInButtonState('error', 'Open via web URL');
            splashSignInBtn.disabled = true;
            showCustomAlert("Mobile sign-in can't run from a file:// URL. Please serve this app over http(s) (e.g., VS Code Live Server) and retry.");
            console.warn('Auth Precheck: Blocking sign-in on mobile file:// context.');
        }
    } catch(_) {}

    if (splashSignInBtn && splashSignInBtn.getAttribute('data-bound') !== 'true') {
        let splashSignInRetryTimer = null;
        let splashSignInInProgress = false;
        splashSignInBtn.setAttribute('data-bound','true');
        splashSignInBtn.addEventListener('click', async () => {
            logDebug('Auth: Splash Screen Sign-In Button Clicked.');
            const currentAuth = auth;
            if (!currentAuth || !authFunctions) {
                console.warn('Auth: Auth service not ready or functions not loaded. Cannot process splash sign-in.');
                showCustomAlert('Authentication service not ready. Please try again in a moment.');
                return;
            }
            try {
                if (splashSignInInProgress) {
                    console.warn('Auth: Sign-in already in progress; ignoring duplicate click.');
                    return;
                }
                splashSignInInProgress = true;
                // Visual feedback
                if (splashKangarooIcon) splashKangarooIcon.classList.add('pulsing');
                splashSignInBtn.disabled = true;
                const btnSpan = splashSignInBtn.querySelector('span');
                if (btnSpan) { btnSpan.textContent = 'Signing in…'; }
                // Always create a fresh provider per attempt to avoid stale customParameters
                const provider = (authFunctions.createGoogleProvider ? authFunctions.createGoogleProvider() : authFunctions.GoogleAuthProviderInstance);
                if (!provider) {
                    console.error('Auth: GoogleAuthProvider instance not found. Is Firebase module script loaded?');
                    showCustomAlert('Authentication service not ready. Firebase script missing.');
                    splashSignInInProgress = false;
                    return;
                }
                try { provider.addScope('email'); provider.addScope('profile'); } catch(_) {}
                // Ensure persistence is set to local before performing the sign-in so the session remains after app restarts.
                try {
                    if (authFunctions.setPersistence && authFunctions.browserLocalPersistence) {
                        await authFunctions.setPersistence(currentAuth, authFunctions.browserLocalPersistence);
                        logDebug('Auth: Persistence force-set to browserLocalPersistence prior to sign-in.');
                    }
                } catch (pErr) {
                    console.warn('Auth: Failed to force-set browserLocalPersistence prior to sign-in. Proceeding with sign-in anyway.', pErr);
                }

                // Prefer redirect in environments where popup is likely to fail (COOP/COEP or blocked popups)
                const preferRedirect = (typeof window !== 'undefined' && (!!window.crossOriginIsolated || /Headless|Electron|Steam|OPR\//i.test(navigator.userAgent || '')));
                if (preferRedirect) {
                    logDebug('Auth: crossOriginIsolated detected. Using signInWithRedirect.');
                    if (btnSpan) { btnSpan.textContent = 'Redirecting to Google…'; }
                    await authFunctions.signInWithRedirect(currentAuth, provider);
                    return; // navigation begins
                }

                // Attempt popup first
                try {
                    const resolver = authFunctions.browserPopupRedirectResolver;
                    if (resolver) await authFunctions.signInWithPopup(currentAuth, provider, resolver);
                    else await authFunctions.signInWithPopup(currentAuth, provider);
                    logDebug('Auth: Google Sign-In successful from splash screen (popup).');
                } catch (popupErr) {
                    const code = popupErr && popupErr.code ? String(popupErr.code) : '';
                    const msg = popupErr && popupErr.message ? String(popupErr.message) : '';
                    const coopHint = /Cross-Origin-Opener-Policy|Blocked a frame with origin|SecurityError|COOP|COEP/i.test(msg);
                    const shouldFallback = coopHint || code === 'auth/operation-not-supported-in-this-environment' || code === 'auth/popup-blocked' || code === 'auth/unauthorized-domain';
                    if (shouldFallback) {
                        logDebug('Auth: Popup sign-in blocked or unsupported. Falling back to redirect.', { code, coopHint });
                        if (btnSpan) { btnSpan.textContent = 'Redirecting to Google…'; }
                        try {
                            await authFunctions.signInWithRedirect(currentAuth, provider);
                            return; // navigation begins
                        } catch (redirErr) {
                            console.error('Auth: signInWithRedirect also failed.', redirErr);
                            throw redirErr; // surface to outer catch for UI reset
                        }
                    } else {
                        throw popupErr; // non-recoverable popup error
                    }
                }
                // onAuthStateChanged will transition UI; keep button disabled briefly to avoid double-click
            }
            catch (error) {
                console.error('Auth: Google Sign-In failed from splash screen:', { code: error.code, message: error.message });
                showCustomAlert('Google Sign-In failed: ' + error.message);
                splashSignInInProgress = false;
                splashSignInInProgress = false;
                splashSignInBtn.disabled = false;
                const btnSpanReset = splashSignInBtn.querySelector('span');
                if (btnSpanReset) { btnSpanReset.textContent = 'Sign in with Google'; }
                if (splashKangarooIcon) splashKangarooIcon.classList.remove('pulsing');
            }
        });
    }

    // Optionally resolve pending redirect results (no-op when not applicable)
    try {
        if (auth && authFunctions && typeof authFunctions.getRedirectResult === 'function') {
            authFunctions.getRedirectResult(auth).then((res)=>{
                if (res && res.user) {
                    logDebug('Auth: Redirect result received; user signed in.');
                }
            }).catch((e)=>{
                const msg = String(e && e.message || '');
                if (/Cross-Origin-Opener-Policy|COOP|COEP/i.test(msg)) {
                    console.warn('Auth: COOP/COEP error encountered post-redirect. This is non-fatal; user may already be signed in.');
                }
            });
        }
    } catch(_) {}

    // NEW: Event listener for the top 'X' close button in the Target Hit Details Modal
    if (targetHitModalCloseTopBtn) {
        targetHitModalCloseTopBtn.addEventListener('click', () => {
            hideModal(targetHitDetailsModal); // Standard close, keeps bubble active
            logDebug('Target Alert Modal: Top Close button clicked. Modal hidden.');
        });
    }

    // NEW: Event listener for the "Minimize" button at the bottom of the modal
    if (alertModalMinimizeBtn) {
        alertModalMinimizeBtn.addEventListener('click', () => {
            hideModal(targetHitDetailsModal); // Close the modal
            // The bubble remains visible by default unless explicitly dismissed
            logDebug('Target Alert Modal: Minimize button clicked. Modal hidden, bubble remains active.');
        });
    }

    // NEW: Event listener for the "Dismiss All" button at the bottom of the modal
    if (alertModalDismissAllBtn) {
        alertModalDismissAllBtn.addEventListener('click', () => {
            targetHitIconDismissed = true; // Mark as dismissed for the session
            localStorage.setItem('targetHitIconDismissed', 'true'); // Save dismissal preference
            try { localStorage.setItem('lastKnownTargetCount', '0'); } catch(e) {}
            // No need to explicitly hide the bubble here, updateTargetHitBanner will handle it.
            updateTargetHitBanner(); // Update the bubble (will hide it if no alerts and dismissed)
            hideModal(targetHitDetailsModal); // Close the modal
            showCustomAlert('Alert Targets dismissed until next login.', 2000); // User feedback
            renderWatchlist(); // Re-render the watchlist to remove all borders/highlights
            try { enforceMoversVirtualView(); } catch(_) {}
            logDebug('Target Alert Modal: Dismiss All button clicked. Alerts dismissed, modal and bubble hidden. Watchlist re-rendered.');
        });
    }

    // NEW: Clear All Alerts button listener (alertPanel is not in current HTML, but kept for consistency)
    if (clearAllAlertsBtn) {
        clearAllAlertsBtn.addEventListener('click', () => {
            logDebug('Alert Panel: Clear All button clicked.');
            setSharesAtTargetPrice([]); // Clear all alerts in memory
            // renderAlertsInPanel(); // Commented out as alertPanel is not in HTML
            updateTargetHitBanner(); // Update the main icon count
            showCustomAlert('All alerts cleared for this session.', 1500);
            // hideModal(alertPanel); // Commented out as alertPanel is not in HTML
        });
    }


    // Logout Button
    if (logoutBtn) {
        logoutBtn.addEventListener('click', async () => {
            logDebug('Auth: Logout Button Clicked (No Confirmation).');
            const currentAuth = auth;
            if (!currentAuth || !authFunctions) {
                console.warn('Auth: Auth service not ready or functions not loaded. Cannot process logout.');
                showCustomAlert('Authentication service not ready. Please try again in a moment.');
                return;
            }
            try {
                await authFunctions.signOut(currentAuth);
                showCustomAlert('Logged out successfully!', 1500);
                logDebug('Auth: User successfully logged out.');

                // Cleanup global watchers
                try {
                    if (globalViewModeWatcher) {
                        clearInterval(globalViewModeWatcher);
                        globalViewModeWatcher = null;
                        logDebug('Auth: Global view mode enforcer cleaned up');
                    }
                    if (viewModePersistenceTimer) {
                        clearTimeout(viewModePersistenceTimer);
                        viewModePersistenceTimer = null;
                    }
                    if (sortOrderPersistenceTimer) {
                        clearTimeout(sortOrderPersistenceTimer);
                        sortOrderPersistenceTimer = null;
                    }
                    if (viewModeConsistencyChecker) {
                        clearInterval(viewModeConsistencyChecker);
                        viewModeConsistencyChecker = null;
                        logDebug('Auth: View mode consistency checker cleaned up');
                    }
                } catch (cleanupError) {
                    console.warn('Auth: Error cleaning up watchers:', cleanupError);
                }

                toggleAppSidebar(false);

                // NEW: Explicitly ensure splash screen is visible for re-authentication
                if (splashScreen) {
                    splashScreen.style.display = 'flex'; // Ensure splash screen is visible
                    splashScreen.classList.remove('hidden'); // Ensure it's not hidden
                    document.body.style.overflow = 'hidden'; // Re-apply overflow hidden
                    if (splashKangarooIcon) {
                        splashKangarooIcon.classList.remove('pulsing'); // Stop animation if signed out
                    }
                    if (splashSignInBtn) {
                        splashSignInBtn.disabled = false; // Enable sign-in button
                        const buttonTextSpan = splashSignInBtn.querySelector('span');
                        if (buttonTextSpan) {
                            buttonTextSpan.textContent = 'Sign in with Google'; // Reset only the text, not the icon
                        }
                    }
                    // Hide main app content
                    if (mainContainer) {
                        mainContainer.classList.add('app-hidden');
                    }
                    if (appHeader) {
                        appHeader.classList.add('app-hidden');
                    }
                    logDebug('Splash Screen: User signed out, splash screen remains visible for sign-in.');
                } else {
                    console.warn('Splash Screen: User signed out, but splash screen element not found. App content might be visible.');
                }
                // NEW: Reset targetHitIconDismissed and clear localStorage entry on logout for a fresh start on next login
                targetHitIconDismissed = false; 
                localStorage.removeItem('targetHitIconDismissed');
                try { localStorage.removeItem('forcedLiveFetchOnce'); } catch(e) {}
                try { localStorage.setItem('lastKnownTargetCount', '0'); } catch(e) {}

            }
            catch (error) {
                console.error('Auth: Logout failed:', error);
                showCustomAlert('Logout failed: ' + error.message);
            }
        });
    }

// Delete All User Data Button
if (deleteAllUserDataBtn) {
    deleteAllUserDataBtn.addEventListener('click', () => {
        logDebug('UI: Delete All User Data button clicked.');
        deleteAllUserData();
        toggleAppSidebar(false); // Close sidebar after action
    });
}

    // Watchlist Select Change Listener
    if (watchlistSelect) {
        watchlistSelect.addEventListener('change', async (event) => {
            logDebug('Watchlist Select: Change event fired. New value: ' + event.target.value);
            setCurrentSelectedWatchlistIds([event.target.value]);
            try { localStorage.setItem('lastWatchlistSelection', JSON.stringify(currentSelectedWatchlistIds)); } catch(_) {}
                    try { setLastSelectedView(event.target.value); } catch(_) {}

            // Robust watchlist selection persistence
            try {
                await saveLastSelectedWatchlistIds(currentSelectedWatchlistIds);
                logDebug('Watchlist: Saved last selected IDs: ' + currentSelectedWatchlistIds.join(', '));
            } catch (error) {
                console.warn('Watchlist: Failed to save last selected IDs:', error);
                // Fallback: ensure localStorage is set
                try {
                    localStorage.setItem('lastWatchlistSelection', JSON.stringify(currentSelectedWatchlistIds));
                    logDebug('Watchlist: Emergency fallback - saved to localStorage');
                } catch (localError) {
                    console.error('Watchlist: Emergency fallback also failed:', localError);
                }
            }

            // Restore per-watchlist sort order if available, but validate it's applicable for the newly-selected view.
            try {
                // Rebuild the sort select options for the new view so we can validate restored values
                try { renderSortSelect(); } catch(_) {}
                const availableOptionValues = Array.from(sortSelect ? sortSelect.options : []).map(o => o.value);

                let watchlistSortOrder = getSortOrderForWatchlist(event.target.value);
                if (watchlistSortOrder && availableOptionValues.includes(watchlistSortOrder)) {
                    setCurrentSortOrder(watchlistSortOrder);
                    logDebug('Watchlist Select: Restored valid per-watchlist sort for ' + event.target.value + ': ' + watchlistSortOrder);
                    try { if (sortSelect) sortSelect.value = watchlistSortOrder; updateSortIcon(); } catch(_) {}
                } else {
                    // If saved order is invalid or missing, pick a sensible default for this view
                    const sensibleDefault = (event.target.value === CASH_BANK_WATCHLIST_ID) ? 'name-asc' : 'percentageChange-desc';
                    // If portfolio view, prefer totalDollar-desc as default
                    const portfolioDefault = (event.target.value === 'portfolio') ? 'totalDollar-desc' : sensibleDefault;
                    const chosenDefault = availableOptionValues.includes(portfolioDefault) ? portfolioDefault : (availableOptionValues[0] || sensibleDefault);
                    setCurrentSortOrder(chosenDefault);
                    logDebug('Watchlist Select: Applied fallback/default sort for ' + event.target.value + ': ' + chosenDefault);
                    try { if (sortSelect) sortSelect.value = chosenDefault; updateSortIcon(); } catch(_) {}
                    // Persist this fallback back to per-watchlist preferences so subsequent switches remember it
                    try {
                        setWatchlistSortOrder(event.target.value, chosenDefault);
                        // Use robust persistence helper (debounced and resilient)
                        try { robustSaveSortOrder(chosenDefault); } catch(_) {}
                        logDebug('Watchlist Select: Persisted fallback sort for ' + event.target.value + ': ' + chosenDefault);
                    } catch (persistErr) {
                        console.warn('Watchlist Select: Failed to persist fallback sort for ' + event.target.value, persistErr);
                    }
                }
            } catch (err) {
                console.warn('Watchlist Select: Error restoring/validating per-watchlist sort, falling back to global/defaults', err);
                // As a last resort, apply a safe default
                const safeDefault = (event.target.value === CASH_BANK_WATCHLIST_ID) ? 'name-asc' : 'percentageChange-desc';
                try { setCurrentSortOrder(safeDefault); if (sortSelect) sortSelect.value = safeDefault; updateSortIcon(); } catch(_) {}
            }

            // Just render the watchlist. The listeners for shares/cash are already active.
            sortShares();
            try { enforceMoversVirtualView(); } catch(_) {}
            // FIX: Update ASX button state when switching watchlists via dropdown
            // This was missing and caused the ASX button visibility bug
            try { toggleCodeButtonsArrow(); } catch (e) { console.warn('Watchlist Select: toggleCodeButtonsArrow failed', e); }
            // Also update add header button context (consistency with watchlist picker)
            try { updateAddHeaderButton(); updateSidebarAddButtonContext(); } catch (e) { console.warn('Watchlist Select: header button update failed', e); }
        // UX: scroll to top after changing watchlist so users see top content
        try { if (window.scrollMainToTop) window.scrollMainToTop(); else scrollMainToTop(); } catch(_) {}
        });
    }

    // Sort Select Change Listener
if (sortSelect) {
    sortSelect.addEventListener('change', async (event) => {
        logDebug('Sort Select: Change event fired. New value: ' + event.target.value);
        // If the ASX toggle pseudo-option was chosen, toggle ASX buttons and restore the current sort selection.
        if (event.target.value === '__asx_toggle') {
            try {
                console.log('[SORT SELECT DEBUG] ASX toggle option selected');
                const currentExpanded = getAsxButtonsExpanded();
                console.log('[SORT SELECT DEBUG] Current expanded state:', currentExpanded);

                setAsxButtonsExpanded(!currentExpanded);
                applyAsxButtonsState();

                // Update the ASX option label to reflect new state
                const asxOpt = Array.from(sortSelect.options).find(o => o.value === '__asx_toggle');
                if (asxOpt) asxOpt.textContent = (getAsxButtonsExpanded() ? 'ASX Codes — Hide' : 'ASX Codes — Show');

                // Trigger scroll logic for ASX toggle
                console.log('[SORT SELECT DEBUG] Setting __asxToggleWantsScroll = true');
                window.__asxToggleWantsScroll = true;

                // Trigger scroll with delay to allow DOM to update
                setTimeout(() => {
                    try {
                        const targetPosition = calculateWatchlistScrollPosition();
                        console.log('[SORT SELECT DEBUG] Scrolling to position:', targetPosition);
                        if (window.scrollMainToTop) {
                            window.scrollMainToTop(false, targetPosition);
                        } else {
                            scrollMainToTop(false, targetPosition);
                        }
                        adjustMainContentPadding();
                    } catch(error) {
                        console.error('Error in sort select scroll:', error);
                    }
                }, 100);

                // Fallback scroll
                setTimeout(() => {
                    if (window.__asxToggleWantsScroll) {
                        try {
                            // Reset known inner scrollers first
                            const tc = document.querySelector('.table-container'); if (tc && tc.scrollTop) tc.scrollTop = 0;
                            const mc = document.getElementById('mobileShareCards'); if (mc && mc.scrollTop) mc.scrollTop = 0;
                            const pf = document.querySelector('.portfolio-scroll-wrapper'); if (pf && pf.scrollTop) pf.scrollTop = 0;

                            const targetPosition = calculateWatchlistScrollPosition();
                            if (window.scrollMainToTop) {
                                window.scrollMainToTop(false, targetPosition);
                            } else {
                                scrollMainToTop(false, targetPosition);
                            }
                            adjustMainContentPadding();
                            delete window.__asxToggleWantsScroll;
                        } catch(error) {
                            console.error('Fallback scroll error:', error);
                        }
                    }
                }, 500);

            } catch (e) { console.warn('ASX toggle option handler failed', e); }
            // Restore the visible selection back to the active sort (do not trigger a sort)
            try { sortSelect.value = currentSortOrder || (getCurrentSelectedWatchlistIds().includes('portfolio') ? 'totalDollar-desc' : 'entryDate-desc'); } catch(_) {}
            try { updateSortIcon(); } catch(_) {}
            return; // do not apply sorting when toggling ASX codes
        }

        setCurrentSortOrder(sortSelect.value);
        // Immediately reflect this choice in the in-memory per-watchlist mapping so subsequent view switches see it
        try {
            const curIds = getCurrentSelectedWatchlistIds();
            if (Array.isArray(curIds) && curIds.length > 0) {
                const wid = curIds[0];
                if (wid) try { setWatchlistSortOrder(wid, sortSelect.value); } catch(_) {}
            }
        } catch(_) {}
        updateSortIcon();

        // AGGRESSIVE FIX: Force apply sort immediately for percentage change sorts
        const __selectedSortNow = (typeof getCurrentSortOrder === 'function') ? getCurrentSortOrder() : window.currentSortOrder;
        if (__selectedSortNow === 'percentageChange-desc' || __selectedSortNow === 'percentageChange-asc') {
            logDebug('AGGRESSIVE SORT: Percentage change sort selected, forcing immediate application');
            forceApplyCurrentSort();
        }
        
        // Determine whether to sort shares or cash assets
        if (getCurrentSelectedWatchlistIds().includes(CASH_BANK_WATCHLIST_ID)) {
            renderCashCategories(); // Re-render cash categories with new sort order
        } else {
            sortShares(); // Sorts allSharesData and calls renderWatchlist
        }

    // Robust sort order persistence with error recovery - save the authoritative value
    const __toPersistSort = (typeof getCurrentSortOrder === 'function') ? getCurrentSortOrder() : window.currentSortOrder;
    try {
        // Avoid redundant persist calls if we've already persisted this exact sort recently
        if (window.__lastPersistedSort && window.__lastPersistedSort === __toPersistSort) {
            logDebug('Sort: Persist skipped (no change): ' + __toPersistSort);
        } else {
            robustSaveSortOrder(__toPersistSort);
            // Record the last persisted value so subsequent identical changes are skipped
            try { window.__lastPersistedSort = __toPersistSort; } catch(_) {}
        }
    } catch (persistErr) {
        console.warn('Sort: Error while attempting to persist sort order (non-fatal):', persistErr);
    }

    // NEW: Scroll to the top of the main content after sorting/rendering
    try { scrollMainToTop(); } catch(_) {}
    logDebug('Sort: Scrolled to top after sorting.');
    });
    updateSortIcon();
}
    // New Share Button (from sidebar) - Now contextual, handled by updateSidebarAddButtonContext
    // The event listener will be set dynamically by updateSidebarAddButtonContext()
    // No direct event listener here anymore.

    // NEW: Add New Cash Asset Button (from sidebar)
    if (addCashAssetSidebarBtn) {
        addCashAssetSidebarBtn.addEventListener('click', () => {
            logDebug('UI: Add New Cash Asset button (sidebar) clicked.');
            addCashCategoryUI(); // This function now directly opens the modal for adding a new cash asset
            toggleAppSidebar(false);
        });
    }

    // Add Share Header Button (from header) - now contextual, handled by updateAddHeaderButton
    // Its click listener is set dynamically in updateAddHeaderButton()

    // Event listener for shareNameInput to toggle saveShareBtn
    if (shareNameInput && saveShareBtn) {
        // UX: Prevent attempting to add a duplicate ASX code. Disable Save and surface a message.
        let __isDuplicateCode = false;
        const duplicateHintElId = 'duplicateCodeHint';
        function setDuplicateState(isDup) {
            // New UX: when duplicate detected, simply disable save and rely on a toast at save-time.
            __isDuplicateCode = !!isDup;
            try {
                if (__isDuplicateCode) {
                    setIconDisabled(saveShareBtn, true);
                    // Keep DOM minimal: remove any previous inline hint to avoid encouraging open-edit flow
                    const h = document.getElementById(duplicateHintElId); if (h) h.remove();
                    // Optionally set aria-describedby for accessibility (not visible text)
                    try { shareNameInput.setAttribute('aria-describedby', duplicateHintElId); } catch(_) {}
                } else {
                    setIconDisabled(saveShareBtn, false);
                    const h = document.getElementById(duplicateHintElId); if (h) h.remove();
                    try { shareNameInput.removeAttribute('aria-describedby'); } catch(_) {}
                }
            } catch(_) {}
        }

        shareNameInput.addEventListener('input', () => {
            checkFormDirtyState();
            try {
                const val = (shareNameInput.value || '').trim().toUpperCase();
                if (val) {
                    const exists = Array.isArray(allSharesData) && allSharesData.some(s => s && (s.shareName||'').toUpperCase() === val);
                    // Consider it a duplicate only if there exists another share with the same code
                    // whose id is different from the currently edited share (if any).
                    let isDup = false;
                    if (exists) {
                        const other = (Array.isArray(allSharesData) ? allSharesData.find(s => s && (s.shareName||'').toUpperCase() === val && s.id !== (selectedShareDocId || null)) : null);
                        isDup = !!other;
                    }
                    setDuplicateState(isDup);
                } else {
                    setDuplicateState(false);
                }
            } catch(e) { console.warn('Duplicate code check failed', e); }
        });

        // Evaluate initial state once in case the input is prefilled when opening the modal for edit
        try {
            const initialVal = (shareNameInput.value || '').trim().toUpperCase();
            if (initialVal) {
                const other = (Array.isArray(allSharesData) ? allSharesData.find(s => s && (s.shareName||'').toUpperCase() === initialVal && s.id !== (selectedShareDocId || null)) : null);
                setDuplicateState(!!other);
            } else {
                setDuplicateState(false);
            }
        } catch(_) {}

        // Intercept Save click to show friendly message if duplicate flag present
        const _origSaveHandler = saveShareBtn.onclick || null;
        saveShareBtn.addEventListener('click', async (ev) => {
            try {
                if (__isDuplicateCode) {
                    // Block save and show an appropriate message depending on context
                    const form = (typeof getCurrentFormData === 'function') ? getCurrentFormData() : null;
                    const isEditing = !!selectedShareDocId;
                    const hasWatchlistSelection = (form && ((Array.isArray(form.watchlistIds) && form.watchlistIds.length > 0) || (form.watchlistId && form.watchlistId !== '')));

                    if (isEditing && !hasWatchlistSelection) {
                        const msg = 'Save canceled — please assign this share to at least one watchlist before saving.';
                        if (window.ToastManager && typeof window.ToastManager.info === 'function') {
                            window.ToastManager.info(msg, 3500);
                        } else if (typeof window.showCustomAlert === 'function') {
                            window.showCustomAlert(msg);
                        } else {
                            try { alert(msg); } catch(_) {}
                        }
                    } else {
                        const dupMsg = 'A share with this code already exists. Save blocked.';
                        if (window.ToastManager && typeof window.ToastManager.info === 'function') {
                            window.ToastManager.info(dupMsg, 3000);
                        } else if (typeof window.showCustomAlert === 'function') {
                            window.showCustomAlert(dupMsg, 2500);
                        } else {
                            try { alert(dupMsg); } catch(_) {}
                        }
                    }

                    // Prevent any other click handlers (including the AppService save handler)
                    // from running on this event.
                    if (ev && typeof ev.stopImmediatePropagation === 'function') ev.stopImmediatePropagation();
                    try { if (ev && typeof ev.preventDefault === 'function') ev.preventDefault(); } catch(_) {}
                    return; // prevent original save path
                }
            } catch(e) {
                console.warn('Duplicate intercept failed', e);
            }

            // otherwise proceed with original click handlers (if any were wired via onclick)
            if (_origSaveHandler) try { _origSaveHandler.call(saveShareBtn, ev); } catch(_) {}
        });
    }

    // Save Share Button
    if (saveShareBtn) {
        saveShareBtn.addEventListener('click', async () => {
            logDebug('Share Form: Save Share button clicked.');

            // Restore selectedShareDocId from modal dataset if not set
            if (!selectedShareDocId && shareDetailModal && shareDetailModal.dataset && shareDetailModal.dataset.shareId) {
                selectedShareDocId = shareDetailModal.dataset.shareId;
                logDebug('Save Share: Restored selectedShareDocId from modal dataset: ' + selectedShareDocId);
            }

            // Prevent duplicate rapid clicks by disabling immediately and awaiting the service
            try {
                window.setIconDisabled && window.setIconDisabled(saveShareBtn, true);
            } catch(_) {}

            try {
                // Await the AppService save so modal close behavior and state is consistent
                // Capture the visible modal current price at click-time. Use a tiny retry/backoff
                // if the element is populated asynchronously to reduce the race window.
                let capturedPriceBeforeSave = '';
                try {
                    const readCurrentPrice = () => {
                        const cpEl = document.getElementById('currentPrice');
                        return (cpEl && typeof cpEl.value === 'string') ? cpEl.value.trim() : '';
                    };

                    // Try immediate read, then short backoffs if empty (conservative: 3 attempts)
                    capturedPriceBeforeSave = readCurrentPrice();
                    if (!capturedPriceBeforeSave) {
                        // small delay/polling values chosen to be short but helpful (ms)
                        const backoffs = [120, 300];
                        for (let i = 0; i < backoffs.length && !capturedPriceBeforeSave; i++) {
                            // eslint-disable-next-line no-await-in-loop
                            await new Promise(res => setTimeout(res, backoffs[i]));
                            capturedPriceBeforeSave = readCurrentPrice();
                        }
                    }
                } catch (_) { capturedPriceBeforeSave = ''; }

                // Pass the captured price explicitly to the AppService save method so it doesn't rely on a window-global
                if (typeof saveShareDataSvc === 'function') {
                    await saveShareDataSvc(false, capturedPriceBeforeSave);
                } else if (window.AppService && typeof window.AppService.saveShareData === 'function') {
                    await window.AppService.saveShareData(false, capturedPriceBeforeSave);
                } else {
                    // Fallback to old call if function reference not available
                    saveShareDataSvc(false, capturedPriceBeforeSave);
                }
            } catch (err) {
                console.error('Share Form: Error saving share via service:', err);
                // Re-enable on error so user can retry
                try { window.setIconDisabled && window.setIconDisabled(saveShareBtn, false); } catch(_) {}
            }
        });
    }

    // Delete Share Button (with confirmation)
    if (deleteShareBtn) {
        deleteShareBtn.addEventListener('click', async () => {
            logDebug('Share Form: Delete Share button clicked.');
            if (deleteShareBtn.classList.contains('is-disabled-icon')) {
                console.warn('Delete Share: Delete button was disabled, preventing action.');
                return;
            }
            if (!selectedShareDocId) { showCustomAlert('No share selected for deletion.'); return; }
            try {
                const shares = (typeof getAllSharesData === 'function') ? getAllSharesData() : (window.allSharesData || []);
                const s = shares.find(x => x && x.id === selectedShareDocId);
                const code = (s && s.shareName) ? String(s.shareName).toUpperCase() : 'this share';
                showCustomConfirm(`Delete "${code}"? This action cannot be undone.`, async (confirmed) => {
                    if (!confirmed) return;
                    try { await deleteShareSvc(selectedShareDocId); } catch (error) { console.error('Firestore: Error deleting share:', error); showCustomAlert('Error deleting share: ' + error.message); }
                });
            } catch (e) {
                console.warn('Delete Share: could not resolve share name; proceeding with confirm.', e);
                showCustomConfirm('Delete this share? This action cannot be undone.', async (confirmed) => { if (!confirmed) return; try { await deleteShareSvc(selectedShareDocId); } catch (error) { console.error('Firestore: Error deleting share:', error); showCustomAlert('Error deleting share: ' + error.message); } });
            }
        });
    }

    // Edit Share From Detail Button
    if (editShareFromDetailBtn) {
        editShareFromDetailBtn.addEventListener('click', () => {
            logDebug('Share Details: Edit Share button clicked.');
            if (editShareFromDetailBtn.classList.contains('is-disabled-icon')) {
                console.warn('Edit Share From Detail: Edit button was disabled, preventing action.');
                return;
            }
            // Ensure selectedShareDocId exists even if selection was cleared after save/render
            if (!selectedShareDocId && shareDetailModal && shareDetailModal.dataset && shareDetailModal.dataset.shareId) {
                selectedShareDocId = shareDetailModal.dataset.shareId;
                logDebug('Share Details: Restored selectedShareDocId from modal dataset: ' + selectedShareDocId);
            }
            // Mark that the edit form was opened from share details so back restores it
            wasEditOpenedFromShareDetail = true;
            // Close the detail modal visually only (keep it in the back stack) to avoid overlay conflicts
            try {
                if (typeof hideModalKeepStack === 'function') {
                    logBackDebug && logBackDebug('DETAIL→EDIT keep-stack hide', 'shareDetailModal');
                    hideModalKeepStack(shareDetailModal);
                } else if (window.UI && window.UI.hideModal) {
                    // UI.hideModal will purge; instead do a visual hide to preserve stack
                    shareDetailModal.style.setProperty('display','none','important');
                    shareDetailModal.classList.remove('show');
                } else {
                    shareDetailModal.style.setProperty('display','none','important');
                    shareDetailModal.classList.remove('show');
                }
            } catch(_) {}
            if (typeof showEditFormForSelectedShare === 'function') {
                showEditFormForSelectedShare();
            }
        });
    }

    // Delete Share From Detail Button (with confirmation)
    if (deleteShareFromDetailBtn) {
        deleteShareFromDetailBtn.addEventListener('click', async () => {
            logDebug('Share Details: Delete Share button clicked.');
            if (deleteShareFromDetailBtn.classList.contains('is-disabled-icon')) { console.warn('Delete Share From Detail: Delete button was disabled, preventing action.'); return; }
            if (!selectedShareDocId) { showCustomAlert('No share selected for deletion.'); return; }
            try {
                const shares = (typeof getAllSharesData === 'function') ? getAllSharesData() : (window.allSharesData || []);
                const s = shares.find(x => x && x.id === selectedShareDocId);
                const code = (s && s.shareName) ? String(s.shareName).toUpperCase() : 'this share';
                showCustomConfirm(`Are you sure you want to delete "${code}" this action cannot be undone?`, async (confirmed) => {
                    if (!confirmed) return;
                    try { await deleteShareSvc(selectedShareDocId); } catch (error) { console.error('Firestore: Error deleting share:', error); showCustomAlert('Error deleting share: ' + error.message); }
                });
            } catch (_) {
                showCustomConfirm('Are you sure you want to delete this share this action cannot be undone?', async (confirmed) => { if (!confirmed) return; try { await deleteShareSvc(selectedShareDocId); } catch (error) { console.error('Firestore: Error deleting share:', error); showCustomAlert('Error deleting share: ' + error.message); } });
            }
        });
    }

    // Context Menu Edit Share Button
    if (contextEditShareBtn) {
        contextEditShareBtn.addEventListener('click', () => {
            logDebug('Context Menu: Edit Share button clicked.');
            if (currentContextMenuShareId) {
                const shareIdToEdit = currentContextMenuShareId;
                hideContextMenu();
                showEditFormForSelectedShare(shareIdToEdit);
            } else {
                console.warn('Context Menu: No share ID found for editing.');
            }
        });
    }

    // Context Menu Delete Share Button (with confirmation)
    if (contextDeleteShareBtn) {
        contextDeleteShareBtn.addEventListener('click', async () => {
            logDebug('Context Menu: Delete Share button clicked.');
            if (!currentContextMenuShareId) { showCustomAlert('No share selected for deletion from context menu.'); console.warn('Context Menu: No share ID found for deletion.'); return; }
            const shareToDeleteId = currentContextMenuShareId;
            hideContextMenu();
            try {
                const shares = (typeof getAllSharesData === 'function') ? getAllSharesData() : (window.allSharesData || []);
                const s = shares.find(x => x && x.id === shareToDeleteId);
                const code = (s && s.shareName) ? String(s.shareName).toUpperCase() : 'this share';
                showCustomConfirm(`Are you sure you want to delete "${code}" this action cannot be undone?`, async (confirmed) => {
                    if (!confirmed) return;
                    try { await deleteShareSvc(shareToDeleteId); } catch (error) { console.error('Firestore: Error deleting share:', error); showCustomAlert('Error deleting share: ' + error.message); }
                });
            } catch (_) {
                showCustomConfirm('Are you sure you want to delete this share this action cannot be undone?', async (confirmed) => { if (!confirmed) return; try { await deleteShareSvc(shareToDeleteId); } catch (error) { console.error('Firestore: Error deleting share:', error); showCustomAlert('Error deleting share: ' + error.message); } });
            }
        });
    }

    // Add Watchlist Button
    if (addWatchlistBtn) {
        addWatchlistBtn.addEventListener('click', () => {
            logDebug('UI: Add Watchlist button clicked.');
            if (newWatchlistNameInput) newWatchlistNameInput.value = '';
            setIconDisabled(saveWatchlistBtn, true); // Disable save button initially
            logDebug('Add Watchlist: saveWatchlistBtn disabled initially.');
            originalWatchlistData = getCurrentWatchlistFormData(true); // Store initial state for dirty check
            showModal(addWatchlistModal);
            try { scrollMainToTop(); } catch(_) {}
            newWatchlistNameInput.focus();
            toggleAppSidebar(false);
            checkWatchlistFormDirtyState(true); // Check dirty state immediately after opening
        });
    }

    // Event listener for newWatchlistNameInput to toggle saveWatchlistBtn (for Add Watchlist Modal)
    if (newWatchlistNameInput && saveWatchlistBtn) {
        newWatchlistNameInput.addEventListener('input', () => {
            checkWatchlistFormDirtyState(true);
        });
    }

    // Save Watchlist Button (for Add Watchlist Modal)
    if (saveWatchlistBtn) {
        saveWatchlistBtn.addEventListener('click', async () => {
            logDebug('Watchlist Form: Save Watchlist button clicked.');
            if (saveWatchlistBtn.classList.contains('is-disabled-icon')) {
                showCustomAlert('Please enter a watchlist name.');
                console.warn('Save Watchlist: Save button was disabled, preventing action.');
                return;
            }
            const watchlistName = newWatchlistNameInput.value.trim();
            await saveWatchlistChanges(false, watchlistName); // false indicates not silent
        });
    }

    // Edit Watchlist Button
    if (editWatchlistBtn) {
        editWatchlistBtn.addEventListener('click', () => {
            logDebug('UI: Edit Watchlist button clicked.');
            let watchlistToEditId = watchlistSelect.value;

            // Prevent editing "All Shares" or "Cash & Assets"
            if (watchlistToEditId === ALL_SHARES_ID || watchlistToEditId === CASH_BANK_WATCHLIST_ID) {
                showCustomAlert('Cannot edit this special watchlist.', 2000);
                return;
            }

            if (!watchlistToEditId || !userWatchlists.some(w => w.id === watchlistToEditId)) {
                showCustomAlert('Please select a watchlist to edit.');
                return;
            }
            const selectedWatchlistObj = userWatchlists.find(w => w.id === watchlistToEditId);
            const watchlistToEditName = selectedWatchlistObj ? selectedWatchlistObj.name : '';

            logDebug('Edit Watchlist Button Click: Watchlist to edit ID: ' + watchlistToEditId + ', Name: ' + watchlistToEditName);

            // Ensure currentEditingWatchlistId is set for modal actions (delete/save)
            currentEditingWatchlistId = watchlistToEditId;

            editWatchlistNameInput.value = watchlistToEditName;
            // Keep at least one real watchlist + Cash & Assets
            const actualWatchlists = userWatchlists.filter(wl => wl.id !== ALL_SHARES_ID && wl.id !== CASH_BANK_WATCHLIST_ID);
            const isDisabledDelete = actualWatchlists.length <= 1; 
            setIconDisabled(deleteWatchlistInModalBtn, isDisabledDelete); 
            logDebug('Edit Watchlist: deleteWatchlistInModalBtn disabled: ' + isDisabledDelete);
            setIconDisabled(saveWatchlistNameBtn, true); // Disable save button initially
            logDebug('Edit Watchlist: saveWatchlistNameBtn disabled initially.');
            originalWatchlistData = getCurrentWatchlistFormData(false); // Store initial state for dirty check
            showModal(manageWatchlistModal);
            try { scrollMainToTop(); } catch(_) {}
            editWatchlistNameInput.focus();
            toggleAppSidebar(false);
            checkWatchlistFormDirtyState(false); // Check dirty state immediately after opening
        });
    }

    // Event listener for editWatchlistNameInput to toggle saveWatchlistNameBtn
    if (editWatchlistNameInput && saveWatchlistNameBtn) {
        editWatchlistNameInput.addEventListener('input', () => {
            checkWatchlistFormDirtyState(false);
        });
    }

    // Save Watchlist Name Button (for Manage Watchlist Modal)
    if (saveWatchlistNameBtn) {
        saveWatchlistNameBtn.addEventListener('click', async () => {
            logDebug('Manage Watchlist Form: Save Watchlist Name button clicked.');
            if (saveWatchlistNameBtn.classList.contains('is-disabled-icon')) {
                showCustomAlert('Watchlist name cannot be empty or unchanged.');
                console.warn('Save Watchlist Name: Save button was disabled, preventing action.');
                return;
            }
            const newName = editWatchlistNameInput.value.trim();
            const watchlistToEditId = currentEditingWatchlistId; // Use the stored ID
            await saveWatchlistChanges(false, newName, watchlistToEditId); // false indicates not silent
        });
    }

    // Delete Watchlist In Modal Button (for Manage Watchlist Modal)
    if (deleteWatchlistInModalBtn) {
        deleteWatchlistInModalBtn.addEventListener('click', async () => {
            logDebug('Manage Watchlist Form: Delete Watchlist button clicked (Direct Delete).');
            if (deleteWatchlistInModalBtn.classList.contains('is-disabled-icon')) {
                console.warn('Delete Watchlist In Modal: Delete button was disabled, preventing action.');
                return;
            }

            let watchlistToDeleteId = currentEditingWatchlistId; // Use the stored ID

            // Guard clause: check for null/undefined/empty ID
            if (!watchlistToDeleteId) {
                showCustomAlert('Error: Cannot delete watchlist. ID is missing or invalid.', 2000);
                console.error('DeleteWatchlist: watchlistToDeleteId is null/undefined/empty:', watchlistToDeleteId);
                return;
            }

            // Prevent deleting "All Shares" or "Cash & Assets"
            if (watchlistToDeleteId === ALL_SHARES_ID || watchlistToDeleteId === CASH_BANK_WATCHLIST_ID) {
                showCustomAlert('Cannot delete this special watchlist.', 2000);
                return;
            }

            // Ensure at least one actual watchlist remains (excluding Cash & Assets)
            const actualWatchlists = userWatchlists.filter(wl => wl.id !== ALL_SHARES_ID && wl.id !== CASH_BANK_WATCHLIST_ID);
            if (actualWatchlists.length <= 1) {
                showCustomAlert('Cannot delete the last stock watchlist. Please create another stock watchlist first.', 3000);
                return;
            }

            // Use the new safe deletion function which handles confirmation internally
            try {
                await deleteWatchlistSvc(watchlistToDeleteId);
                // The service function handles all UI updates, so no additional actions needed here
            } catch (error) {
                console.error('Error deleting watchlist:', error);
                // Error handling is done within the service function
            }
        });
    }

    // Initialize calculators via UI module if available
    // Ensure calculators are initialized after UI module loaded. Prefer UI.initCalculators when available.
    try {
        if (window.UI && typeof window.UI.initCalculators === 'function') {
            window.UI.initCalculators();
            } else {
            // If UI isn't ready yet, schedule a short retry once so dynamic load order doesn't break functionality
            setTimeout(() => {
                try {
                    if (window.UI && typeof window.UI.initCalculators === 'function') {
                        window.UI.initCalculators();
            } else {
                        console.warn('Calculator Setup: window.UI.initCalculators() still not found after retry.');
                    }
                } catch (e) { console.warn('Calculator Setup: retry failed', e); }
            }, 50);
        }
    } catch (e) { console.warn('Calculator Setup: init error', e); }









    // Scroll to Top Button
    if (scrollToTopBtn) {
        window.addEventListener('scroll', () => {
            if (window.innerWidth <= 768) {
                if (window.scrollY > 200) {
                    scrollToTopBtn.style.display = 'flex';
                    scrollToTopBtn.style.opacity = '1';
                } else {
                    scrollToTopBtn.style.opacity = '0';
                    setTimeout(() => {
                        scrollToTopBtn.style.display = 'none';
                    }, 300);
                }
            } else {
                scrollToTopBtn.style.display = 'none';
            }
        });
        if (window.innerWidth > 768) {
            scrollToTopBtn.style.display = 'none';
        } else {
            window.dispatchEvent(new Event('scroll'));
        }
        scrollToTopBtn.addEventListener('click', () => { window.scrollTo({ top: 0, behavior: 'smooth' }); logDebug('UI: Scrolled to top.'); });
    }

    // Hamburger Menu and Sidebar Interactions
    if (hamburgerBtn && appSidebar && closeMenuBtn && sidebarOverlay) {
        logDebug('Sidebar Setup: Initializing sidebar event listeners. Elements found:', {
            hamburgerBtn: !!hamburgerBtn,
            appSidebar: !!appSidebar,
            closeMenuBtn: !!closeMenuBtn,
            sidebarOverlay: !!sidebarOverlay
        });
        
        // Ensure initial state is correct: always start CLOSED after reload
        if (window.innerWidth > 768) {
            document.body.classList.remove('sidebar-active'); // Do not shift body on load
            sidebarOverlay.style.pointerEvents = 'none'; // Overlay non-interactive on desktop when closed
            appSidebar.classList.remove('open'); // Start closed on desktop too
            logDebug('Sidebar: Desktop: Sidebar initialized as closed.');
        } else {
            document.body.classList.remove('sidebar-active'); // No shift on mobile
            sidebarOverlay.style.pointerEvents = 'auto'; // Overlay interactive on mobile
            appSidebar.classList.remove('open'); // Sidebar closed by default on mobile
            logDebug('Sidebar: Mobile: Sidebar initialized as closed.');
        }


        // Unified hamburger listener with idempotent guard
        if (!hamburgerBtn.dataset.sidebarBound) {
            hamburgerBtn.addEventListener('click', (event) => {
                logDebug('UI: Hamburger button CLICKED. Event:', event);
                event.stopPropagation();
                const willOpen = !appSidebar.classList.contains('open');
                toggleAppSidebar();
            });
            hamburgerBtn.dataset.sidebarBound = '1';
        }
        closeMenuBtn.addEventListener('click', () => {
            logDebug('UI: Close Menu button CLICKED.');
            toggleAppSidebar(false);
        });
        
        // Unified overlay handler (single authoritative listener) - prevents race/double fire
        if (sidebarOverlay._unifiedHandler) {
            sidebarOverlay.removeEventListener('mousedown', sidebarOverlay._unifiedHandler, true);
            sidebarOverlay.removeEventListener('click', sidebarOverlay._unifiedHandler, true);
            sidebarOverlay.removeEventListener('touchstart', sidebarOverlay._unifiedHandler, true);
        }
        const unifiedHandler = (e) => {
            if (e.target !== sidebarOverlay) return; // Only backdrop clicks
            if (!appSidebar.classList.contains('open')) return;
            try { toggleAppSidebar(false); } catch(err){ console.warn('Sidebar close failed', err); }
            // Suppress any further processing or bubbling to avoid click-throughs
            if (e.stopImmediatePropagation) e.stopImmediatePropagation();
            e.stopPropagation();
            if (e.preventDefault) e.preventDefault();
        };
        sidebarOverlay.addEventListener('mousedown', unifiedHandler, true);
        sidebarOverlay._unifiedHandler = unifiedHandler;

        // Accessibility & focus trap for sidebar when open
        const mainContent = document.getElementById('mainContent') || document.querySelector('main');
        const firstFocusableSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
        function trapFocus(e){
            if (!appSidebar.classList.contains('open')) return;
            const focusables = Array.from(appSidebar.querySelectorAll(firstFocusableSelector)).filter(el=>!el.disabled && el.offsetParent!==null);
            if (!focusables.length) return;
            const first = focusables[0];
            const last = focusables[focusables.length-1];
            if (e.key === 'Tab') {
                if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
                else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
            }
        }
        document.addEventListener('keydown', trapFocus, true);

        // Hook into toggleAppSidebar to set aria-hidden
        const __origToggle = toggleAppSidebar;
        window.toggleAppSidebar = function(force){
            __origToggle(force);
            const isOpen = appSidebar.classList.contains('open');
            if (mainContent) mainContent.setAttribute('aria-hidden', isOpen ? 'true':'false');
            if (isOpen) {
                // Move initial focus
                setTimeout(()=>{
                    const first = appSidebar.querySelector(firstFocusableSelector);
                    if (first) first.focus();
                },30);
            } else {
                if (mainContent) mainContent.removeAttribute('inert');
            }
        };

        // Desktop outside-click closer (capture + swallow to prevent click-through)
        document.addEventListener('click', (event) => {
            const isDesktop = window.innerWidth > 768;
            if (!isDesktop) return; // Mobile uses overlay
            if (!appSidebar.classList.contains('open')) return;
            // If click target is outside sidebar & hamburger button
            if (!appSidebar.contains(event.target) && !hamburgerBtn.contains(event.target)) {
                logDebug('Global Click (capture): outside desktop click -> closing sidebar (swallowing event)');
                // Close sidebar first
                toggleAppSidebar(false);
                // Swallow so underlying element does NOT also activate on this same click
                event.stopPropagation();
                event.preventDefault();
            }
        }, true); // capture phase so we intercept before underlying handlers

        window.addEventListener('resize', () => {
            logDebug('Window Resize: Resizing window. Closing sidebar if open.');
            const isDesktop = window.innerWidth > 768;
            if (appSidebar.classList.contains('open')) {
                toggleAppSidebar(false);
            }
            if (scrollToTopBtn) {
                if (window.innerWidth > 768) {
                    scrollToTopBtn.style.display = 'none';
                } else {
                    window.dispatchEvent(new Event('scroll'));
                }
            }
            // NEW: Recalculate header height on resize
            adjustMainContentPadding();

            // NEW: Update the compact view button state on resize
            updateCompactViewButtonState();
        });

        const menuButtons = appSidebar.querySelectorAll('.menu-button-item');
        menuButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const clickedButton = event.currentTarget;
                logDebug('Sidebar Menu Item Click: Button \'' + clickedButton.textContent.trim() + '\' clicked.');

                // Handle specific action for the toggle compact view button
                if (clickedButton.id === 'toggleCompactViewBtn') {
                    toggleMobileViewMode();
                }

                const closesMenu = clickedButton.dataset.actionClosesMenu !== 'false';
                if (clickedButton.id === 'forceUpdateBtn') {
                    // Force update always closes first to avoid stale UI during reload
                    toggleAppSidebar(false);
                    forceHardUpdate();
                    return; // further processing not needed
                }
                if (closesMenu) toggleAppSidebar(false);
            });
        });
    } else {
        console.warn('Sidebar Setup: Fallback: window.UI.initSidebar() not found. Using minimal fallback.');
        if (hamburgerBtn && appSidebar && closeMenuBtn && sidebarOverlay) {
            logDebug('Sidebar Setup: Initializing sidebar event listeners. Elements found:', {
                hamburgerBtn: !!hamburgerBtn,
                appSidebar: !!appSidebar,
                closeMenuBtn: !!closeMenuBtn,
                sidebarOverlay: !!sidebarOverlay
            });
            
            // Ensure initial state is correct: always start CLOSED after reload
            if (window.innerWidth > 768) {
                document.body.classList.remove('sidebar-active'); // Do not shift body on load
                sidebarOverlay.style.pointerEvents = 'none'; // Overlay non-interactive on desktop when closed
                appSidebar.classList.remove('open'); // Start closed on desktop too
                logDebug('Sidebar: Desktop: Sidebar initialized as closed.');
            } else {
                document.body.classList.remove('sidebar-active'); // No shift on mobile
                sidebarOverlay.style.pointerEvents = 'auto'; // Overlay interactive on mobile
                appSidebar.classList.remove('open'); // Sidebar closed by default on mobile
                logDebug('Sidebar: Mobile: Sidebar initialized as closed.');
            }


            // Unified hamburger listener with idempotent guard
            if (!hamburgerBtn.dataset.sidebarBound) {
                hamburgerBtn.addEventListener('click', (event) => {
                    logDebug('UI: Hamburger button CLICKED. Event:', event);
                    event.stopPropagation();
                    const willOpen = !appSidebar.classList.contains('open');
                    toggleAppSidebar();
                });
                hamburgerBtn.dataset.sidebarBound = '1';
            }
            closeMenuBtn.addEventListener('click', () => {
                logDebug('UI: Close Menu button CLICKED.');
                toggleAppSidebar(false);
            });
            
            // Unified overlay handler (single authoritative listener) - prevents race/double fire
            if (sidebarOverlay._unifiedHandler) {
                sidebarOverlay.removeEventListener('mousedown', sidebarOverlay._unifiedHandler, true);
                sidebarOverlay.removeEventListener('click', sidebarOverlay._unifiedHandler, true);
                sidebarOverlay.removeEventListener('touchstart', sidebarOverlay._unifiedHandler, true);
            }
            const unifiedHandler = (e) => {
                if (e.target !== sidebarOverlay) return; // Only backdrop clicks
                if (!appSidebar.classList.contains('open')) return;
                try { toggleAppSidebar(false); } catch(err){ console.warn('Sidebar close failed', err); }
                // Suppress any further processing or bubbling to avoid click-throughs
                if (e.stopImmediatePropagation) e.stopImmediatePropagation();
                e.stopPropagation();
                if (e.preventDefault) e.preventDefault();
            };
            sidebarOverlay.addEventListener('mousedown', unifiedHandler, true);
            sidebarOverlay._unifiedHandler = unifiedHandler;

            // Accessibility & focus trap for sidebar when open
            const mainContent = document.getElementById('mainContent') || document.querySelector('main');
            const firstFocusableSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
            function trapFocus(e){
                if (!appSidebar.classList.contains('open')) return;
                const focusables = Array.from(appSidebar.querySelectorAll(firstFocusableSelector)).filter(el=>!el.disabled && el.offsetParent!==null);
                if (!focusables.length) return;
                const first = focusables[0];
                const last = focusables[focusables.length-1];
                if (e.key === 'Tab') {
                    if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
                    else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
                }
            }
            document.addEventListener('keydown', trapFocus, true);

            // Hook into toggleAppSidebar to set aria-hidden
            const __origToggle = toggleAppSidebar;
            window.toggleAppSidebar = function(force){
                __origToggle(force);
                const isOpen = appSidebar.classList.contains('open');
                if (mainContent) mainContent.setAttribute('aria-hidden', isOpen ? 'true':'false');
                if (isOpen) {
                    // Move initial focus
                    setTimeout(()=>{
                        const first = appSidebar.querySelector(firstFocusableSelector);
                        if (first) first.focus();
                    },30);
                } else {
                    if (mainContent) mainContent.removeAttribute('inert');
                }
            };

            // Desktop outside-click closer (capture + swallow to prevent click-through)
            document.addEventListener('click', (event) => {
                const isDesktop = window.innerWidth > 768;
                if (!isDesktop) return; // Mobile uses overlay
                if (!appSidebar.classList.contains('open')) return;
                // If click target is outside sidebar & hamburger button
                if (!appSidebar.contains(event.target) && !hamburgerBtn.contains(event.target)) {
                    logDebug('Global Click (capture): outside desktop click -> closing sidebar (swallowing event)');
                    // Close sidebar first
                    toggleAppSidebar(false);
                    // Swallow so underlying element does NOT also activate on this same click
                    event.stopPropagation();
                    event.preventDefault();
                }
            }, true); // capture phase so we intercept before underlying handlers

            window.addEventListener('resize', () => {
                logDebug('Window Resize: Resizing window. Closing sidebar if open.');
                const isDesktop = window.innerWidth > 768;
                if (appSidebar.classList.contains('open')) {
                    toggleAppSidebar(false);
                }
                if (scrollToTopBtn) {
                    if (window.innerWidth > 768) {
                        scrollToTopBtn.style.display = 'none';
                    } else {
                        window.dispatchEvent(new Event('scroll'));
                    }
                }
                // NEW: Recalculate header height on resize
                adjustMainContentPadding();

                // NEW: Update the compact view button state on resize
                updateCompactViewButtonState();
            });

            const menuButtons = appSidebar.querySelectorAll('.menu-button-item');
            menuButtons.forEach(button => {
                button.addEventListener('click', (event) => {
                    const clickedButton = event.currentTarget;
                    logDebug('Sidebar Menu Item Click: Button \'' + clickedButton.textContent.trim() + '\' clicked.');

                    // Handle specific action for the toggle compact view button
                    if (clickedButton.id === 'toggleCompactViewBtn') {
                        toggleMobileViewMode();
                    }

                    const closesMenu = clickedButton.dataset.actionClosesMenu !== 'false';
                    if (clickedButton.id === 'forceUpdateBtn') {
                        // Force update always closes first to avoid stale UI during reload
                        toggleAppSidebar(false);
                        forceHardUpdate();
                        return; // further processing not needed
                    }
                    if (closesMenu) toggleAppSidebar(false);
                });
            });
        } else {
            console.warn('Sidebar Setup: Missing one or more sidebar elements (hamburgerBtn, appSidebar, closeMenuBtn, sidebarOverlay). Sidebar functionality might be impaired.');
        }
    }
    // Export Watchlist Button Event Listener
    if (exportWatchlistBtn) {
        exportWatchlistBtn.addEventListener('click', () => {
            logDebug('UI: Export Watchlist button clicked.');
            exportWatchlistToCSV();
            toggleAppSidebar(false);
        });
    }

    // Refresh Live Prices Button Event Listener
    if (refreshLivePricesBtn) {
        refreshLivePricesBtn.addEventListener('click', () => {
            logDebug('UI: Refresh Live Prices button clicked.');
            fetchLivePrices();
            showCustomAlert('Refreshing live prices...', 1000);
            toggleAppSidebar(false); // NEW: Close sidebar on refresh
            try { if (window.scrollMainToTop) window.scrollMainToTop(); else scrollMainToTop(); } catch(_) {}
        });
    }

    // NEW: Search Stock Button Listener
    if (searchStockBtn) {
        searchStockBtn.addEventListener('click', () => {
            logDebug('UI: Search Stock button clicked. Opening search modal.');
            // Clear and reset the modal content when opening
            asxSearchInput.value = '';
            searchResultDisplay.innerHTML = '<p class="initial-message">Start typing an ASX code to search.</p>';
            searchModalActionButtons.innerHTML = '';
            asxSuggestions.classList.remove('active');
            currentSelectedSuggestionIndex = -1;
            currentSearchShareData = null;
            showModal(stockSearchModal);
            try { scrollMainToTop(); } catch(_) {}
            asxSearchInput.focus();
            toggleAppSidebar(false); // Close sidebar
        });
    }
    
    // Removed: Show Last Live Price toggle listener (automatic behavior now)

    // NEW: Cash Asset Form Modal Save/Delete/Edit Buttons (2.1, 2.2)
    if (saveCashAssetBtn) {
        saveCashAssetBtn.addEventListener('click', async () => {
            logDebug('Cash Form: Save Cash Asset button clicked.');
            if (saveCashAssetBtn.classList.contains('is-disabled-icon')) {
                showCustomAlert('Asset name and balance are required, or no changes made.');
                console.warn('Save Cash Asset: Save button was disabled, preventing action.');
                return;
            }
            // Prevent duplicate clicks
            try { window.setIconDisabled && window.setIconDisabled(saveCashAssetBtn, true); } catch(_) {}
            try {
                if (window.AppService && typeof window.AppService.saveCashAsset === 'function') {
                    await window.AppService.saveCashAsset(false);
                } else {
                    // Enforce canonical save path: refuse to fall back to legacy code.
                    console.error('Save Cash Asset: AppService.saveCashAsset not available — aborting save to avoid legacy fallback.');
                    try { window.showCustomAlert && window.showCustomAlert('Internal error: Save service unavailable. Please refresh the page.'); } catch(_) {}
                    throw new Error('AppService.saveCashAsset not available');
                }
                // Ensure modal is closed after successful save - AppService attempts this but be defensive
                try { if (typeof closeModals === 'function') closeModals(); else if (window.closeModals) window.closeModals(); } catch(_) {}
            } catch(e) {
                console.error('Save Cash Asset failed', e);
                // Re-enable on error so user can retry
                try { window.setIconDisabled && window.setIconDisabled(saveCashAssetBtn, false); } catch(_) {}
            }
        });
    }

    // Delete is now handled inside the modal by uiService to avoid duplicate bindings

    if (editCashAssetFromDetailBtn) {
        editCashAssetFromDetailBtn.addEventListener('click', () => {
            logDebug('Cash Details: Edit Cash Asset button clicked.');
            if (selectedCashAssetDocId) {
                hideModal(cashAssetDetailModal);
                try {
                    // Defensive guard: if we just saved this asset very recently, suppress immediate reopen
                    if (window.__suppressCashModalReopen && window.__justSavedCashAssetId && window.__justSavedCashAssetId === selectedCashAssetDocId) {
                        try { window.logDebug && window.logDebug('Cash Details: Suppressed immediate reopen for just-saved asset ID=' + selectedCashAssetDocId); } catch(_) {}
                    } else {
                        try {
                            const shouldOpen = !(window.__suppressCashModalReopen && window.__justSavedCashAssetId && window.__justSavedCashAssetId === selectedCashAssetDocId);
                            if (shouldOpen) showAddEditCashCategoryModal(selectedCashAssetDocId);
                            else window.logDebug && window.logDebug('Suppressed reopening cash modal for just-saved asset ID: ' + selectedCashAssetDocId);
                        } catch(e) { try { showAddEditCashCategoryModal(selectedCashAssetDocId); } catch(_) {} }
                    }
                } catch (e) {
                    console.warn('Cash Details: Failed to open edit modal defensively', e);
                    try {
                        const shouldOpen = !(window.__suppressCashModalReopen && window.__justSavedCashAssetId && window.__justSavedCashAssetId === selectedCashAssetDocId);
                        if (shouldOpen) showAddEditCashCategoryModal(selectedCashAssetDocId);
                        else window.logDebug && window.logDebug('Suppressed reopening cash modal for just-saved asset ID: ' + selectedCashAssetDocId);
                    } catch(e) { try { showAddEditCashCategoryModal(selectedCashAssetDocId); } catch(_) {} }
                }
            } else {
                showCustomAlert('No cash asset selected for editing.');
            }
        });
    }

    if (deleteCashAssetFromDetailBtn) {
        deleteCashAssetFromDetailBtn.addEventListener('click', async () => {
            logDebug('Cash Details: Delete Cash Asset button clicked.');
            if (selectedCashAssetDocId) {
                const didDelete = await deleteCashCategory(selectedCashAssetDocId);
                if (didDelete) { try { closeModals(); } catch(_) {} }
            } else {
                showCustomAlert('No cash asset selected for deletion.');
            }
        });
    }


    // Call adjustMainContentPadding initially and on window load/resize
    // Removed: window.addEventListener('load', adjustMainContentPadding); // Removed, handled by onAuthStateChanged
    // Already added to window.addEventListener('resize') in sidebar section

    // NEW: Set initial state for the compact view button
    updateCompactViewButtonState();
    // applyCompactViewMode(); // Disabled - conflicts with robust restoration
} 
// This closing brace correctly ends the `initializeAppLogic` function here.
// Build Marker: v0.1.13 (Network-first CSS/JS, cache bust deploy)
// Also expose as a runtime variable for lightweight diagnostics
window.BUILD_MARKER = 'v0.1.13';

// Global helper: render a unified 52-week high/low notification card
// Safe to call from both the modern modal renderer and legacy/local paths.
// If later overridden, keep signature stable: (entry, kind) where kind is 'high' | 'low'
if (typeof window.renderHiLoEntry !== 'function') {
    function renderHiLoEntry(e, kind) {
        const code = String(e.code || e.shareCode || '').toUpperCase();
    const name = sanitizeCompanyName(e.name || e.companyName || code, code);
        const liveVal = (e.live!=null && !isNaN(Number(e.live))) ? Number(e.live) : null;
        const liveDisplay = (liveVal!=null) ? ('$' + formatAdaptivePrice(liveVal)) : '<span class="na">N/A</span>';
        // Pull both 52W High and Low from entry or livePrices fallback
        let lp = null; try { lp = (window.livePrices && window.livePrices[code]) ? window.livePrices[code] : null; } catch(_) {}
        const hiRaw = (e.high52 ?? e.High52 ?? e.hi52 ?? e.high ?? (lp ? (lp.high52 ?? lp.High52 ?? lp.hi52 ?? lp.high) : null) ?? null);
        const loRaw = (e.low52 ?? e.Low52 ?? e.lo52 ?? e.low ?? (lp ? (lp.low52 ?? lp.Low52 ?? lp.lo52 ?? lp.low) : null) ?? null);
        const hiDisplay = (hiRaw!=null && !isNaN(Number(hiRaw))) ? ('$' + formatAdaptivePrice(Number(hiRaw))) : '?';
        const loDisplay = (loRaw!=null && !isNaN(Number(loRaw))) ? ('$' + formatAdaptivePrice(Number(loRaw))) : '?';
        const card = document.createElement('div');
        card.className = 'notification-card hilo-card ' + kind;
        card.innerHTML = `
            <div class="notification-card-row">
                <div class="notification-card-left">
                    <div class="notification-code">${code}</div>
                    <div class="notification-name small">${name}</div>
                </div>
                <div class="notification-card-right">
                    <div class="notification-live">${liveDisplay}</div>
                </div>
            </div>
            <div class="notification-card-bottom hilo-bottom-row">
                <div class="hilo-low"><span class="label">Low:</span> ${loDisplay}</div>
                <div class="hilo-high"><span class="label">High:</span> ${hiDisplay}</div>
            </div>`;
        card.addEventListener('click', ()=>{
            try { hideModal(targetHitDetailsModal); } catch(_) {}
            try {
                const list = (window.allSharesData || []);
                const share = list.find(s => s && s.shareName && String(s.shareName).toUpperCase() === code);
                if (share && typeof selectShare === 'function') {
                    try { wasShareDetailOpenedFromTargetAlerts = true; } catch(_) {}
                    selectShare(share.id);
                    if (typeof showShareDetails === 'function') showShareDetails();
                    return;
                }
            } catch(_) {}
            try { if (typeof openStockSearchForCode === 'function') openStockSearchForCode(code); } catch(_) {}
        });
        return card;
    }
    // Expose on window for explicit usage as well
    try { window.renderHiLoEntry = renderHiLoEntry; } catch(_) {}
}

// Function to show the target hit details modal (moved to global scope)
function showTargetHitDetailsModal(options={}) {
    const explicit = options.explicit === true;
    const userInitiated = options.userInitiated === true;
    const allowDuringInitialLoad = options.allowDuringInitialLoad === true || userInitiated;
    try {
        if (window.__initialLoadPhase) {
            window.__targetHitModalInitLogCount = (window.__targetHitModalInitLogCount || 0) + 1;
            if (window.__targetHitModalInitLogCount <= 4) {
                console.warn('[TargetHitModal][InitPhase] open requested during initial load', { options, explicit, userInitiated, allowDuringInitialLoad, alreadyUserInitiated: __userInitiatedTargetModal });
                try { console.trace('[TargetHitModal][InitPhase] trace'); } catch(_) {}
            }
        }
    } catch(_) {}
    if (window.__initialLoadPhase && !allowDuringInitialLoad && !__userInitiatedTargetModal) {
        if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) console.log('[TargetHitModal] Suppressed auto-open during initial load phase', { explicit, userInitiated, allowDuringInitialLoad });
        return;
    }
    if (!targetHitDetailsModal || !targetHitSharesList) {
        console.error('Target Hit Modal: Required elements or data not found.');
        showCustomAlert('Error displaying target hit details. Please try again.', 2000);
        return;
    }
    // Guard: if no enabled/muted alerts, no custom hits, AND no active global summary, suppress unless explicit
    try {
        const noLocalEnabled = !sharesAtTargetPrice || sharesAtTargetPrice.length === 0;
        const noLocalMuted = !sharesAtTargetPriceMuted || sharesAtTargetPriceMuted.length === 0;
        const hasGlobalActive = (typeof isDirectionalThresholdsActive === 'function') ? isDirectionalThresholdsActive() : false;
        const hasDisplayableGlobal = hasGlobalActive && globalAlertSummary && globalAlertSummary.totalCount > 0;
        // Consider custom trigger hits as a source of displayable alerts for auto-open
        const __uid = (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) ? window.firebase.auth().currentUser.uid : currentUserId;
        const customHitsCount = (function(){ try { const arr = (window.customTriggerHits && Array.isArray(window.customTriggerHits.hits)) ? window.customTriggerHits.hits : []; return selectCustomTriggerHitsForUser(arr, __uid).length; } catch(_) { return 0; } })();
        if (!explicit && noLocalEnabled && noLocalMuted && !hasDisplayableGlobal && customHitsCount === 0) {
            if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) console.log('[TargetHitModal] Auto-open suppressed: no alerts, no custom triggers, or global summary to display.');
            return;
        }
    } catch(_err) { /* ignore */ }
    targetHitSharesList.innerHTML = ''; // Clear previous content (target hit section only)
    // Clear new global containers if present
    try {
        const gm = document.getElementById('globalMoversContainer'); if (gm) gm.innerHTML='';
        const gh = document.getElementById('globalHigh52Container'); if (gh) gh.innerHTML='';
        const gl = document.getElementById('globalLow52Container'); if (gl) gl.innerHTML='';
    } catch(_) {}

    // Delegate rendering of centralized global sections to the impl (populates movers/highs/lows)
    try { if (typeof window.__renderTargetHitDetailsModalImpl === 'function') { window.__renderTargetHitDetailsModalImpl(options); } } catch(_) {}

    // Update Notifications Summary counts and clicks
    try {
        const summaryHost = document.getElementById('notificationsSummary');
        if (summaryHost) {
            // Counts: Custom Triggers equals the union of
            // - selected CUSTOM_TRIGGER_HITS for the current user
            // - live in-memory triggered alerts (sharesAtTargetPrice)
            // - per-user 52-week hits (sharesAt52WeekLow / sharesAt52WeekHigh if present)
            const __uid = (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) ? window.firebase.auth().currentUser.uid : currentUserId;
            // Build union of codes so badge/modal counts match what user sees in notifications
            const centralHitsRaw = (window.customTriggerHits && Array.isArray(window.customTriggerHits.hits)) ? window.customTriggerHits.hits.slice() : [];
            const selectedCentralHits = selectCustomTriggerHitsForUser(centralHitsRaw, __uid) || [];
            const liveArrForCount = (window.sharesAtTargetPrice && Array.isArray(window.sharesAtTargetPrice)) ? window.sharesAtTargetPrice : (Array.isArray(sharesAtTargetPrice) ? sharesAtTargetPrice : []);
            const low52ArrForCount = (Array.isArray(window.sharesAt52WeekLow) ? window.sharesAt52WeekLow.filter(i => !i.muted) : []);
            const unionCodes = new Set();
            try { selectedCentralHits.forEach(h => { const c = String(h && (h.code || h.shareCode || h.shareName || '')).toUpperCase(); if (c) unionCodes.add(c); }); } catch(_) {}
            try { liveArrForCount.forEach(s => { const c = String(s && (s.shareName || s.code || s.shareCode || '')).toUpperCase(); if (c) unionCodes.add(c); }); } catch(_) {}
            try { low52ArrForCount.forEach(s => { const c = String(s && (s.code || s.shareName || s.shareCode || '')).toUpperCase(); if (c) unionCodes.add(c); }); } catch(_) {}
            const customCount = unionCodes.size;
            const targetCount = customCount;
            // Prefer centralized filtered movers, then raw, then snapshot fallback
            let gainersCount = 0, losersCount = 0;
            try {
                if (window.globalMoversHits) {
                    gainersCount = Array.isArray(window.globalMoversHits.upHits) ? window.globalMoversHits.upHits.length : 0;
                    losersCount = Array.isArray(window.globalMoversHits.downHits) ? window.globalMoversHits.downHits.length : 0;
                } else {
                    const gm = window.globalMovers || {};
                    if (Array.isArray(gm.upFiltered) || Array.isArray(gm.downFiltered) || Array.isArray(gm.up) || Array.isArray(gm.down)) {
                        gainersCount = Array.isArray(gm.upFiltered) ? gm.upFiltered.length : (Array.isArray(gm.up) ? gm.up.length : 0);
                        losersCount = Array.isArray(gm.downFiltered) ? gm.downFiltered.length : (Array.isArray(gm.down) ? gm.down.length : 0);
                    } else if (window.__lastMoversSnapshot && Array.isArray(window.__lastMoversSnapshot.entries)) {
                        const entries = window.__lastMoversSnapshot.entries;
                        gainersCount = entries.filter(e => (e.direction||'').toLowerCase() === 'up').length;
                        losersCount = entries.filter(e => (e.direction||'').toLowerCase() === 'down').length;
                    } else if (window.__lastMoversComputed && typeof window.__lastMoversComputed === 'object') {
                        gainersCount = Array.isArray(window.__lastMoversComputed.ups) ? window.__lastMoversComputed.ups.length : 0;
                        losersCount = Array.isArray(window.__lastMoversComputed.downs) ? window.__lastMoversComputed.downs.length : 0;
                    }
                }
            } catch(_) {}
            // 52-week highs/lows counts from centralized alerts if present
            let high52Count = 0, low52Count = 0;
            try {
                if (window.globalHiLo52Hits) {
                    high52Count = Array.isArray(window.globalHiLo52Hits.highHits) ? window.globalHiLo52Hits.highHits.length : 0;
                    low52Count = Array.isArray(window.globalHiLo52Hits.lowHits) ? window.globalHiLo52Hits.lowHits.length : 0;
                } else {
                    const hiLo = window.globalHiLo52Alerts || null;
                    if (hiLo) {
                        high52Count = Array.isArray(hiLo.highs) ? hiLo.highs.length : 0;
                        low52Count = Array.isArray(hiLo.lows) ? hiLo.lows.length : 0;
                    }
                }
            } catch(_) {}

            const setText = (id, val) => { const el=document.getElementById(id); if (el) el.textContent = String(val||0); };
            setText('summaryTargetCount', targetCount);
            setText('summaryGainersCount', gainersCount);
            setText('summaryLosersCount', losersCount);
            setText('summaryHigh52Count', high52Count);
            setText('summaryLow52Count', low52Count);

            // Click behavior: toggle respective accordion section; clicking again closes; clicking other switches
            if (!summaryHost.__chipsBound) {
                summaryHost.addEventListener('click', (ev) => {
                    const chip = ev.target.closest('.summary-chip');
                    if (!chip) return;
                    const sectionKey = chip.getAttribute('data-section');
                    if (!sectionKey) return;
                    const acc = document.querySelector('.notifications-accordion');
                    if (!acc) return;
                    const targetSection = acc.querySelector(`.accordion-section[data-section="${sectionKey}"]`);
                    if (!targetSection) return;

                    const isOpen = targetSection.classList.contains('open');
                    const header = targetSection.querySelector('.accordion-toggle');
                    if (!header) return;

                    if (isOpen) {
                        // Close the currently open section
                        targetSection.classList.remove('open');
                        header.setAttribute('aria-expanded', 'false');
                    } else {
                        // Close any other open section first
                        acc.querySelectorAll('.accordion-section.open').forEach(sec => {
                            if (sec !== targetSection) {
                                sec.classList.remove('open');
                                const h = sec.querySelector('.accordion-toggle');
                                if (h) h.setAttribute('aria-expanded', 'false');
                            }
                        });
                        // Open target section
                        targetSection.classList.add('open');
                        header.setAttribute('aria-expanded', 'true');
                        try { header.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch(_) {}
                    }
                });
                summaryHost.__chipsBound = true;
            }
        }
    } catch(err) { console.warn('[NotificationsSummary] Failed to update summary', err); }

    // --- Custom Triggers section: prefer live in-memory triggered alerts (sharesAtTargetPrice), then merge central CUSTOM_TRIGGER_HITS ---
    try {
    const __uid = (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) ? window.firebase.auth().currentUser.uid : currentUserId;
    // Normalize live-triggered shares into a hit-like shape so the existing renderer can consume them
    // Include per-user 52-week low/high alerts so they appear in the Custom Triggers section
    const liveShares = [];
    try {
        if (Array.isArray(sharesAtTargetPrice)) liveShares.push(...sharesAtTargetPrice.slice());
        if (Array.isArray(window.sharesAt52WeekLow)) {
            // Only include non-muted 52w entries
            window.sharesAt52WeekLow.forEach(s => { try { if (s && !s.muted) liveShares.push(s); } catch(_) {} });
        }
    } catch(_) { /* defensive */ }
    const hitsFromLive = liveShares.map(s => {
        try {
            const code = String(s && (s.shareName || s.code || s.shareCode || '')).toUpperCase();
            const name = sanitizeCompanyName(s && (s.name || s.companyName || ''), code);
            // live value: prefer explicit live on the share, else global livePrices
            let liveVal = (s && s.live != null && !isNaN(Number(s.live))) ? Number(s.live) : null;
            if (liveVal == null) {
                try { if (window.livePrices && window.livePrices[code] && window.livePrices[code].live != null) liveVal = Number(window.livePrices[code].live); } catch(_) {}
            }
            // target value: prefer targetPrice, fallback to target
            const targetVal = (s && s.targetPrice != null && !isNaN(Number(s.targetPrice))) ? Number(s.targetPrice) : ((s && s.target != null && !isNaN(Number(s.target))) ? Number(s.target) : null);
            const dir = (s && s.targetDirection) ? s.targetDirection : ((targetVal != null && liveVal != null) ? (liveVal >= targetVal ? 'above' : 'below') : '');
            const userIntent = (s && s.intent) ? s.intent : (s && s.userIntent ? s.userIntent : '');
            return { code, name, intent: 'target-hit', direction: dir, live: liveVal, target: targetVal, userIntent: userIntent, id: s && s.id };
        } catch(_) { return null; }
    }).filter(Boolean);

    // Pull central customTriggerHits for the user and slice to avoid mutating original
    let centralHits = (window.customTriggerHits && Array.isArray(window.customTriggerHits.hits)) ? window.customTriggerHits.hits.slice() : [];
    centralHits = selectCustomTriggerHitsForUser(centralHits, __uid);

    // Deduplicate by code: prefer live-derived hits (already triggered from runtime) over central doc duplicates
    const seenCodes = new Set(hitsFromLive.map(h => String(h.code || '').toUpperCase()));
    const mergedCentral = centralHits.filter(h => {
        try { const c = String(h && (h.code || h.shareCode || '')).toUpperCase(); return !seenCodes.has(c); } catch(_) { return true; }
    });

    // Combine live-first then central fallback entries
    let hitsArr = hitsFromLive.concat(mergedCentral);

    // Accept multiple intent variants produced by different producers/legacy shapes
    const isTargetHitIntent = (h) => {
        try {
            const intent = String(h && (h.intent || h.userIntent || '')).toLowerCase().trim();
            if (!intent) return false;
            if (intent === 'target-hit' || intent === 'target_hit' || intent === 'targethit' || intent === 'target hit') return true;
            if (/target[-_ ]?hit/.test(intent)) return true;
            if (intent.indexOf('target') !== -1 && intent.indexOf('hit') !== -1) return true;
            if (intent === 'target' && (h && (h.target != null))) return true;
            return false;
        } catch(_) { return false; }
    };
    const targetHits = hitsArr.filter(h => isTargetHitIntent(h));
    const otherHits = hitsArr.filter(h => !isTargetHitIntent(h));
    hitsArr = targetHits.concat(otherHits);
        // targetHitSharesList already cleared above
        if (!hitsArr.length) {
            const p = document.createElement('p'); p.className = 'no-alerts-message'; p.textContent = 'No custom triggers currently triggered.'; targetHitSharesList.appendChild(p);
        } else {
            const frag = document.createDocumentFragment();
            hitsArr.forEach(h => {
                try {
                    const code = String(h.code || h.shareCode || '').toUpperCase();
                    const name = sanitizeCompanyName(h.name || h.companyName || code, code);
                    const intent = (h.intent || '').toLowerCase();
                    const dir = (h.direction || '').toLowerCase();
                    let liveVal = (h.live!=null && !isNaN(Number(h.live))) ? Number(h.live) : null;
                    const targetVal = (h.target!=null && !isNaN(Number(h.target))) ? Number(h.target) : null;

                    // Prefer known live price; fallback to global caches
                    if (liveVal == null && window.livePrices && window.livePrices[code] && window.livePrices[code].live != null) {
                        try { liveVal = Number(window.livePrices[code].live); } catch(_) {}
                    }

                    // For duplicated 52-week entries, render using the compact notification card layout
                    if (intent === '52w-low' || intent === '52w-high') {
                        // Robust 52-week lookup: prefer centralized hits, then livePrices (many variants), then legacy global alerts, then allSharesData.
                        let hi = null, lo = null;
                        try {
                            // 1) Centralized computed hits (preferred)
                            const gh = window.globalHiLo52Hits || {};
                            const lowArr = Array.isArray(gh.lowHits) ? gh.lowHits : [];
                            const highArr = Array.isArray(gh.highHits) ? gh.highHits : [];
                            const foundLow = lowArr.find(e => String(e.code || e.shareCode || e.shareName || '').toUpperCase() === code);
                            const foundHigh = highArr.find(e => String(e.code || e.shareCode || e.shareName || '').toUpperCase() === code);
                            const src = (intent === '52w-low') ? (foundLow || foundHigh) : (foundHigh || foundLow);
                            if (src) {
                                const pickNum = (obj, ...keys) => {
                                    for (const k of keys) {
                                        try { if (obj && obj[k] != null && !isNaN(Number(obj[k]))) return Number(obj[k]); } catch(_) {}
                                    }
                                    return null;
                                };
                                hi = pickNum(src, 'high52', 'High52', 'hi52', 'high', 'High');
                                lo = pickNum(src, 'low52', 'Low52', 'lo52', 'low', 'Low');
                                if (liveVal == null) {
                                    const liveCandidate = pickNum(src, 'live', 'Live', 'lastLivePrice');
                                    if (liveCandidate != null) liveVal = liveCandidate;
                                }
                            }

                            // 2) If still missing, inspect livePrices for multiple possible field names
                            if ((hi == null || lo == null) && window.livePrices && window.livePrices[code]) {
                                const lp = window.livePrices[code];
                                const pickNum = (obj, ...keys) => {
                                    for (const k of keys) {
                                        try { if (obj && typeof obj === 'object' && obj[k] != null && !isNaN(Number(obj[k]))) return Number(obj[k]); } catch(_) {}
                                    }
                                    return null;
                                };
                                if (hi == null) hi = pickNum(lp, 'high52', 'High52', 'hi52', 'high', 'High');
                                if (lo == null) lo = pickNum(lp, 'low52', 'Low52', 'lo52', 'low', 'Low');
                                if (liveVal == null) {
                                    const lv = pickNum(lp, 'live', 'Live', 'lastLivePrice'); if (lv != null) liveVal = lv;
                                }
                            }

                            // 3) Fallback: legacy globalHiLo52Alerts structure
                            if ((hi == null || lo == null) && window.globalHiLo52Alerts) {
                                try {
                                    const highs = Array.isArray(window.globalHiLo52Alerts.highs) ? window.globalHiLo52Alerts.highs : [];
                                    const lows = Array.isArray(window.globalHiLo52Alerts.lows) ? window.globalHiLo52Alerts.lows : [];
                                    const foundLow2 = lows.find(e => String(e.code || e.shareCode || '').toUpperCase() === code);
                                    const foundHigh2 = highs.find(e => String(e.code || e.shareCode || '').toUpperCase() === code);
                                    const src2 = (intent === '52w-low') ? (foundLow2 || foundHigh2) : (foundHigh2 || foundLow2);
                                    if (src2) {
                                        const pickNum = (obj, ...keys) => { for (const k of keys) { try { if (obj && obj[k] != null && !isNaN(Number(obj[k]))) return Number(obj[k]); } catch(_){} } return null; };
                                        if (hi == null) hi = pickNum(src2, 'high52', 'High52', 'hi52', 'high', 'High');
                                        if (lo == null) lo = pickNum(src2, 'low52', 'Low52', 'lo52', 'low', 'Low');
                                    }
                                } catch(_) {}
                            }

                            // 4) Final fallback: check allSharesData for stored hi/lo fields
                            if ((hi == null || lo == null) && Array.isArray(allSharesData)) {
                                try {
                                    const found = allSharesData.find(s => String((s && (s.shareName || s.code || '') )).toUpperCase() === code);
                                    if (found) {
                                        const pickNum = (obj, ...keys) => { for (const k of keys) { try { if (obj && obj[k] != null && !isNaN(Number(obj[k]))) return Number(obj[k]); } catch(_){} } return null; };
                                        if (hi == null) hi = pickNum(found, 'high52', 'High52', 'hi52', 'high', 'High');
                                        if (lo == null) lo = pickNum(found, 'low52', 'Low52', 'lo52', 'low', 'Low');
                                    }
                                } catch(_) {}
                            }

                            if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
                                try { console.debug('[52W-DEBUG] code=', code, 'hi=', hi, 'lo=', lo, 'liveVal=', liveVal, 'srcCentral=', src, 'lp=', window.livePrices && window.livePrices[code]); } catch(_) {}
                            }
                        } catch(_) {}

                        const card = document.createElement('div');
                        // Use notification-card for consistent compact layout; add hilo-card + low/high accent
                        const hiloClass = (intent === '52w-low') ? 'low' : 'high';
                        card.className = 'notification-card custom-trigger-card hilo-card ' + hiloClass;
                        const liveDisp = (liveVal!=null) ? ('$' + formatAdaptivePrice(liveVal)) : '<span class="na">N/A</span>';
                        const loHtml = (lo!=null) ? ('$' + formatAdaptivePrice(lo)) : '?';
                        const hiHtml = (hi!=null) ? ('$' + formatAdaptivePrice(hi)) : '?';
                        card.innerHTML = `
                            <div class="notification-card-row">
                                <div class="notification-card-left">
                                    <div class="notification-code">${code}</div>
                                    <div class="notification-name small">${name}</div>
                                </div>
                                <div class="notification-card-right">
                                    <div class="notification-live">${liveDisp}</div>
                                </div>
                            </div>
                            <div class="notification-card-bottom">
                                <div class="hilo-details"><strong>52W Low:</strong> ${loHtml} &nbsp; <strong>High:</strong> ${hiHtml}</div>
                            </div>`;
                        card.addEventListener('click', ()=>{ try{ hideModal(targetHitDetailsModal); }catch(_){} openShareOrSearch(code); });
                        frag.appendChild(card);
                        return; // done with 52w card
                    }

                    // Default rendering for other custom triggers (e.g., target-hit, mover duplicates)
                    const card = document.createElement('div');
                    // Base compact card
                    let classNames = ['notification-card','custom-trigger-card'];
                    // Add left-accent for mover duplicates
                    if (intent === 'mover') {
                        classNames.push('mover-card');
                        if (dir === 'up' || dir === 'down') classNames.push(dir);
                    }
                    // Add left-accent for target-hit entries
                    if (intent === 'target-hit') {
                        classNames.push('target-hit-accent');
                        // Map intent/direction to classes so CSS can set red/green correctly
                        const uiRaw = (h.userIntent || '').toString().trim().toLowerCase();
                        const isBuy = uiRaw.includes('buy');
                        const isSell = uiRaw.includes('sell');
                        if (isBuy) classNames.push('intent-buy');
                        else if (isSell) classNames.push('intent-sell');
                        // Direction classes for color mapping fallbacks
                        if (dir === 'above' || dir === 'below') classNames.push('dir-' + dir);
                        // As an additional safeguard, set the CSS variable directly when we can infer mapping
                        // Priority (most common): Buy Below -> red, Sell Above -> green
                        try {
                            if (isBuy && dir === 'below') {
                                card.style.setProperty('--target-hit-border-color', 'var(--negative,#d9534f)');
                            } else if (isSell && dir === 'above') {
                                card.style.setProperty('--target-hit-border-color', 'var(--positive,#0a8a00)');
                            } else if (!uiRaw && (dir === 'below' || dir === 'above')) {
                                // If userIntent missing, fall back to direction semantics
                                card.style.setProperty('--target-hit-border-color', dir === 'below' ? 'var(--negative,#d9534f)' : 'var(--positive,#0a8a00)');
                            }
                        } catch(_) {}
                    }
                    card.className = classNames.join(' ');
                    const liveDisp = (liveVal!=null) ? ('$' + formatAdaptivePrice(liveVal)) : '<span class="na">N/A</span>';
                    const tgtDisp = (targetVal!=null) ? ('$' + formatAdaptivePrice(targetVal)) : '';
                    const userIntent = (h.userIntent || '').toString().trim();
                    // Build a human-friendly, de-emphasized meta line
                    const prettyUserIntent = (function(){
                        if (!userIntent) return '';
                        const ui = userIntent.toLowerCase();
                        if (ui.includes('buy') && ui.includes('below')) return 'Buy below';
                        if (ui.includes('sell') && ui.includes('above')) return 'Sell above';
                        if (ui.includes('buy') && ui.includes('above')) return 'Buy above';
                        if (ui.includes('sell') && ui.includes('below')) return 'Sell below';
                        // Fallback: title case raw
                        return ui.replace(/[-_]+/g,' ').replace(/\b\w/g, c => c.toUpperCase());
                    })();
                    const meta = (intent === 'target-hit')
                        ? ['Target hit', prettyUserIntent].filter(Boolean).join(' · ')
                        : [intent?intent.toUpperCase():'', dir?dir.toUpperCase():'', userIntent?userIntent.toUpperCase():''].filter(Boolean).join(' · ');
                    card.innerHTML = `
                        <div class="notification-card-row">
                            <div class="notification-card-left">
                                <div class="notification-code">${code}</div>
                                <div class="notification-name small">${name}</div>
                            </div>
                            <div class="notification-card-right">
                                <div class="notification-live">${liveDisp}</div>
                            </div>
                        </div>
                        <div class="notification-card-bottom">
                            ${tgtDisp?`<div class="target-line"><span class="label">Target:</span> ${tgtDisp}</div>`:''}
                            ${meta?`<div class="meta-line">${meta}</div>`:''}
                        </div>`;
                    card.addEventListener('click', ()=>{ try{ hideModal(targetHitDetailsModal); }catch(_){} openShareOrSearch(code); });
                    frag.appendChild(card);
                } catch(e) { /* skip malformed hit */ }
            });
            targetHitSharesList.appendChild(frag);
        }
    } catch(e) { console.warn('[CustomTriggers] render failed', e); }

    // Show the modal now and exit. Legacy local target list UI has been removed in favor of persistent CUSTOM_TRIGGER_HITS.
    try { showModal(targetHitDetailsModal); } catch(_) {}
    try { __userInitiatedTargetModal = true; } catch(_) {}
    try { logDebug('Notifications modal displayed (Custom Triggers + centralized sections).'); } catch(_) {}
    return;

    // Inject explainer headers for each notifications section
    try {
        const accordion = document.getElementById('notificationsAccordion');
        if (accordion) {
            function ensureExplainer(sectionKey, textBuilder, onClick) {
                const sec = accordion.querySelector(`.accordion-section[data-section="${sectionKey}"]`);
                if (!sec) return;
                const panel = sec.querySelector('.accordion-panel'); if (!panel) return;
                let expl = panel.querySelector('.section-explainer');
                if (!expl) {
                    expl = document.createElement('div');
                    expl.className = 'section-explainer';
                    expl.setAttribute('role', 'button');
                    expl.tabIndex = 0;
                    panel.prepend(expl);
                }
                expl.textContent = textBuilder();
                expl.title = 'Click to configure related settings';
                if (!expl.__bound) {
                    expl.addEventListener('click', (e)=>{ try { if (typeof onClick === 'function') onClick(e); } catch(_) {} });
                    expl.addEventListener('keydown', (e)=>{
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            try { if (typeof onClick === 'function') onClick(e); } catch(_) {}
                        }
                    });
                    expl.__bound = true;
                }
            }
            const toNum = (v)=>{ const n = Number(v); return (v!=null && isFinite(n) && n>0) ? n : null; };
            const fmtMoney = (n)=>{
                const v = toNum(n); if (v==null) return 'Not set';
                if (v>=1e9) return '$'+(v/1e9).toFixed(1)+'B';
                if (v>=1e6) return '$'+(v/1e6).toFixed(1)+'M';
                if (v>=1e3) return '$'+(v/1e3).toFixed(1)+'K';
                return '$'+v.toFixed(2);
            };
            const pctPart = (v)=>{ const n = toNum(v); return (n!=null) ? (n.toFixed(0)+'%') : 'Not set'; };
            const dolPart = (v)=>{ const n = toNum(v); return (n!=null) ? ('$'+n.toFixed(2)) : 'Not set'; };
            const minPricePart = (v)=>{ const n = toNum(v); return (n!=null) ? ('$'+n.toFixed(2)) : 'Not set'; };

            // Target Hits (local alerts use user per-share targets)
            ensureExplainer('target-hits', ()=>'Your per-share alert targets (Buy/Sell, Above/Below).', ()=>{
                try { if (typeof hideModal==='function') hideModal(targetHitDetailsModal); } catch(_) {}
                // Open the Global Alerts modal directly
                try {
                    if (typeof showModal === 'function') {
                        if (!globalAlertsModal) { try { globalAlertsModal = document.getElementById('globalAlertsModal'); } catch(_) {} }
                        if (globalAlertsModal) {
                            showModal(globalAlertsModal);
                            try { if (globalPercentIncreaseInput) globalPercentIncreaseInput.focus(); } catch(_) {}
                        }
                    }
                } catch(_){ }
            });

            // Global gainers/losers based on directional thresholds
            ensureExplainer('global-gainers', ()=>{
                const base = (typeof window.getCurrentDirectionalThresholds==='function') ? window.getCurrentDirectionalThresholds() : {
                    upPercent: window.globalPercentIncrease, upDollar: window.globalDollarIncrease, minimumPrice: window.globalMinimumPrice
                };
                const eff = (window.globalMovers && (window.globalMovers.__effectiveThresholds || window.globalMovers.thresholds)) || null;
                const upPct = (toNum(base.upPercent)!=null) ? toNum(base.upPercent) : (eff ? toNum(eff.upPercent) : null);
                const upDol = (toNum(base.upDollar)!=null) ? toNum(base.upDollar) : (eff ? toNum(eff.upDollar) : null);
                const minP = (toNum(base.minimumPrice)!=null) ? toNum(base.minimumPrice) : (eff ? toNum(eff.minimumPrice) : null);
                const parts = [];
                if (upPct!=null) parts.push(upPct.toFixed(0) + '%');
                if (upDol!=null) parts.push('$' + upDol.toFixed(2));
                const incStr = parts.length ? parts.join(' or ') : 'Not set';
                return `Increase ≥ ${incStr} | Min Price: ${minPricePart(minP)}`;
            }, ()=>{
                try { if (typeof hideModal==='function') hideModal(targetHitDetailsModal); } catch(_) {}
                try {
                    if (!globalAlertsModal) { try { globalAlertsModal = document.getElementById('globalAlertsModal'); } catch(_) {} }
                    if (typeof showModal === 'function' && globalAlertsModal) {
                        showModal(globalAlertsModal);
                        try { if (globalPercentIncreaseInput) globalPercentIncreaseInput.focus(); } catch(_) {}
                    }
                } catch(_){ }
            });
            ensureExplainer('global-losers', ()=>{
                const base = (typeof window.getCurrentDirectionalThresholds==='function') ? window.getCurrentDirectionalThresholds() : {
                    downPercent: window.globalPercentDecrease, downDollar: window.globalDollarDecrease, minimumPrice: window.globalMinimumPrice
                };
                const eff = (window.globalMovers && (window.globalMovers.__effectiveThresholds || window.globalMovers.thresholds)) || null;
                const downPct = (toNum(base.downPercent)!=null) ? toNum(base.downPercent) : (eff ? toNum(eff.downPercent) : null);
                const downDol = (toNum(base.downDollar)!=null) ? toNum(base.downDollar) : (eff ? toNum(eff.downDollar) : null);
                const minP = (toNum(base.minimumPrice)!=null) ? toNum(base.minimumPrice) : (eff ? toNum(eff.minimumPrice) : null);
                const parts = [];
                if (downPct!=null) parts.push(downPct.toFixed(0) + '%');
                if (downDol!=null) parts.push('$' + downDol.toFixed(2));
                const decStr = parts.length ? parts.join(' or ') : 'Not set';
                return `Decrease ≥ ${decStr} | Min Price: ${minPricePart(minP)}`;
            }, ()=>{
                try { if (typeof hideModal==='function') hideModal(targetHitDetailsModal); } catch(_) {}
                try {
                    if (!globalAlertsModal) { try { globalAlertsModal = document.getElementById('globalAlertsModal'); } catch(_) {} }
                    if (typeof showModal === 'function' && globalAlertsModal) {
                        showModal(globalAlertsModal);
                        try { const el = document.getElementById('globalPercentDecrease'); if (el) el.focus(); } catch(_) {}
                    }
                } catch(_){ }
            });

            // 52W High/Low: include Min Price and Min Market Cap
            ensureExplainer('high52', ()=>{
                const mp = hiLoMinimumPrice; const mc = hiLoMinimumMarketCap;
                // List thresholds only; remove any 'Scope All ASX' wording
                const parts = [];
                parts.push(`Min Price: ${minPricePart(mp)}`);
                parts.push(`Min Mkt Cap: ${fmtMoney(mc)}`);
                return parts.join(' | ');
            }, ()=>{ 
                try { if (typeof hideModal==='function') hideModal(targetHitDetailsModal); } catch(_) {}
                try {
                    if (!globalAlertsModal) { try { globalAlertsModal = document.getElementById('globalAlertsModal'); } catch(_) {} }
                    if (typeof showModal === 'function' && globalAlertsModal) {
                        showModal(globalAlertsModal);
                        try { const el = document.getElementById('hiLoMinimumPrice'); if (el) el.focus(); } catch(_) {}
                    }
                } catch(_){ }
            });
            ensureExplainer('low52', ()=>{
                const mp = hiLoMinimumPrice; const mc = hiLoMinimumMarketCap;
                const parts = [];
                parts.push(`Min Price: ${minPricePart(mp)}`);
                parts.push(`Min Mkt Cap: ${fmtMoney(mc)}`);
                return parts.join(' | ');
            }, ()=>{ 
                try { if (typeof hideModal==='function') hideModal(targetHitDetailsModal); } catch(_) {}
                try {
                    if (!globalAlertsModal) { try { globalAlertsModal = document.getElementById('globalAlertsModal'); } catch(_) {} }
                    if (typeof showModal === 'function' && globalAlertsModal) {
                        showModal(globalAlertsModal);
                        try { const el = document.getElementById('hiLoMinimumPrice'); if (el) el.focus(); } catch(_) {}
                    }
                } catch(_){ }
            });
        }
    } catch(e) { console.warn('[Notifications] Failed to add explainer headers', e); }

    // Add Global 52-Week sections (legacy fallback) — SKIPPED when modern renderer already populated containers
    try {
        const skipLegacyGlobalHiLo = !!(targetHitDetailsModal && targetHitDetailsModal.__newGlobalRendered);
        if (!skipLegacyGlobalHiLo) {
            const hiLo = (window.globalHiLo52Alerts && Array.isArray(window.globalHiLo52Alerts.lows)) ? window.globalHiLo52Alerts : null;
            const lows = hiLo ? hiLo.lows : [];
            if (lows && lows.length) {
                const list = document.getElementById('globalLow52Container') || (function(){ const el=document.createElement('div'); el.id='globalLow52Container'; return el; })();
                lows.forEach(entry => {
                    const card = document.createElement('div');
                    card.className = 'low52-alert-card low52-low';
                    const code = String(entry.code || entry.shareCode || '').toUpperCase();
                    const name = entry.name || entry.companyName || code;
                    const live = (entry.live!=null? Number(entry.live) : (livePrices && livePrices[code] ? Number(livePrices[code].live) : null));
                    const hi = (entry.high52!=null? Number(entry.high52) : (entry.High52!=null? Number(entry.High52) : null));
                    const lo = (entry.low52!=null? Number(entry.low52) : (entry.Low52!=null? Number(entry.Low52) : null));
                    card.innerHTML = `
                        <div class="low52-card-row low52-header-row">
                            <span class="low52-code">${code}</span>
                            <span class="low52-name">${sanitizeCompanyName(name, code)}</span>
                            <span class="low52-price">${live!=null?('$'+formatAdaptivePrice(live)):'<span class="low52-price-na">N/A</span>'}</span>
                        </div>
                        <div class="low52-thresh-row">
                            <span class="low52-thresh"><strong>52W Low:</strong> ${lo!=null?'$'+formatAdaptivePrice(lo):'?'} &nbsp; <strong>High:</strong> ${hi!=null?'$'+formatAdaptivePrice(hi):'?'} </span>
                        </div>`;
                    // Click opens search modal for the code
                    card.addEventListener('click', ()=>{
                        try { hideModal(targetHitDetailsModal); } catch(_) {}
                        openStockSearchForCode(code);
                    });
                    list.appendChild(card);
                });
            }
            // Add Global 52-Week Highs section (centralized)
            const highs = (window.globalHiLo52Alerts && Array.isArray(window.globalHiLo52Alerts.highs)) ? window.globalHiLo52Alerts.highs : [];
            if (highs && highs.length) {
                const list2 = document.getElementById('globalHigh52Container') || (function(){ const el=document.createElement('div'); el.id='globalHigh52Container'; return el; })();
                highs.forEach(entry => {
                    const card = document.createElement('div');
                    card.className = 'low52-alert-card low52-high';
                    const code = String(entry.code || entry.shareCode || '').toUpperCase();
                    const name = entry.name || entry.companyName || code;
                    const live = (entry.live!=null? Number(entry.live) : (livePrices && livePrices[code] ? Number(livePrices[code].live) : null));
                    const hi = (entry.high52!=null? Number(entry.high52) : (entry.High52!=null? Number(entry.High52) : null));
                    const lo = (entry.low52!=null? Number(entry.low52) : (entry.Low52!=null? Number(entry.Low52) : null));
                    card.innerHTML = `
                        <div class="low52-card-row low52-header-row">
                            <span class="low52-code">${code}</span>
                            <span class="low52-name">${sanitizeCompanyName(name, code)}</span>
                            <span class="low52-price">${live!=null?('$'+formatAdaptivePrice(live)):'<span class="low52-price-na">N/A</span>'}</span>
                        </div>
                        <div class="low52-thresh-row">
                            <span class="low52-thresh"><strong>52W Low:</strong> ${lo!=null?'$'+formatAdaptivePrice(lo):'?'} &nbsp; <strong>High:</strong> ${hi!=null?'$'+formatAdaptivePrice(hi):'?'} </span>
                        </div>`;
                    // Click opens search modal for the code
                    card.addEventListener('click', ()=>{
                        try { hideModal(targetHitDetailsModal); } catch(_) {}
                        openStockSearchForCode(code);
                    });
                    list2.appendChild(card);
                });
            }
        }
    } catch(e) { console.warn('[HiLo52] Failed to render global section', e); }

    // Inject headings + global summary card (legacy fallback) — SKIPPED when modern renderer already populated movers UI
    (function(){
        const skipLegacyGlobalSummary = !!(targetHitDetailsModal && targetHitDetailsModal.__newGlobalRendered);
        if (skipLegacyGlobalSummary) return;
        // Only show global summary if thresholds still active to avoid displaying stale counts after clear
        // Priority: Check for comprehensive scan results first, then fall back to regular scan
        let data = null;
        let isComprehensive = false;

        if (isDirectionalThresholdsActive()) {
            // First check for comprehensive scan results (GA_SUMMARY_COMPREHENSIVE)
            if (globalAlertSummary && globalAlertSummary.comprehensiveScan === true && globalAlertSummary.totalCount > 0) {
                data = globalAlertSummary;
                isComprehensive = true;
                console.log('[GlobalAlerts] Using COMPREHENSIVE scan results:', data);
            }
            // Fall back to regular scan results (GA_SUMMARY)
            else if (globalAlertSummary && globalAlertSummary.totalCount > 0) {
                data = globalAlertSummary;
                isComprehensive = false;
                console.log('[GlobalAlerts] Using REGULAR scan results:', data);
            }
        }

        const hasGlobalSummary = !!data;
        console.log('[GlobalAlerts] Modal render - hasGlobalSummary:', hasGlobalSummary, 'isComprehensive:', isComprehensive, 'isDirectionalThresholdsActive:', isDirectionalThresholdsActive(), 'globalAlertSummary:', globalAlertSummary);

        if (hasGlobalSummary) {
            const total = data.totalCount || 0;
            const inc = data.increaseCount || 0;
            const dec = data.decreaseCount || 0;
            const threshold = data.threshold || '';
            const portfolioCount = data.portfolioCount || 0;
            const discoverCount = Array.isArray(data.nonPortfolioCodes) ? data.nonPortfolioCodes.length : 0;
            const enabled = (data.enabled !== false);
            const containerHost = document.getElementById('globalMoversContainer') || targetHitSharesList; // fallback
            const container = document.createElement('div');
            container.classList.add('target-hit-item','global-summary-alert');
            const minText = (data.appliedMinimumPrice && data.appliedMinimumPrice > 0) ? `Ignoring < $${Number(data.appliedMinimumPrice).toFixed(2)}` : '';
            const arrowsRow = `<div class=\"global-summary-arrows-row\"><span class=\"up\"><span class=\"arrow\">&#9650;</span> <span class=\"arrow-count\">${inc}</span></span><span class=\"down\"><span class=\"arrow\">&#9660;</span> <span class=\"arrow-count\">${dec}</span></span></div>`;
            container.innerHTML = `
                <div class="global-summary-inner">
                    ${arrowsRow}
                    <div class="global-summary-detail total-line">${total} shares moved ${threshold ? ('≥ ' + threshold) : ''}${isComprehensive && data.totalSharesScanned ? (' (scanned ' + data.totalSharesScanned + ' total)') : ''}</div>
                    <div class="global-summary-detail portfolio-line">${portfolioCount} from your portfolio</div>
                    ${minText ? ('<div class=\"global-summary-detail ignoring-line\">' + minText + '</div>') : ''}
                </div>
                <div class=\"global-summary-actions\">
                    <button data-action=\"discover\" ${discoverCount?'':'disabled'}>${discoverCount?`Global (${discoverCount})`:'View All'}</button>
                    <button data-action=\"view-portfolio\" ${portfolioCount?'':'disabled'}>${portfolioCount?`Local (${portfolioCount})`:'Local'}</button>
                    <button data-action=\"mute-global\" title=\"${enabled ? 'Mute Global Alert' : 'Unmute Global Alert'}\">${enabled ? 'Mute' : 'Unmute'}</button>
                </div>`;
            const actions = container.querySelector('.global-summary-actions');
            if (actions) {
                actions.addEventListener('click', (e)=>{
                    const btn = e.target.closest('button'); if (!btn) return;
                    const act = btn.getAttribute('data-action');
                    if (act === 'view-portfolio') {
                        try {
                            // Show local/portfolio shares that met global criteria
                            openLocalSharesModal(data);
                        } catch(e){ console.warn('Local shares modal open failed', e); }
                    } else if (act === 'discover') {
                        try {
                            // Ensure we have the latest movers data before opening the modal
                            applyGlobalSummaryFilter({ silent: true, computeOnly: true });
                            setTimeout(() => {
                                openDiscoverModal(data);
                            }, 100); // Small delay to allow snapshot to be created
                        } catch(e){ console.warn('Discover modal open failed', e); }
                    } else if (act === 'mute-global') {
                        e.preventDefault();
                        toggleGlobalSummaryEnabled();
                    }
                });
            }
            containerHost.appendChild(container);
        }
    })();

    async function openDiscoverModal(summaryData) {
        let modal = document.getElementById('discoverGlobalModal');
        if (!modal) { console.warn('Discover modal element missing.'); return; }
        
        // Fetch live prices for global shares if not already available
        console.log('[DiscoverModal] Checking if we need to fetch live prices for global shares...');
        const globalCodes = summaryData?.nonPortfolioCodes || [];
        const missingCodes = globalCodes.filter(code => !livePrices[code]);
        
        if (missingCodes.length > 0) {
            console.log(`[DiscoverModal] Fetching live prices for ${missingCodes.length} global shares:`, missingCodes.slice(0, 10));
            try {
                // Temporarily add global codes to the needed set for fetching
                const originalNeeded = window._globalNeededCodes;
                window._globalNeededCodes = new Set([...missingCodes]);
                await fetchLivePrices({ cacheBust: true });
                window._globalNeededCodes = originalNeeded;
                console.log('[DiscoverModal] Live prices fetched for global shares');
            } catch (error) {
                console.warn('[DiscoverModal] Failed to fetch live prices for global shares:', error);
            }
        }
        const listEl = modal.querySelector('#discoverGlobalList');
        if (listEl) {
            const summary = summaryData || globalAlertSummary || {};

            // Update modal title for global shares
            const titleEl = modal.querySelector('.modal-title');
            if (titleEl) {
                titleEl.textContent = 'Global Movers (All ASX)';
            }
            // Persist last summary for re-sorts
            try { window.__lastDiscoverSummaryData = summary; } catch(_) {}
            console.log('[DiscoverModal] Opening global shares modal');
            const nonPortfolioCodes = Array.isArray(summary.nonPortfolioCodes) ? summary.nonPortfolioCodes : [];
            const threshold = (typeof summary.threshold === 'number') ? summary.threshold : null;
            const appliedMinimumPrice = summary.appliedMinimumPrice;
            const codeSet = new Set(nonPortfolioCodes.map(c => (c || '').toUpperCase()));
            const snapshot = (window.__lastMoversSnapshot && Array.isArray(window.__lastMoversSnapshot.entries)) ? window.__lastMoversSnapshot : null;
            const externalRows = Array.isArray(globalExternalPriceRows) ? globalExternalPriceRows : [];


            // Build global criteria badges (percent / dollar up+down thresholds + min price)
            function buildCriteriaBadges() {
                const badges = [];
                // Prefer server thresholds when client-side values are absent so the UI still shows what's applied
                const serverThresholds = (gm && gm.__serverThresholds) ? gm.__serverThresholds : null;
                const upPct = (typeof globalPercentIncrease === 'number' && globalPercentIncrease>0) ? globalPercentIncrease : (serverThresholds && serverThresholds.upPercent) ? serverThresholds.upPercent : null;
                const upDol = (typeof globalDollarIncrease === 'number' && globalDollarIncrease>0) ? globalDollarIncrease : (serverThresholds && serverThresholds.upDollar) ? serverThresholds.upDollar : null;
                const dnPct = (typeof globalPercentDecrease === 'number' && globalPercentDecrease>0) ? globalPercentDecrease : (serverThresholds && serverThresholds.downPercent) ? serverThresholds.downPercent : null;
                const dnDol = (typeof globalDollarDecrease === 'number' && globalDollarDecrease>0) ? globalDollarDecrease : (serverThresholds && serverThresholds.downDollar) ? serverThresholds.downDollar : null;
                if (upPct) badges.push({ cls:'up', text:'▲ ≥ '+upPct+'%' });
                if (upDol) badges.push({ cls:'up', text:'▲ ≥ $'+upDol });
                if (dnPct) badges.push({ cls:'down', text:'▼ ≥ '+dnPct+'%' });
                if (dnDol) badges.push({ cls:'down', text:'▼ ≥ $'+dnDol });
                if (appliedMinimumPrice) badges.push({ cls:'min', text:'Min $'+Number(appliedMinimumPrice).toFixed(2) });
                return badges;
            }
            const criteriaBadges = buildCriteriaBadges();
            const lastUpdatedTs = new Date().toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' });

            let entries = [];
            console.log('[DiscoverModal] Building entries from snapshot and codeSet...');
            console.log('[DiscoverModal] snapshot available:', !!snapshot);
            console.log('[DiscoverModal] snapshot entries count:', snapshot ? snapshot.entries.length : 0);
            console.log('[DiscoverModal] summary nonPortfolioCodes count:', summary && summary.nonPortfolioCodes ? summary.nonPortfolioCodes.length : 0);

            // For Global modal with comprehensive data, prioritize the comprehensive scan results
            if (summary && summary.nonPortfolioCodes && summary.nonPortfolioCodes.length > 0 && summary.comprehensiveScan) {
                console.log('[DiscoverModal] Using comprehensive scan non-portfolio codes for Global modal');
                entries = summary.nonPortfolioCodes.map(code => {
                    const lp = livePrices && livePrices[code.toUpperCase()];
                    if (!lp) return null;

                    return {
                        code: code,
                        name: lp.companyName || code,
                        pct: lp.prevClose ? ((lp.live - lp.prevClose) / lp.prevClose) * 100 : 0,
                        live: lp.live,
                        prevClose: lp.prevClose
                    };
                }).filter(Boolean);
                console.log('[DiscoverModal] Created entries from comprehensive scan:', entries.length);
            }
            // Fallback to snapshot if no comprehensive data or for regular scans
            else if (snapshot) {
                console.log('[DiscoverModal] Using snapshot entries for Global modal');
                entries = snapshot.entries.filter(e => {
                    const code = String(e.code || '').toUpperCase();
                    // Include both portfolio and non-portfolio shares that met the global criteria
                    return true; // Include all shares from the snapshot that met global criteria
                });
                console.log('[DiscoverModal] Created entries from snapshot:', entries.length);
            }

            // Fallback: if no snapshot entries, try to create from codeSet
            if (!entries.length && codeSet.size) {
                entries = Array.from(codeSet).map(c => ({ code: c }));
                console.log('[DiscoverModal] Created entries from codeSet:', entries.length);
            }

            // Final fallback: show non-portfolio shares from existing data
            if (!entries.length && summary && summary.totalCount > 0 && summary.nonPortfolioCodes && summary.nonPortfolioCodes.length > 0) {
                console.log('[DiscoverModal] Final fallback: using summary nonPortfolioCodes');
                entries = summary.nonPortfolioCodes.map(code => {
                    const lp = livePrices && livePrices[code.toUpperCase()];
                    if (!lp) return null;

                    return {
                        code: code,
                        name: lp.companyName || code,
                        pct: lp.prevClose ? ((lp.live - lp.prevClose) / lp.prevClose) * 100 : 0,
                        live: lp.live,
                        prevClose: lp.prevClose
                    };
                }).filter(Boolean);
                console.log('[DiscoverModal] Created entries from final fallback:', entries.length);
            }
            entries.sort((a,b)=> (Math.abs(b.pct||0)) - (Math.abs(a.pct||0)));

            listEl.innerHTML='';
            // Header / criteria bar
            const criteriaBar = document.createElement('div');
            criteriaBar.className = 'discover-criteria-bar';
            const titleSpan = document.createElement('span');
            titleSpan.className = 'criteria-title';
            // Show different title based on whether we have discoveries or just portfolio alerts
            const hasNonPortfolio = summary && summary.nonPortfolioCodes && summary.nonPortfolioCodes.length > 0;
            titleSpan.textContent = hasNonPortfolio ? 'Global Discoveries' : 'Global Alerts';
            const badgeContainer = document.createElement('div');
            badgeContainer.className = 'criteria-badges';
            if (criteriaBadges.length) {
                criteriaBadges.forEach(b => { const s=document.createElement('span'); s.className='criteria-badge '+b.cls; s.textContent=b.text; badgeContainer.appendChild(s); });
            } else {
                const none=document.createElement('span'); none.className='criteria-badge none'; none.textContent='No active thresholds'; badgeContainer.appendChild(none);
            }
            // Summary line (mirror sidebar Global Alerts summary)
            function buildGlobalAlertsSummaryInline(){
                try {
                    // Reuse formatting helper if present
                    const incPartLocal = (typeof formatGlobalAlertPart === 'function') ? formatGlobalAlertPart(globalPercentIncrease, globalDollarIncrease) : '';
                    const decPartLocal = (typeof formatGlobalAlertPart === 'function') ? formatGlobalAlertPart(globalPercentDecrease, globalDollarDecrease) : '';
                    // Prefer server-provided thresholds if available
                    const server = (window.globalMovers && window.globalMovers.__serverThresholds) ? window.globalMovers.__serverThresholds : null;
                    const incPart = (incPartLocal && incPartLocal !== 'Off') ? incPartLocal : (server ? (formatGlobalAlertPart(server.upPercent, server.upDollar) || '') : incPartLocal);
                    const decPart = (decPartLocal && decPartLocal !== 'Off') ? decPartLocal : (server ? (formatGlobalAlertPart(server.downPercent, server.downDollar) || '') : decPartLocal);
                    const anyActive = (incPart && incPart !== 'Off') || (decPart && decPart !== 'Off') || (typeof globalMinimumPrice === 'number' && globalMinimumPrice>0);
                    if (!anyActive) return '';
                    const minPart = (typeof globalMinimumPrice === 'number' && globalMinimumPrice>0) ? ('Min: $' + Number(globalMinimumPrice).toFixed(2) + ' | ') : '';
                    return minPart + 'Increase: ' + incPart + ' | Decrease: ' + decPart;
                } catch(err){ console.warn('Global alerts inline summary build failed', err); return ''; }
            }
            const inlineSummary = buildGlobalAlertsSummaryInline();
            const tsSpan = document.createElement('span'); tsSpan.className='criteria-timestamp'; tsSpan.textContent = lastUpdatedTs;
            criteriaBar.appendChild(titleSpan);
            criteriaBar.appendChild(badgeContainer);

            // Make the Global Movers criteria bar clickable to open Global Alerts settings
            criteriaBar.title = 'Click to configure Global Alerts settings';
            criteriaBar.addEventListener('click', () => {
                // Close the Discover Moving Shares modal
                hideModal(modal);
                // Open the sidebar
                toggleAppSidebar(true);
                // Open the Global Alerts modal
                setTimeout(() => {
                    showModal(globalAlertsModal);
                }, 300); // Small delay to ensure sidebar animation completes
            });
            if (inlineSummary) {
                const summarySpan = document.createElement('span');
                summarySpan.className = 'criteria-summary';
                summarySpan.textContent = inlineSummary;
                criteriaBar.appendChild(summarySpan);
            }
            criteriaBar.appendChild(tsSpan);
            listEl.appendChild(criteriaBar);
            // Sorting controls (create once per render)
            const sortWrapper = document.createElement('div');
            sortWrapper.className = 'discover-sort-bar discover-sort-bar-centered';
            const sortSelect = document.createElement('select');
            sortSelect.id = 'discoverSortSelect';
            const SORT_OPTIONS = [
                { value:'code_asc', label:'A → Z' },
                { value:'price_desc', label:'Price ↓' },
                { value:'pct_asc', label:'Biggest Losers (% ↓)' },
                { value:'chg_asc', label:'Biggest Losers ($ ↓)' }
            ];
            const storedSort = (localStorage.getItem('discoverSort') || 'pct_desc');
            // Migrate old sort keys if present
            let initialSort = storedSort;
            if (initialSort === 'pct_desc') initialSort = 'pct_asc';
            if (initialSort === 'chg_desc') initialSort = 'chg_asc';
            SORT_OPTIONS.forEach(opt=>{
                const o = document.createElement('option'); o.value = opt.value; o.textContent = opt.label; if (opt.value===initialSort) o.selected = true; sortSelect.appendChild(o);
            });
            sortWrapper.appendChild(sortSelect);
            const sortDesc = document.createElement('div');
            sortDesc.className = 'discover-sort-desc';
            function sortModeDescription(v){
                switch(v){
                    case 'code_asc': return 'Alphabetical (A → Z)';
                    case 'price_desc': return 'Highest live price first';
                    case 'pct_asc': return 'Biggest losers by % (lowest to highest)';
                    case 'chg_asc': return 'Biggest losers by $ (lowest to highest)';
                    default: return '';
                }
            }
            sortDesc.textContent = sortModeDescription(storedSort);
            sortWrapper.appendChild(sortDesc);
            listEl.appendChild(sortWrapper);

            function applySort(list) {
                const mode = sortSelect.value;
                if (mode === 'code_asc') {
                    list.sort((a,b)=> (a.code||'').localeCompare(b.code||''));
                } else if (mode === 'price_desc') {
                    list.sort((a,b)=> ( (b._priceForSort ?? -Infinity) - (a._priceForSort ?? -Infinity) ) );
                } else if (mode === 'pct_asc') {
                    list.sort((a,b)=> ((a._pctForSort ?? 0) - (b._pctForSort ?? 0)) );
                } else if (mode === 'chg_asc') {
                    list.sort((a,b)=> ((a._chForSort ?? 0) - (b._chForSort ?? 0)) );
                }
            }
            const ul = document.createElement('ul');
            ul.className='discover-code-list enriched global-only card-layout';

            const contextLine = document.createElement('div');
            contextLine.className = 'discover-context-line discover-context-line-spaced';
            contextLine.innerHTML = `<strong>${nonPortfolioCodes.length}</strong> global ${nonPortfolioCodes.length===1?'share':'shares'} matched thresholds`;
            listEl.appendChild(contextLine);

            if (!entries.length) {
                const li=document.createElement('li'); li.className='ghosted-text'; li.textContent='No current global movers meeting threshold.'; ul.appendChild(li);
            } else {
                const missingCodes = [];
                entries.forEach(en => {
                    const code = (en.code || '').toUpperCase();
                    const lpData = (livePrices && livePrices[code]) ? livePrices[code] : {};
                    // Fallback: if no livePrices data, attempt to source from externalRows captured during last fetch
                    let ext = null;
                    if ((!lpData || lpData.live == null) && externalRows.length) {
                        ext = externalRows.find(r => r.code === code);
                    }
                    
                    // Debug logging for first few entries (temporarily enabled)
                    if (entries.indexOf(en) < 3) {
                        console.log(`[DiscoverModal] Entry ${entries.indexOf(en)}: ${code}`, {
                            hasLivePrice: !!(lpData && lpData.live != null),
                            livePricesSample: Object.keys(livePrices || {}).slice(0, 10)
                        });
                    }
                    // Map snapshot & external fields: live -> price fallback, change->ch
                    function num(v){ if (v===null||v===undefined||v==='') return null; const n=Number(v); return isNaN(n)?null:n; }
                    const price = num(en.price) ?? num(en.live) ?? num(lpData.live) ?? (ext?num(ext.live):null);
                    const prevClose = num(en.prevClose) ?? num(lpData.prevClose) ?? (ext?num(ext.prevClose):null);
                    let ch = num(en.ch) ?? num(en.change) ?? num(lpData.change);
                    // If change missing, derive from price/prev
                    if ((ch === null || ch === undefined) && price !== null && prevClose !== null) ch = price - prevClose;
                    let pct = num(en.pct) ?? num(lpData.pct);
                    if ((pct === null || pct === undefined) && ch !== null && prevClose !== null && prevClose !== 0) pct = (ch / prevClose) * 100;
                    const dir = (ch === null || ch === 0) ? 'flat' : (ch > 0 ? 'up' : 'down');
                    const colorClass = (ch === null || ch === 0) ? 'neutral' : (ch > 0 ? 'positive' : 'negative');
                    const li = document.createElement('li');
                    li.className = 'discover-mover dir-' + dir;
                    li.dataset.code = code;
                    let comboLine = 'No movement data yet';
                    if (ch != null && pct != null) {
                        comboLine = `${ch>0?'+':''}$${ch.toFixed(2)} / ${pct>0?'+':''}${pct.toFixed(2)}%`;
                    } else if (ch != null) {
                        comboLine = `${ch>0?'+':''}$${ch.toFixed(2)}`;
                    } else if (pct != null) {
                        comboLine = `${pct>0?'+':''}${pct.toFixed(2)}%`;
                    } else {
                        missingCodes.push(code);
                    }
                    if (DEBUG_MODE) console.log('[DiscoverItem]', code, { price, prevClose, ch, pct, raw: en, lpData, ext });
                    // Attach sort helper values directly for later resort without recompute
                    li._priceForSort = price;
                    li._pctForSort = pct;
                    li._chForSort = ch;
                    // Mirror onto original entry for initial sort function
                    en._priceForSort = price; en._pctForSort = pct; en._chForSort = ch;
                    // Company name (from allAsxCodes cache) & 52w range
                    let companyName = '';
                    try { if (Array.isArray(allAsxCodes)) { const m = allAsxCodes.find(c=>c.code===code); if (m && m.name) companyName = m.name; } } catch(_) {}
                    const hi52 = (lpData && lpData.High52!=null && !isNaN(lpData.High52)) ? '$'+formatAdaptivePrice(lpData.High52) : '';
                    const lo52 = (lpData && lpData.Low52!=null && !isNaN(lpData.Low52)) ? '$'+formatAdaptivePrice(lpData.Low52) : '';
                    const rangeLine = (hi52||lo52) ? `<div class=\"range-line\">${lo52||'?'}<span class=\"sep\">→</span>${hi52||'?'} 52w</div>` : '';
                    const priceLine = `<div class=\"price-line\">${price!=null?('$'+Number(price).toFixed(2)):'-'} ${comboLine?`<span class=\"movement-combo ${colorClass}\">${comboLine}</span>`:''}</div>`;

                    // Create a more structured layout with proper containers
                    li.innerHTML = `
                        <div class="discover-mover-content">
                            <div class="discover-mover-header">
                                <div class="row-top">
                                    <span class="code">${code}</span>
                                    ${companyName ? `<span class="company-name">${companyName}</span>` : ''}
                                </div>
                            </div>
                            <div class="discover-mover-details">
                                <div class="price-info">
                                    ${priceLine}
                                    ${rangeLine}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Debug logging for first few entries (temporarily enabled)
                    if (entries.indexOf(en) < 3) {
                        console.log(`[DiscoverModal] Rendered HTML for ${code}:`, {
                            price,
                            comboLine,
                            hasLivePrice: !!(lpData && lpData.live != null)
                        });
                    }
                    li.addEventListener('click',()=>{
                        try { hideModal(modal); } catch(_) {}
                        openShareOrSearch(code);
                    });
                    ul.appendChild(li);
                });
                // Async enrichment retry: if some codes missing data, schedule a one-off background refresh
                if (missingCodes.length) {
                    if (DEBUG_MODE) console.log('[Discover] Missing movement for', missingCodes.length, 'codes. Scheduling enrichment fetch.');
                    const now = Date.now();
                    if (!window.__discoverEnrichTs || (now - window.__discoverEnrichTs) > 4000) {
                        window.__discoverEnrichTs = now;
                        setTimeout(async ()=>{
                            try {
                                await fetchLivePrices({ cacheBust: true });
                                if (modal && modal.style.display !== 'none') {
                                    try { openDiscoverModal(summaryData); } catch(e){ console.warn('Discover enrichment refresh failed', e); }
                                }
                            } catch(e) { console.warn('Discover enrichment fetch error', e); }
                        }, 350);
                    }
                }
            }
            // Apply chosen sort to entries & reorder DOM if necessary
            try {
                applySort(entries);
                // Re-append in new order
                const ordered = entries.map(en => ul.querySelector('li.discover-mover[data-code="'+en.code+'"]')).filter(Boolean);
                ordered.forEach(li => ul.appendChild(li));
            } catch(e){ if (DEBUG_MODE) console.warn('Discover sort apply failed', e); }
            // Listen for sort changes
            sortSelect.addEventListener('change', () => {
                try { localStorage.setItem('discoverSort', sortSelect.value); } catch(_) {}
                // Re-sort using existing in-memory entries (with helper values)
                applySort(entries);
                const ordered = entries.map(en => ul.querySelector('li.discover-mover[data-code="'+en.code+'"]')).filter(Boolean);
                ordered.forEach(li => ul.appendChild(li));
                sortDesc.textContent = sortModeDescription(sortSelect.value);
            });
            listEl.appendChild(ul);
        }
        showModal(modal);
    }
    // Expose openDiscoverModal globally so other click handlers can call it safely
    try { window.openDiscoverModal = openDiscoverModal; } catch(_) {}

    // Function to show local/portfolio shares that met global criteria
    function openLocalSharesModal(summaryData) {
        let modal = document.getElementById('discoverGlobalModal');
        if (!modal) { console.warn('Local shares modal element missing.'); return; }
        const listEl = modal.querySelector('#discoverGlobalList');
        if (listEl) {
            const summary = summaryData || globalAlertSummary || {};
            console.log('[LocalModal] Opening local shares modal with summary:', summary);

            // Build portfolio codes set (recreate userCodes logic)
            const portfolioCodes = new Set();
            (allSharesData||[]).forEach(s => { if (s && s.shareName) portfolioCodes.add(s.shareName.toUpperCase()); });

            // Build local entries from live prices - only portfolio shares that met global criteria
            let entries = Object.entries(livePrices || {}).map(([code, lp]) => ({
                code: code,
                name: lp.companyName || code,
                pct: lp.prevClose ? ((lp.live - lp.prevClose) / lp.prevClose) * 100 : 0,
                live: lp.live,
                prevClose: lp.prevClose
            })).filter(entry => {
                const code = entry.code.toUpperCase();
                const isPortfolioShare = portfolioCodes.has(code);

                // Only include PORTFOLIO shares that would have triggered based on current thresholds
                if (!isPortfolioShare) {
                    return false; // Exclude non-portfolio shares from local view
                }

                const change = entry.live - entry.prevClose;
                const absChange = Math.abs(change);
                const triggered = (change > 0 && globalDollarIncrease && absChange >= globalDollarIncrease) ||
                                (change < 0 && globalDollarDecrease && absChange >= globalDollarDecrease);

                return triggered;
            });

            // Update modal title for local shares
            const titleEl = modal.querySelector('.modal-title');
            if (titleEl) {
                titleEl.textContent = 'Local Movers (Portfolio)';
            }

            listEl.innerHTML = '';

            if (entries.length === 0) {
                const contextLine = document.createElement('div');
                contextLine.className = 'discover-context-line discover-context-line-spaced';
                contextLine.innerHTML = `<strong>0</strong> portfolio shares matched global thresholds`;
                listEl.appendChild(contextLine);

                listEl.innerHTML += '<div class="no-shares-message">No portfolio shares currently meet your global alert criteria.</div>';
                showModal(modal);
                return;
            }

            // Sort by absolute percentage change
            entries.sort((a,b)=> (Math.abs(b.pct||0)) - (Math.abs(a.pct||0)));

            // Add context line showing count
            const contextLine = document.createElement('div');
            contextLine.className = 'discover-context-line discover-context-line-spaced';
            contextLine.innerHTML = `<strong>${entries.length}</strong> portfolio ${entries.length===1?'share':'shares'} matched global thresholds`;
            listEl.appendChild(contextLine);

            const ul = document.createElement('ul');
            ul.className = 'discover-code-list enriched global-only card-layout';

            entries.forEach(entry => {
                const li = document.createElement('li');
                li.className = 'discover-mover';
                li.dataset.code = entry.code;

                const change = entry.live - entry.prevClose;
                const pct = entry.pct;
                const isPositive = change > 0;
                const isNegative = change < 0;

                // Get 52-week range data if available
                const lpData = (livePrices && livePrices[entry.code]) ? livePrices[entry.code] : {};
                const hi52 = (lpData && lpData.High52!=null && !isNaN(lpData.High52)) ? '$'+formatAdaptivePrice(lpData.High52) : '';
                const lo52 = (lpData && lpData.Low52!=null && !isNaN(lpData.Low52)) ? '$'+formatAdaptivePrice(lpData.Low52) : '';
                const rangeLine = (hi52||lo52) ? `<div class="range-line">${lo52||'?'}<span class="sep">→</span>${hi52||'?'} 52w</div>` : '';
                const priceLine = `<div class="price-line">$${entry.live.toFixed(2)} <span class="movement-combo ${isPositive ? 'positive' : isNegative ? 'negative' : 'neutral'}">${change > 0 ? '+' : ''}$${change.toFixed(2)} (${pct > 0 ? '+' : ''}${pct.toFixed(2)}%)</span></div>`;

                // Use the same structured layout as Global modal
                li.innerHTML = `
                    <div class="discover-mover-content">
                        <div class="discover-mover-header">
                            <div class="row-top">
                                <span class="code">${entry.code}</span>
                                ${entry.name ? `<span class="company-name">${entry.name}</span>` : ''}
                            </div>
                        </div>
                        <div class="discover-mover-details">
                            <div class="price-info">
                                ${priceLine}
                                ${rangeLine}
                            </div>
                        </div>
                    </div>
                `;

                li.addEventListener('click', () => {
                    if (typeof selectShare === 'function') {
                        // Find the share ID for this code
                        const share = allSharesData.find(s => s.shareName && s.shareName.toUpperCase() === entry.code.toUpperCase());
                        if (share) {
                            hideModal(modal);
                            selectShare(share.id);
                            showShareDetails();
                        }
                    }
                });

                ul.appendChild(li);
            });

            listEl.appendChild(ul);
        }
        showModal(modal);
    }

    const makeItem = (share, isMuted) => {
        const livePriceData = livePrices[share.shareName.toUpperCase()] || {};
        const currentLivePrice = (livePriceData.live !== undefined && livePriceData.live !== null && !isNaN(livePriceData.live)) ? Number(livePriceData.live) : null;
        const prevClose = (livePriceData.prevClose !== undefined && livePriceData.prevClose !== null && !isNaN(livePriceData.prevClose)) ? Number(livePriceData.prevClose) : null;
        const targetPrice = share.targetPrice;
        // Determine configured direction; default to 'below' if unspecified
        const direction = (share && typeof share.targetDirection === 'string' && share.targetDirection.toLowerCase() === 'above') ? 'above' : 'below';
        const priceClass = (currentLivePrice !== null && targetPrice != null && !isNaN(targetPrice) && currentLivePrice >= targetPrice) ? 'positive' : 'negative';
        // Movement calculations (dollar + percent) for discover/target list items
        let movementDeltaHtml = '';
        let movementBorderColor = null; // prefer movement color for the left accent when available
        if (currentLivePrice !== null && prevClose !== null && prevClose !== 0) {
            const ch = currentLivePrice - prevClose;
            const pct = (ch / prevClose) * 100;
            const dirClass = ch === 0 ? 'neutral' : (ch > 0 ? 'positive' : 'negative');
            const combo = `${ch>0?'+':''}${ch.toFixed(2)} / ${pct>0?'+':''}${pct.toFixed(2)}%`;
            movementDeltaHtml = `<span class=\"movement-combo ${dirClass}\">${combo}</span>`;
            // pick border color by movement
            if (ch > 0) movementBorderColor = 'var(--brand-green)'; else if (ch < 0) movementBorderColor = 'var(--brand-red)';
        }
        const item = document.createElement('div');
        item.classList.add('target-hit-item');
        // This list only contains alerts that are currently hit; always show the accent
        item.classList.add('target-hit-accent');
        try {
            const color = movementBorderColor || (direction === 'above' ? 'var(--brand-green)' : 'var(--brand-red)');
            item.style.setProperty('--target-hit-border-color', color);
        } catch(_) {}
        if (isMuted) item.classList.add('muted');
        item.dataset.shareId = share.id;
        if (share.shareName) item.dataset.asxCode = share.shareName.toUpperCase();
        item.innerHTML = `
            <div class="target-hit-item-grid">
                <div class="col-left">
                    <span class="share-name-code ${priceClass}">${share.shareName}</span>
                    <span class="target-price-line alert-target-line">${renderAlertTargetInline(share,{showLabel:true})}</span>
                    ${movementDeltaHtml?`<div class=\"movement-line\">${movementDeltaHtml}</div>`:''}
                </div>
                <div class="col-right">
                    <span class="live-price-display ${priceClass}">${currentLivePrice !== null ? ('$' + formatAdaptivePrice(currentLivePrice)) : ''}</span>
                    <button class="toggle-alert-btn tiny-toggle" data-share-id="${share.id}" title="${isMuted ? 'Unmute Alert' : 'Mute Alert'}">${isMuted ? 'Unmute' : 'Mute'}</button>
                </div>
            </div>
        `;
        // Click to open share details
        item.addEventListener('click', (e) => {
            // If the click is on the toggle button, don't navigate
            if (e.target && e.target.classList && e.target.classList.contains('toggle-alert-btn')) return;
            const sid = item.dataset.shareId;
            if (sid) {
                wasShareDetailOpenedFromTargetAlerts = true;
                hideModal(targetHitDetailsModal);
                selectShare(sid);
                showShareDetails();
            }
            // Click-to-populate: trigger snapshot fetch/populate if shareNameInput present
            const code = item.dataset.asxCode;
            if (code && typeof updateAddFormLiveSnapshot === 'function') {
                try {
                    if (typeof shareNameInput !== 'undefined' && shareNameInput) {
                        // Populate input BEFORE snapshot so stale check passes
                        shareNameInput.value = code;
                    }
                    if (DEBUG_MODE) console.log('[ClickPopulate] Triggering snapshot fetch for', code);
                    updateAddFormLiveSnapshot(code);
                } catch(err) { if (DEBUG_MODE) console.warn('Click-to-populate snapshot failed', err); }
            }
        });
        // Mute/unmute button
        const toggleBtn = item.querySelector('.toggle-alert-btn');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                try {
                    await toggleAlertEnabled(share.id); // internal handles optimistic update + banner refresh
                    showTargetHitDetailsModal(); // rebuild list to reflect new grouping/button text
                } catch(err) {
                    console.warn('Toggle alert failed', err);
                }
            });
        }
        return item;
    };

    const hasEnabled = sharesAtTargetPrice.length > 0;
    const hasMuted = Array.isArray(sharesAtTargetPriceMuted) && sharesAtTargetPriceMuted.length > 0;
    if (!hasEnabled && !hasMuted) {
        const p = document.createElement('p');
        p.className = 'no-alerts-message';
    p.textContent = 'No shares currently at alert target.';
        targetHitSharesList.appendChild(p);
    } else {
        if (hasEnabled) {
            const enabledHeader = document.createElement('h3');
            enabledHeader.textContent = 'Target hit';
            enabledHeader.className = 'target-hit-section-title target-hit-enabled-header';
            enabledHeader.id = 'targetHitHeader';
            // Append after global movers block (which was added first if present)
            targetHitSharesList.appendChild(enabledHeader);
            sharesAtTargetPrice.forEach(share => targetHitSharesList.appendChild(makeItem(share, false)));
        }
        if (hasMuted) {
            const mutedHeader = document.createElement('h3');
            mutedHeader.textContent = 'Muted Alerts';
            targetHitSharesList.appendChild(mutedHeader);
            sharesAtTargetPriceMuted.forEach(share => targetHitSharesList.appendChild(makeItem(share, true)));
        }
    }

    showModal(targetHitDetailsModal);
    __userInitiatedTargetModal = true; // mark that user has seen modal this session
    logDebug('Target Hit Modal: Displayed details. Enabled=' + sharesAtTargetPrice.length + ' Muted=' + (sharesAtTargetPriceMuted?sharesAtTargetPriceMuted.length:0));
}

// Expose the function to window object for global access
window.showTargetHitDetailsModal = showTargetHitDetailsModal;
window.recomputeTriggeredAlerts = recomputeTriggeredAlerts;

// Debug helper: dumps current trigger state for inspection in browser console
if (typeof window !== 'undefined') {
    window.dumpTriggerState = function() {
        try {
            const sampleLive = {};
            (Array.isArray(sharesAtTargetPrice) ? sharesAtTargetPrice : []).forEach(s => {
                const code = (s && (s.shareName || s.code || s.shareCode || s.symbol) || '').toUpperCase();
                sampleLive[code] = window.livePrices && window.livePrices[code] ? window.livePrices[code] : null;
            });
            const out = {
                timestamp: new Date().toISOString(),
                sharesAtTargetPrice: (Array.isArray(sharesAtTargetPrice) ? sharesAtTargetPrice.map(s => ({ id: s.id, code: (s.shareName||s.code||s.shareCode||'').toUpperCase(), name: s.companyName || s.shareName || s.name || '' })) : []),
                sharesAtTargetPriceMuted: (Array.isArray(sharesAtTargetPriceMuted) ? sharesAtTargetPriceMuted.map(s => ({ id: s.id, code: (s.shareName||s.code||s.shareCode||'').toUpperCase(), name: s.companyName || s.shareName || s.name || '' })) : []),
                alertsEnabledMapSize: (alertsEnabledMap && typeof alertsEnabledMap.size !== 'undefined') ? alertsEnabledMap.size : null,
                liveSamples: sampleLive,
                liveKeysCount: Object.keys(window.livePrices || {}).length,
                allSharesDataCount: Array.isArray(allSharesData) ? allSharesData.length : null
            };
            console.groupCollapsed('[DumpTriggerState]');
            console.log(out);
            console.groupEnd();
            return out;
        } catch(e) { console.error('dumpTriggerState failed', e); return null; }
    };
}

// Toggle GA_SUMMARY enabled flag (mute/unmute for session)
async function toggleGlobalSummaryEnabled() {
    try {
        if (!db || !currentUserId || !firestore) return;
        const alertsCol = firestore.collection(db, 'artifacts/' + currentAppId + '/users/' + currentUserId + '/alerts');
        const summaryRef = firestore.doc(alertsCol, 'GA_SUMMARY');
        const snap = await firestore.getDoc(summaryRef);
        let currentEnabled = true;
        if (snap.exists()) {
            const d = snap.data();
            currentEnabled = (d.enabled !== false);
        }
        await firestore.setDoc(summaryRef, { enabled: !currentEnabled, updatedAt: firestore.serverTimestamp() }, { merge: true });
        // Optimistic update of local cache
        if (globalAlertSummary) globalAlertSummary.enabled = !currentEnabled;
        updateTargetHitBanner();
        if (targetHitDetailsModal && targetHitDetailsModal.style.display !== 'none') showTargetHitDetailsModal();
        showCustomAlert((!currentEnabled ? 'Global Alert unmuted' : 'Global Alert muted'), 1200);
    } catch(e) { console.warn('Global Alert mute toggle failed', e); }
}

// Force Update: fully clears caches, unregisters service workers, clears storage, reloads fresh
async function forceHardUpdate() {
    try {
        showCustomAlert('Forcing update...', 1200);
        // Unregister all service workers
        if (navigator.serviceWorker) {
            const regs = await navigator.serviceWorker.getRegistrations();
            await Promise.all(regs.map(r=>r.unregister().catch(()=>{})));
            if (DEBUG_MODE) console.log('[ForceUpdate] Service workers unregistered:', regs.length);
        }
        // Clear caches
        if (window.caches && caches.keys) {
            const keys = await caches.keys();
            await Promise.all(keys.map(k=>caches.delete(k).catch(()=>{})));
            if (DEBUG_MODE) console.log('[ForceUpdate] Caches cleared:', keys);
        }
        // Clear IndexedDB databases (best-effort; some browsers may not support indexedDB.databases)
        try {
            if (window.indexedDB && indexedDB.databases) {
                const dbs = await indexedDB.databases();
                if (Array.isArray(dbs)) {
                    await Promise.all(dbs.map(db => db && db.name ? new Promise(res=>{ const req = indexedDB.deleteDatabase(db.name); req.onsuccess=req.onerror=req.onblocked=()=>res(); }) : Promise.resolve()));
                    if (DEBUG_MODE) console.log('[ForceUpdate] IndexedDB databases cleared:', dbs.map(d=>d && d.name));
                }
            }
        } catch(idbErr) { if (DEBUG_MODE) console.warn('[ForceUpdate] IndexedDB clear not fully supported', idbErr); }
        // Clear local/session storage (preserve maybe user theme? currently wiping everything for guaranteed fresh load)
        try { localStorage.clear(); } catch(_) {}
        try { sessionStorage.clear(); } catch(_) {}
        // Small delay to allow SW unregister & cache deletion to settle
        setTimeout(()=>{ window.location.reload(true); }, 300);
    } catch(err) {
        console.warn('[ForceUpdate] Failed, manual hard reload may be required.', err);
        showCustomAlert('Force update failed. Please hard reload manually.', 2500);
    }
}
if (targetHitIconBtn) {
    targetHitIconBtn.addEventListener('click', (event) => {
        logDebug('Target Alert: Icon button clicked. Opening details modal.');
        __userInitiatedTargetModal = true;
        ALLOW_ALERT_MODAL_AUTO_OPEN = true; // enable future passive opens this session
        showTargetHitDetailsModal({ explicit:true, userInitiated:true, allowDuringInitialLoad:true });
    });
}
let firebaseServices;

document.addEventListener('DOMContentLoaded', async function() {
    if (window.__appDomBootstrapped) { try { console.debug('Init: DOMContentLoaded bootstrap already run; skipping'); } catch(_){} return; }
    window.__appDomBootstrapped = true;
    // Prefer hub singletons
    db = hubDb; auth = hubAuth; currentAppId = hubAppId; firestore = hubFs; authFunctions = hubAuthFx;
    try { window._firebaseInitialized = !!hubInit; } catch(_) {}
    initializeAppEventListeners(()=>{});
    // Initialize theme management with a delay to ensure DOM is ready
    setTimeout(() => {
        initializeTheme();
    }, 100);
    if (!window.__initializeAppCalled) { window.__initializeAppCalled = true; initializeApp(); }
});

function initializeApp() {
    if (db && auth && currentAppId && firestore && authFunctions) {
        logDebug('Firebase Ready: DB, Auth, and AppId assigned from firebase.js. Setting up auth state listener.');

        // Ensure persistence is set once
        try {
            // Force persistent local storage for auth so the user remains signed in across app restarts.
            // Prefer browserLocalPersistence; fall back to browserSessionPersistence only if local is unavailable.
            if (authFunctions.setPersistence) {
                const targetPersistence = authFunctions.browserLocalPersistence || authFunctions.browserSessionPersistence;
                if (targetPersistence) {
                    authFunctions
                        .setPersistence(auth, targetPersistence)
                        .then(() => logDebug('Auth: Persistence set to ' + (targetPersistence === authFunctions.browserSessionPersistence ? 'browserSessionPersistence' : 'browserLocalPersistence') + '.'))
                        .catch((e) => console.warn('Auth: Failed to set persistence, continuing with default.', e));
                }
            }
        } catch (e) {
            console.warn('Auth: Failed to set persistence (outer), continuing with default.', e);
        }

    window.__handleAuthStateChange = async (user) => {
        // Always clear notification state on any auth state change (sign-in, sign-out, refresh, switch)
        clearAllNotificationState();
            if (user) {
                // Restore movers view if it was active prior to a storage reset during auth
                try {
                    const pre = sessionStorage.getItem('preResetLastSelectedView');
                    if (pre === '__movers' && !localStorage.getItem('lastSelectedView')) {
                        setLastSelectedView('__movers');
                        sessionStorage.removeItem('preResetLastSelectedView');
                    }
                } catch(_) {}
                currentUserId = user.uid;
                window.currentUserId = user.uid; // Set on window object for global access
                logDebug('AuthState: User signed in: ' + user.uid);

                // Restore user's last state from localStorage
                restorePersistedState();

                // Snapshot restore happens synchronously on module load; UI shows unified loader until live data arrives.
                logDebug && logDebug('AuthState: User email: ' + user.email);
                try { localStorage.removeItem('authRedirectAttempted'); localStorage.removeItem('authRedirectReturnedNoUser'); } catch(_) {}
                // Use dynamic update instead of hard-coded label so it reflects current selection
                updateMainTitle();
                logDebug('AuthState: Dynamic title initialized via updateMainTitle().');
                updateMainButtonsState(true);
                window._userAuthenticated = true; // Mark user as authenticated
                try { window.__authReadyAt = Date.now(); } catch(_) {}

                if (mainContainer) {
                    mainContainer.classList.remove('app-hidden');
                }
                if (appHeader) {
                    appHeader.classList.remove('app-hidden');
                }
                adjustMainContentPadding();

                        // Ensure header click bindings are attached after header becomes visible
                        try { ensureTitleStructure(); bindHeaderInteractiveElements(); } catch(e) { console.warn('Header binding: failed to bind after auth show', e); }

                if (splashKangarooIcon) {
                    splashKangarooIcon.classList.add('pulsing');
                    logDebug('Splash Screen: Started pulsing animation after sign-in.');
                }

                targetHitIconDismissed = localStorage.getItem('targetHitIconDismissed') === 'true';
                // Immediately reflect any persisted target count before live data loads
                try { updateTargetHitBanner(); } catch(e) { console.warn('Auth early Target Alert restore failed', e); }

                // Robust preference loading with proper sequencing
                logDebug('Auth: Starting robust preference loading sequence...');

                try {
                    // Step 1: Load user data first
                    await loadUserWatchlistsAndSettings();
                    logDebug('Auth: User watchlists and settings loaded successfully');
                } catch (error) {
                    console.warn('Auth: Failed to load user watchlists and settings:', error);
                    // Continue with other steps even if this fails
                }

                try {
                    // Step 2: Load user preferences
                    await loadUserPreferences();
                    logDebug('Auth: User preferences loaded successfully');
                } catch (error) {
                    console.warn('Auth: Failed to load user preferences:', error);
                }

                // UI nicety: ensure placeholder text in numeric inputs clears on focus/input (mobile + desktop)
                try {
                    const smartInputs = Array.from(document.querySelectorAll('input.smart-ph'));
                    smartInputs.forEach(inp => {
                        // On focus, clear placeholder so it doesn't stay visible while typing on some mobile browsers
                        inp.addEventListener('focus', () => {
                            inp.dataset._ph = inp.getAttribute('placeholder') || '';
                            inp.setAttribute('placeholder', '');
                        });
                        // If user types, ensure placeholder stays cleared
                        inp.addEventListener('input', () => {
                            if (inp.value && inp.value.length > 0) inp.setAttribute('placeholder', '');
                        });
                        // On blur, if input is empty, restore original placeholder
                        inp.addEventListener('blur', () => {
                            if (!inp.value || inp.value.length === 0) {
                                const original = inp.dataset._ph || '';
                                if (original) inp.setAttribute('placeholder', original);
                                else inp.removeAttribute('placeholder');
                            }
                        });
                    });
                } catch(_) {}
                    // Continue with fallback preferences

                try {
                    // Step 3: Restore view and mode with error recovery
                    await robustRestoreViewAndModeFromPreferences();
                    logDebug('Auth: View and mode preferences restored successfully');
                } catch (error) {
                    console.warn('Auth: Failed to restore view and mode preferences:', error);
                    // Continue with default settings
                }
                try { ensureTitleStructure(); } catch(e) {}

                // Start global view mode enforcer for continuous monitoring
                try {
                    startGlobalViewModeEnforcer();
                    logDebug('Auth: Global view mode enforcer started');
                } catch (error) {
                    console.warn('Auth: Failed to start global view mode enforcer:', error);
                }

                // Note: View mode restoration is now handled by robustRestoreViewAndModeFromPreferences()
                // above. This duplicate code has been removed to prevent conflicts.
                // Start alerts listener (enabled alerts only; muted excluded from notifications)
                await loadTriggeredAlertsListener(db, firestore, currentUserId, currentAppId);
                // startGlobalSummaryListener(); // Deprecated for notifications: persistent *_HITS now used exclusively
                startGlobalHiLoListener();
                startGlobalMoversListener(); // NEW centralized movers listener
                startCustomTriggerHitsListener();
                // On first auth load, force one live fetch even if starting in Cash view to restore alerts
                const forcedOnce = localStorage.getItem('forcedLiveFetchOnce') === 'true';
                // Unblock UI immediately; prices can finish in background
                try { window._livePricesLoaded = true; hideSplashScreenIfReady(); } catch(_) {}
                try { console.log('[Live Price] Invoking initial fetch...'); } catch(_) {}
                const __livePriceSafetyTimer = setTimeout(() => {
                    try {
                        console.warn('Live Price: safety timeout reached; marking as loaded to unblock UI');
                        window._livePricesLoaded = true;
                        hideSplashScreenIfReady();
                    } catch(_) {}
                }, 8000);
                try {
                await fetchLivePrices({ forceLiveFetch: !forcedOnce, cacheBust: true });
                } finally {
                    try { clearTimeout(__livePriceSafetyTimer); } catch(_) {}
                }
                try { if (!forcedOnce) localStorage.setItem('forcedLiveFetchOnce','true'); } catch(e) {}
                startLivePriceUpdates();
                // Extra safety: ensure target modal not left open from cached state on fresh auth
                try { if (targetHitDetailsModal && targetHitDetailsModal.style.display !== 'none' && window.__initialLoadPhase) hideModal(targetHitDetailsModal); } catch(_){ }

                setAllAsxCodes(await loadAsxCodesFromCSV());
                logDebug(`ASX Autocomplete: Loaded ${allAsxCodes.length} codes for search.`);

                // Legacy block replaced by restoreViewAndModeFromPreferences()
            }

            else {
                currentUserId = null;
                window.currentUserId = null; // Clear from window object
                // Clear all notification state to prevent leakage between users
                clearAllNotificationState();
                // Reset title safely using the inner span, do not expand click target
                try { ensureTitleStructure(); const t = document.getElementById('dynamicWatchlistTitleText'); if (t) t.textContent = 'Share Watchlist'; } catch(e) {}
                logDebug('AuthState: User signed out.');
                updateMainButtonsState(false);
                clearShareList();
                clearWatchlistUI();
                userCashCategories = []; // Clear cash data on logout
                if (cashCategoriesContainer) cashCategoriesContainer.innerHTML = ''; // Clear cash UI
                if (totalCashDisplay) totalCashDisplay.textContent = '$0.00'; // Reset total cash
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                applyTheme('system-default');
                if (unsubscribeShares) {
                    unsubscribeShares();
                    unsubscribeShares = null;
                    logDebug('Firestore Listener: Unsubscribed from shares listener on logout.');
                }
                if (unsubscribeCashCategories) { // NEW: Unsubscribe from cash categories
                    unsubscribeCashCategories();
                    unsubscribeCashCategories = null;
                    logDebug('Firestore Listener: Unsubscribed from cash categories listener on logout.');
                }
                if (unsubscribeAlerts) { // NEW: Unsubscribe from alerts
                    try { unsubscribeAlerts(); } catch(_) {}
                    unsubscribeAlerts = null;
                    logDebug('Firestore Listener: Unsubscribed from alerts listener on logout.');
                }
                // stopGlobalSummaryListener(); // Not started for notifications
                stopGlobalHiLoListener();
                stopCustomTriggerHitsListener();
                stopLivePriceUpdates();

                window._userAuthenticated = false; // Mark user as not authenticated
                // If signed out, ensure splash screen is visible for sign-in
                if (splashScreen) {
                    splashScreen.style.display = 'flex'; // Ensure splash screen is visible
                    splashScreen.classList.remove('hidden'); // Ensure it's not hidden
                    document.body.style.overflow = 'hidden'; // Re-apply overflow hidden
                    if (splashKangarooIcon) {
                        splashKangarooIcon.classList.remove('pulsing'); // Stop animation if signed out
                    }
                    if (splashSignInBtn) {
                        splashSignInBtn.disabled = false; // Enable sign-in button
                        const buttonTextSpan = splashSignInBtn.querySelector('span');
                        if (buttonTextSpan) {
                            buttonTextSpan.textContent = 'Sign in with Google'; // Reset only the text, not the icon
                        }
                    }
                    // Hide main app content
                    if (mainContainer) {
                        mainContainer.classList.add('app-hidden');
                    }
                    if (appHeader) {
                        appHeader.classList.add('app-hidden');
                    }
                    logDebug('Splash Screen: User signed out, splash screen remains visible for sign-in.');
                } else {
                    console.warn('Splash Screen: User signed out, but splash screen element not found. App content might be visible.');
                }
                // NEW: Reset targetHitIconDismissed and clear localStorage entry on logout for a fresh start on next login
                targetHitIconDismissed = false;
                localStorage.removeItem('targetHitIconDismissed');

            }
            if (!window._appLogicInitialized) {
                initializeAppLogic();
                window._appLogicInitialized = true;
            } else {
                // If app logic already initialized, ensure view mode is applied after auth.
                // This handles cases where user signs out and then signs back in.
                // Use the robust application with retry mechanism
                try {
                    await applyViewModeToUI(currentMobileViewMode);
                } catch (error) {
                    console.warn('Auth: Failed to reapply view mode after re-auth:', error);
                    startViewModeWatcher(); // Fallback watcher
                }

                // Restart global enforcer if needed
                try {
                    startGlobalViewModeEnforcer();
                    logDebug('Auth: Global view mode enforcer restarted after re-auth');
                } catch (error) {
                    console.warn('Auth: Failed to restart global view mode enforcer:', error);
                }
            }
            // Call renderWatchlist here to ensure correct mobile card rendering after auth state is set
            renderWatchlist();
            try { ensureTitleStructure(); } catch(e) {}
            // Removed: adjustMainContentPadding(); // Removed duplicate call, now handled inside if (user) block
        };
        // Prevent duplicate auth listener registration
        if (!window.__authListenerSetup) {
            window.__authListenerSetup = true;
            setupAuthListener(auth, authFunctions);
        } else {
            try { console.debug('Auth: setupAuthListener already registered; skipping duplicate'); } catch(_) {}
        }
    } else {
    console.error('Firebase: Firebase objects (db, auth, appId, firestore, authFunctions) are not available on DOMContentLoaded. Firebase initialization likely failed in index.html.');
        const errorDiv = document.getElementById('firebaseInitError');
        if (errorDiv) {
                errorDiv.style.display = 'block';
        }
        updateMainButtonsState(false);
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        applyTheme('system-default');
        // NEW: Call adjustMainContentPadding even if Firebase fails, to ensure some basic layout
        adjustMainContentPadding();
        // NEW: Hide splash screen if Firebase fails to initialize
        hideSplashScreen();
    }

    // Test card removed - 52-week low detection is now working properly
    // Ensure header interactive bindings are attached even on first load
    try { ensureTitleStructure(); bindHeaderInteractiveElements(); } catch(e) { console.warn('Header binding: failed to bind on DOMContentLoaded', e); }
    // Early notification restore from persisted count
    try { if (typeof updateTargetHitBanner === 'function') updateTargetHitBanner(); } catch(e) { console.warn('Early Target Alert restore failed', e); }

    // Ensure Edit Current Watchlist button updates when watchlist selection changes
    if (watchlistSelect) {
        watchlistSelect.addEventListener('change', function() {
            updateMainButtonsState(true);
            try { updateMainTitle(); } catch(e) {}
        });
    }

    // Display App Version on splash screen
    const splashScreenEl = document.getElementById('splashScreen');
    if (splashScreenEl) {
        let versionEl = document.getElementById('splashAppVersion');
        if (!versionEl) {
            versionEl = document.createElement('p');
            versionEl.id = 'splashAppVersion';
            versionEl.className = 'app-version-splash';
            splashScreenEl.prepend(versionEl);
        }
    versionEl.textContent = 'v' + APP_VERSION;
    }
    // Splash flags are managed by auth/data/price flows and Firebase hub; do not reset here

    // Show splash screen immediately on DOMContentLoaded
    if (splashScreen) {
        splashScreen.style.display = 'flex'; // Ensure it's visible
        splashScreen.classList.remove('hidden'); // Ensure it's not hidden
        splashScreenReady = true; // Mark splash screen as ready
        document.body.style.overflow = 'hidden'; // Prevent scrolling of underlying content
        logDebug('Splash Screen: Displayed on DOMContentLoaded, body overflow hidden.');
        // If we are returning from a redirect attempt, keep the button in loading state while we complete sign-in
        try {
            if (localStorage.getItem('authRedirectAttempted') === '1' && typeof updateSplashSignInButtonState === 'function') {
                updateSplashSignInButtonState('loading', 'Completing sign-in…');
            }
        } catch(_) {}
    } else {
        console.warn('Splash Screen: Splash screen element not found. App will start without it.');
        // If splash screen not found, set flags to true and hide the splash screen logic.
        // This is a fallback to allow the app to run without the splash screen HTML.
        window._firebaseInitialized = true;
        window._userAuthenticated = false;
        window._appDataLoaded = true;
        window._livePricesLoaded = true;
    } // This closing brace completes the 'else' block for the splash screen check.

    // Initially hide main app content and header
    if (mainContainer) {
        mainContainer.classList.add('app-hidden');
    }

    // Discovery modal close binding
    const discoverModal = document.getElementById('discoverGlobalModal');
    if (discoverModal && !discoverModal.__boundClose) {
        discoverModal.__boundClose = true;
        const cls = discoverModal.querySelector('.close-button');
        if (cls) cls.addEventListener('click', ()=> hideModal(discoverModal));
        discoverModal.addEventListener('mousedown', (e)=>{ if (e.target === discoverModal) hideModal(discoverModal); });
    }
    if (appHeader) {
        appHeader.classList.add('app-hidden');
    }

    // Fallback Movers restore: if persisted as last view but not applied yet (e.g., due to early race), re-apply after short delay
    setTimeout(()=>{
        try {
            const wantMovers = localStorage.getItem('lastSelectedView') === '__movers';
            const haveMovers = (getCurrentSelectedWatchlistIds() && getCurrentSelectedWatchlistIds()[0] === '__movers');
            if (wantMovers && !haveMovers) {
                setCurrentSelectedWatchlistIds(['__movers']);
                if (watchlistSelect) watchlistSelect.value = '__movers';
                if (typeof renderWatchlist === 'function') renderWatchlist();
                enforceMoversVirtualView(true);
                console.log('[Movers restore][fallback DOMContentLoaded] applied');
            }
        } catch(e){ console.warn('[Movers restore][fallback DOMContentLoaded] failed', e); }
    }, 1300);
    // already set from hub

    if (db && auth && currentAppId && firestore && authFunctions) {
        logDebug('Firebase Ready: DB, Auth, and AppId assigned from firebase.js. Setting up auth state listener.');

        // Ensure persistence is set once
        try {
            // Force persistent local storage for auth so the user remains signed in across app restarts.
            // Prefer browserLocalPersistence; fall back to browserSessionPersistence only if local is unavailable.
            if (authFunctions.setPersistence) {
                const targetPersistence = authFunctions.browserLocalPersistence || authFunctions.browserSessionPersistence;
                if (targetPersistence) {
                    authFunctions
                        .setPersistence(auth, targetPersistence)
                        .then(() => logDebug('Auth: Persistence set to ' + (targetPersistence === authFunctions.browserSessionPersistence ? 'browserSessionPersistence' : 'browserLocalPersistence') + '.'))
                        .catch((e) => console.warn('Auth: Failed to set persistence, continuing with default.', e));
                }
            }
        } catch (e) {
            console.warn('Auth: Failed to set persistence (outer), continuing with default.', e);
        }

        // Prevent duplicate auth listener registration (late path)
        if (!window.__authListenerSetup) {
            window.__authListenerSetup = true;
            setupAuthListener(auth, authFunctions);
        } else {
            try { console.debug('Auth: setupAuthListener already registered (late path); skipping'); } catch(_) {}
        }
    } else {
    console.error('Firebase: Firebase objects (db, auth, appId, firestore, authFunctions) are not available on DOMContentLoaded. Firebase initialization likely failed in index.html.');
        const errorDiv = document.getElementById('firebaseInitError');
        if (errorDiv) {
                errorDiv.style.display = 'block';
        }
        updateMainButtonsState(false);
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        applyTheme('system-default');
        // NEW: Call adjustMainContentPadding even if Firebase fails, to ensure some basic layout
        adjustMainContentPadding();
        // NEW: Hide splash screen if Firebase fails to initialize
        hideSplashScreen();
    }
}

// Simple Diagnostics helper for non-coders (adds click on Diagnostics menu button to copy key info)
try {
    (function initSimpleDiagnostics(){
        const attemptBind = () => {
            const btn = document.getElementById('diagnosticsBtn');
            if(!btn) return false;
            if(btn.__diagBound) return true; btn.__diagBound = true;
            btn.addEventListener('click', async () => {
                try {
                    const diag = {};
                    // Keep this in sync with the Build Marker comment near initializeAppLogic end
                    diag.buildMarker = 'v0.1.13';
                    diag.time = new Date().toISOString();
                    diag.userId = (typeof currentUserId!=='undefined')? currentUserId : null;
                    diag.activeWatchlistId = (typeof activeWatchlistId!=='undefined')? activeWatchlistId : null;
                    diag.selectedWatchlists = (typeof currentSelectedWatchlistIds!=='undefined')? currentSelectedWatchlistIds : [];
                    diag.alertCounts = {
                        enabled: Array.isArray(sharesAtTargetPrice)? sharesAtTargetPrice.length : null,
                        muted: Array.isArray(sharesAtTargetPriceMuted)? sharesAtTargetPriceMuted.length : null,
                        globalSummary: (globalAlertSummary && globalAlertSummary.totalCount) || 0
                    };
                        diag.globalSummary = globalAlertSummary || null;
                    diag.lastLivePriceSample = Object.entries(livePrices||{}).slice(0,10);

            // === SUPER DEBUG TOOL (Environment Snapshot) ===
            // Invoke manually: window.superDebugDump(); or press Alt+Shift+D
            // Auto-enable if URL has ?superdebug
            (function installSuperDebug(){
                if (window.superDebugDump) return; // idempotent
                function superDebugDump(){
                    const data = { ts: new Date().toISOString() };
                    try {
                        data.location = location.href;
                        // Scripts inventory
                        data.scripts = Array.from(document.scripts).map(s=>({
                            src: s.src || null,
                            inlineHead: (!s.src && s.textContent) ? s.textContent.slice(0,120) : null
                        }));
                        // Build marker attempt (inline variable not guaranteed)
                        try {
                            const markerMatch = /Build Marker:[^\n]+/.exec(document.documentElement.innerHTML);
                            data.buildMarkerFound = markerMatch ? markerMatch[0] : null;
                        } catch(err){ data.buildMarkerError = ''+err; }
                        // Overlay state
                        const overlay = document.querySelector('.sidebar-overlay');
                        if (overlay) {
                            data.overlay = {
                                classes: Array.from(overlay.classList),
                                    dataset: { ...overlay.dataset },
                                hasUnifiedHandler: !!overlay._unifiedHandler
                            };
                        }
                        // Target Hit Modal structure
                        const targetList = document.getElementById('targetHitSharesList');
                        const gmTitle = document.getElementById('globalMoversTitle');
                        if (targetList) {
                            data.targetHitModal = {
                                hasGlobalMoversTitle: !!gmTitle,
                                firstFiveChildIdsOrClasses: Array.from(targetList.children).slice(0,5).map(el=>el.id||el.className||el.tagName),
                                movementDeltaCount: targetList.querySelectorAll('.movement-combo').length
                            };
                        }
                        // Ignoring line style
                        const ignoreEl = document.querySelector('.global-summary-detail.ignoring-line');
                        if (ignoreEl) {
                            const cs = getComputedStyle(ignoreEl);
                            data.ignoringLineComputed = { fontSize: cs.fontSize, fontWeight: cs.fontWeight, textTransform: cs.textTransform };
                        }
                        // Live prices sample
                        try { data.livePricesSample = Object.entries(livePrices||{}).slice(0,5); } catch(_){ data.livePricesSampleError = true; }
                        data.globalAlertSummary = (globalAlertSummary ? {
                            total: globalAlertSummary.totalCount,
                            inc: globalAlertSummary.increaseCount,
                            dec: globalAlertSummary.decreaseCount,
                            enabled: globalAlertSummary.enabled,
                            min: globalAlertSummary.appliedMinimumPrice
                        } : null);
                        data.targetHitCounts = {
                            enabled: Array.isArray(sharesAtTargetPrice)? sharesAtTargetPrice.length : null,
                            muted: Array.isArray(sharesAtTargetPriceMuted)? sharesAtTargetPriceMuted.length : null
                        };
                        data.currentUserId = (typeof currentUserId!=='undefined')? currentUserId : null;
                        data.selectedWatchlists = (typeof currentSelectedWatchlistIds!=='undefined')? currentSelectedWatchlistIds : [];
                        // Resource timing for script/style
                        try {
                            data.resourceEntries = performance.getEntriesByType('resource').filter(r=>/script\.js|style\.css/.test(r.name)).map(r=>({ name:r.name, transferSize:r.transferSize, encodedBodySize:r.encodedBodySize, initiator:r.initiatorType }));
                        } catch(_){ }
                        // Caches & SW (async portion)
                        const asyncs = [];
                        if (window.caches && caches.keys) {
                            asyncs.push((async()=>{ const keys = await caches.keys(); data.caches = {}; for (const k of keys){ try { const c = await caches.open(k); const reqs = await c.keys(); data.caches[k] = reqs.length; } catch(e){ data.caches[k]='ERR'; } } })());
                        }
                        if (navigator.serviceWorker && navigator.serviceWorker.getRegistrations) {
                            asyncs.push((async()=>{ const regs = await navigator.serviceWorker.getRegistrations(); data.serviceWorkers = regs.map(r=>({ scope:r.scope, active:r.active?.scriptURL, waiting:r.waiting?.scriptURL, installing:r.installing?.scriptURL })); data.swController = (navigator.serviceWorker.controller && navigator.serviceWorker.controller.state)||null; })());
                        }
                        Promise.all(asyncs).finally(()=>{
                            const json = JSON.stringify(data, null, 2);
                            console.groupCollapsed('%cSUPER DEBUG SNAPSHOT','color:#a49393;font-weight:bold;');
                            console.log(json);
                            console.groupEnd();
                            // Ensure on-page panel ("notepad") exists for user-friendly copying
                            try {
                                let panel = document.getElementById('superDebugPanel');
                                if (!panel) {
                                    panel = document.createElement('div');
                                    panel.id = 'superDebugPanel';
                                    panel.style.cssText = 'position:fixed;bottom:12px;right:12px;z-index:99999;width:360px;max-width:90vw;background:#1e1e1e;color:#eee;font:12px/1.3 monospace;border:1px solid #555;border-radius:6px;box-shadow:0 4px 14px rgba(0,0,0,.4);display:flex;flex-direction:column;';
                                    panel.innerHTML = `
                                        <div style="display:flex;align-items:center;justify-content:space-between;padding:4px 8px;background:#2c2c2c;border-bottom:1px solid #444;border-radius:6px 6px 0 0;cursor:move;user-select:none;">
                                            <strong style="font:600 12px system-ui,Segoe UI,Arial;">Super Debug Snapshot</strong>
                                            <div style="display:flex;gap:6px;align-items:center;">
                                                <button id="superDebugMinBtn" title="Minimize" style="background:#444;color:#ddd;border:0;padding:2px 6px;border-radius:4px;font-size:11px;cursor:pointer;">_</button>
                                                <button id="superDebugCloseBtn" title="Close" style="background:#c0392b;color:#fff;border:0;padding:2px 6px;border-radius:4px;font-size:11px;cursor:pointer;">×</button>
                                            </div>
                                        </div>
                                        <textarea id="superDebugTextArea" spellcheck="false" style="flex:1;min-height:180px;resize:vertical;background:#111;color:#8fdaff;padding:6px 8px;border:0;outline:none;border-radius:0 0 6px 6px;font:11px/1.35 monospace;white-space:pre;overflow:auto;"></textarea>
                                        <div style="display:flex;flex-wrap:wrap;gap:6px;padding:6px 8px;background:#2c2c2c;border-top:1px solid #444;">
                                            <button id="superDebugCopyBtn" style="background:#3a7bd5;color:#fff;border:0;padding:4px 10px;border-radius:4px;font-size:11px;cursor:pointer;">Copy</button>
                                            <button id="superDebugDownloadBtn" style="background:#27ae60;color:#fff;border:0;padding:4px 10px;border-radius:4px;font-size:11px;cursor:pointer;">Download</button>
                                            <button id="superDebugClearBtn" style="background:#555;color:#eee;border:0;padding:4px 10px;border-radius:4px;font-size:11px;cursor:pointer;">Clear</button>
                                        </div>`;
                                    document.body.appendChild(panel);

                                    // Drag to move functionality (simple implementation)
                                    (function enableDrag(el){
                                        const header = el.firstElementChild; if(!header) return; let sx=0, sy=0, ox=0, oy=0, dragging=false;
                                        header.addEventListener('mousedown', (e)=>{ dragging=true; sx=e.clientX; sy=e.clientY; const r=el.getBoundingClientRect(); ox=r.left; oy=r.top; document.addEventListener('mousemove', move, true); document.addEventListener('mouseup', up, true); });
                                        function move(e){ if(!dragging) return; const dx=e.clientX-sx; const dy=e.clientY-sy; el.style.left=(ox+dx)+'px'; el.style.top=(oy+dy)+'px'; el.style.right='auto'; el.style.bottom='auto'; }
                                        function up(){ dragging=false; document.removeEventListener('mousemove', move, true); document.removeEventListener('mouseup', up, true); }
                                    })(panel);

                                    // Button handlers
                                    panel.querySelector('#superDebugCloseBtn').addEventListener('click', ()=> panel.remove());
                                    panel.querySelector('#superDebugMinBtn').addEventListener('click', ()=> {
                                        const ta = panel.querySelector('#superDebugTextArea');
                                        if (!ta) return; const hidden = ta.style.display==='none';
                                        ta.style.display = hidden ? 'block':'none';
                                    });
                                    panel.querySelector('#superDebugCopyBtn').addEventListener('click', ()=> {
                                        const ta = panel.querySelector('#superDebugTextArea');
                                        ta.select(); try { document.execCommand('copy'); showCustomAlert && showCustomAlert('Copied snapshot'); } catch(_) {}
                                    });
                                    panel.querySelector('#superDebugDownloadBtn').addEventListener('click', ()=> {
                                        try { const blob = new Blob([panel.querySelector('#superDebugTextArea').value], {type:'application/json'}); const a=document.createElement('a'); a.download='superdebug-'+Date.now()+'.json'; a.href=URL.createObjectURL(blob); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 1500);} catch(_) {}
                                    });
                                    panel.querySelector('#superDebugClearBtn').addEventListener('click', ()=> {
                                        const ta = panel.querySelector('#superDebugTextArea'); if(ta) ta.value='';
                                    });
                                }
                                const ta = panel.querySelector('#superDebugTextArea');
                                if (ta) { ta.value = json; ta.scrollTop = 0; }
                            } catch(panelErr) { console.warn('SuperDebug: Panel creation failed', panelErr); }

                            // Clipboard attempt (non-fatal)
                            if (navigator.clipboard && navigator.clipboard.writeText) {
                                navigator.clipboard.writeText(json).then(()=>console.log('SuperDebug: Snapshot copied to clipboard.')).catch(()=>console.warn('SuperDebug: Clipboard write failed.'));
                            }
                            try { showCustomAlert && showCustomAlert('Super-Debug snapshot captured', 2200); } catch(_) {}
                        });
                    } catch(err){
                        console.error('SuperDebug error', err);
                    }
                    return data;
                }
                window.superDebugDump = superDebugDump;
                document.addEventListener('keydown', (e)=>{ if (e.altKey && e.shiftKey && e.code==='KeyD'){ superDebugDump(); } }, true);
                if (window.location.search.includes('superdebug')) {
                    setTimeout(superDebugDump, 1500);
                }
            })();
            // === END SUPER DEBUG TOOL ===
                    diag.targetDismissed = !!targetHitIconDismissed;
                    diag.cacheKeys = (await caches.keys()).slice(0,10);
                    diag.serviceWorkers = (await navigator.serviceWorker.getRegistrations()).map(r=>({scope:r.scope, active:!!r.active}));
                    diag.swController = (navigator.serviceWorker.controller && navigator.serviceWorker.controller.state) || null;
                    diag.windowLocation = window.location.href;
                    diag.docHidden = document.hidden;
                    const text = JSON.stringify(diag, null, 2);
                    try { await navigator.clipboard.writeText(text); showCustomAlert('Diagnostics copied'); }
                    catch(_) { alert(text); }
                    console.log('[DiagnosticsDump]', diag);
                } catch(err){
                    console.warn('Diagnostics failed', err); alert('Diagnostics failed: '+err.message);
                }
            });
            return true;
        };
        if(!attemptBind()) {
            // Retry a few times in case sidebar not yet rendered
            let tries = 0; const intv = setInterval(()=>{ if(attemptBind()|| ++tries>10) clearInterval(intv); }, 500);
        }
    })();
} catch(_){ }
// --- Auto SuperDebug Fallback Trigger ---
// Ensures the ?superdebug URL parameter always triggers a snapshot even if
// superDebugDump is registered slightly later (e.g., waiting on other UI pieces).
(function autoSuperDebugFromParam(){
    try {
        const qs = window.location.search;
        if (!qs || !/(^|[?&])superdebug(=|&|$)/i.test(qs)) return; // parameter not present
        let attempts = 0;
        const maxAttempts = 24; // ~12s (24 * 500ms)
        function tryRun(){
            attempts++;
            if (typeof window.superDebugDump === 'function') {
                console.log('[SuperDebug] Auto-run via ?superdebug (attempt ' + attempts + ')');
                try { window.superDebugDump(); } catch(err){ console.warn('[SuperDebug] Auto-run failed', err); }
            } else if (attempts < maxAttempts) {
                setTimeout(tryRun, 500);
            } else {
                console.warn('[SuperDebug] Gave up waiting for superDebugDump after ' + attempts + ' attempts.');
                try { showCustomAlert && showCustomAlert('Super Debug tool not ready'); } catch(_) {}
            }
        }
        setTimeout(tryRun, 400); // slight delay to allow other scripts to attach
    } catch(err) {
        console.warn('[SuperDebug] Fallback init error', err);
    }
})();
// --- End Auto SuperDebug Fallback Trigger ---

// --- Super Debug Always-Install (resiliency) ---
// Some users reported the panel not appearing with ?superdebug. This independent
// installer guarantees superDebugDump exists early, without waiting for other UI.
(function ensureSuperDebugAlwaysInstalled(){
    if (window.superDebugDump) return; // already installed by main diagnostics block
    try {
        window.superDebugDump = function(){
            const data = { ts: new Date().toISOString(), href: location.href };
            try { data.BUILD_MARKER = (typeof window.BUILD_MARKER!=='undefined')? window.BUILD_MARKER : null; } catch(_){ }
            try { data.buildMarkerInline = (/Build Marker:[^\n]+/.exec(document.documentElement.innerHTML)||[])[0]||null; } catch(_){ }
            if (!data.buildMarkerInline && data.BUILD_MARKER) data.buildMarkerInline = '(inline marker not found, using BUILD_MARKER variable)';
            try { data.userId = (typeof currentUserId!=='undefined')? currentUserId : null; } catch(_){ }
            try { data.alertCounts = { enabled: (sharesAtTargetPrice||[]).length, muted: (sharesAtTargetPriceMuted||[]).length }; } catch(_){ }
            try { data.globalSummary = globalAlertSummary? { total: globalAlertSummary.totalCount, inc: globalAlertSummary.increaseCount, dec: globalAlertSummary.decreaseCount } : null; } catch(_){ }
            const json = JSON.stringify(data, null, 2);
            // Console output (always)
            console.groupCollapsed('%cSUPER DEBUG (minimal)','color:#7bd5ff');
            console.log(json); console.groupEnd();
            // Panel creation (idempotent)
            let panel = document.getElementById('superDebugPanel');
            if (!panel) {
                panel = document.createElement('div');
                panel.id = 'superDebugPanel';
                panel.style.cssText = 'position:fixed;bottom:14px;right:14px;z-index:99999;width:340px;max-width:92vw;background:#1b1f23;color:#eef;font:12px monospace;border:1px solid #444;border-radius:6px;display:flex;flex-direction:column;box-shadow:0 6px 18px rgba(0,0,0,.5);';
                panel.innerHTML = '<div style="display:flex;align-items:center;justify-content:space-between;padding:4px 8px;background:#24292e;border-bottom:1px solid #444;border-radius:6px 6px 0 0;">'+
                    '<strong style="font:600 12px system-ui">Super Debug</strong>'+
                    '<div style="display:flex;gap:6px;">'+
                        '<button id="sdCopyBtn" style="background:#0366d6;color:#fff;border:0;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:11px;">Copy</button>'+
                        '<button id="sdCloseBtn" style="background:#d62828;color:#fff;border:0;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:11px;">×</button>'+
                    '</div></div>'+
                    '<textarea id="sdText" spellcheck="false" style="flex:1;min-height:160px;margin:0;padding:6px 8px;background:#0d1117;color:#8fdaff;border:0;outline:none;resize:vertical;border-radius:0 0 6px 6px;font:11px/1.4 monospace;white-space:pre;overflow:auto;"></textarea>';
                document.body.appendChild(panel);
                panel.querySelector('#sdCloseBtn').addEventListener('click', ()=> panel.remove());
                panel.querySelector('#sdCopyBtn').addEventListener('click', ()=>{ const ta=panel.querySelector('#sdText'); ta.select(); try { document.execCommand('copy'); showCustomAlert && showCustomAlert('Copied'); } catch(_){} });
            }
            const ta = panel.querySelector('#sdText');
            if (ta) { ta.value = json; ta.scrollTop = 0; }
            if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(json).catch(()=>{}); }
            return data;
        };
        // Hotkey (duplicate-safe)
        document.addEventListener('keydown', function __sdKey(e){ if (e.altKey && e.shiftKey && e.code==='KeyD'){ try { window.superDebugDump(); } catch(_){} } }, true);
        // Auto-run if param present (quick attempt; the fallback poller above will also assist)
        if (window.location.search.includes('superdebug')) {
            setTimeout(()=>{ try { window.superDebugDump(); } catch(_){} }, 800);
        }
    } catch(err) { console.warn('[SuperDebug] minimal installer failed', err); }
})();
// --- End Super Debug Always-Install ---

